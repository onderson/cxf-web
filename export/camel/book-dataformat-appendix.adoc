[[ConfluenceContent]]
[[chapter-dataformat-Appendix]][[BookDataFormatAppendix-DataFormatAppendix]]
Data Format Appendix
--------------------

[[BookDataFormatAppendix-DataFormat]]
Data Format
~~~~~~~~~~~

Camel supports a pluggable DataFormat to allow messages to be marshalled
to and from binary or text formats to support a kind of
link:message-translator.html[Message Translator].

The following data formats are currently supported:

* Standard JVM object marshalling
** link:serialization.html[Serialization]
** link:string.html[String]

* Object marshalling
** link:avro.html[Avro]
** link:boon.html[Boon]
** link:hessian.html[Hessian]
** link:json.html[JSON]
** link:protobuf.html[Protobuf]
** link:yaml-data-format.html[YAML]

* Object/XML marshalling
** link:castor.html[Castor]
** link:jaxb.html[JAXB]
** link:xmlbeans.html[XmlBeans]
** link:xstream.html[XStream]
** link:jibx.html[JiBX]
** link:jackson-xml.html[Jackson XML]

* Object/XML/Webservice marshalling
** link:soap.html[SOAP]

* Direct JSON / XML marshalling
** link:xmljson.html[XmlJson]

* Flat data structure marshalling
** link:beanio.html[BeanIO]
** link:bindy.html[Bindy]
** link:csv.html[CSV]
** link:edi.html[EDI]
** link:flatpack-dataformat.html[Flatpack DataFormat]
** link:univocity-parsers-formats.html[uniVocity-parsers formats]

* Domain specific marshalling
** link:hl7-dataformat.html[HL7 DataFormat]

* Compression
** link:gzip-data-format.html[GZip data format]
** link:zip-dataformat.html[Zip DataFormat]
** link:zip-file-dataformat.html[Zip File DataFormat]
** link:lzf-data-format.html[LZF Data Format]
** link:tar-dataformat.html[Tar DataFormat]

* Security
** link:crypto.html[Crypto]
** link:crypto.html[PGP]
** link:xmlsecurity-dataformat.html[XMLSecurity DataFormat]

* Misc.
** link:base64.html[Base64]
** link:custom-dataformat.html[Custom DataFormat] - to use your own
custom implementation
** link:mime-multipart.html[MIME-Multipart]
** link:rss.html[RSS]
** link:tidymarkup.html[TidyMarkup]
** link:syslog.html[Syslog]
** link:ical.html[ICal]
** link:barcode-data-format.html[Barcode]- to read and generate barcodes
(QR-Code, PDF417, ...)

And related is the following:

* link:dataformat-component.html[DataFormat Component] for working with
link:data-format.html[Data Format]s as if it was a regular
link:component.html[Component] supporting link:endpoint.html[Endpoint]s
and link:uris.html[URIs].
* link:dozer-type-conversion.html[Dozer Type Conversion] using Dozer for
type converting POJOs

[[BookDataFormatAppendix-Unmarshalling]]
Unmarshalling
^^^^^^^^^^^^^

If you receive a message from one of the Camel
link:components.html[Components] such as link:file2.html[File],
link:http.html[HTTP] or link:jms.html[JMS] you often want to unmarshal
the payload into some bean so that you can process it using some
link:bean-integration.html[Bean Integration] or perform
link:predicate.html[Predicate] evaluation and so forth. To do this use
the *unmarshal* word in the link:dsl.html[DSL] in Java or the
link:xml-configuration.html[Xml Configuration].

For example

[source,brush:,java;,gutter:,false;,theme:,Default]
----
DataFormat jaxb = new JaxbDataFormat("com.acme.model");

from("activemq:My.Queue").
  unmarshal(jaxb).
  to("mqseries:Another.Queue");
----

The above uses a named DataFormat of _jaxb_ which is configured with a
number of Java package names. You can if you prefer use a named
reference to a data format which can then be defined in your
link:registry.html[Registry] such as via your link:spring.html[Spring]
XML file.

You can also use the DSL itself to define the data format as you use it.
For example the following uses Java serialization to unmarshal a binary
file then send it as an ObjectMessage to link:activemq.html[ActiveMQ]

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://foo/bar").
  unmarshal().serialization().
  to("activemq:Some.Queue");
----

[[BookDataFormatAppendix-Marshalling]]
Marshalling
^^^^^^^^^^^

Marshalling is the opposite of unmarshalling, where a bean is marshalled
into some binary or textual format for transmission over some transport
via a Camel link:component.html[Component]. Marshalling is used in the
same way as unmarshalling above; in the link:dsl.html[DSL] you can use a
DataFormat instance, you can configure the DataFormat dynamically using
the DSL or you can refer to a named instance of the format in the
link:registry.html[Registry].

The following example unmarshals via serialization then marshals using a
named JAXB data format to perform a kind of
link:message-translator.html[Message Translator]

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://foo/bar").
  unmarshal().serialization(). 
  marshal("jaxb").
  to("activemq:Some.Queue");
----

[[BookDataFormatAppendix-UsingSpringXML]]
Using Spring XML
^^^^^^^^^^^^^^^^

This example shows how to configure the data type just once and reuse it
on multiple routes

You can also define reusable data formats as Spring beans

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="myJaxb" class="org.apache.camel.model.dataformat.JaxbDataFormat">
  <property name="prettyPrint" value="true"/>
  <property name="contextPath" value="org.apache.camel.example"/>
</bean>  
----

[[BookDataFormatAppendix-Serialization]]
Serialization
~~~~~~~~~~~~~

Serialization is a link:data-format.html[Data Format] which uses the
standard Java Serialization mechanism to unmarshal a binary payload into
Java objects or to marshal Java objects into a binary blob. +
For example the following uses Java serialization to unmarshal a binary
file then send it as an ObjectMessage to link:activemq.html[ActiveMQ]

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://foo/bar").
  unmarshal().serialization().
  to("activemq:Some.Queue");
----

[[BookDataFormatAppendix-Dependencies]]
Dependencies
^^^^^^^^^^^^

This data format is provided in *camel-core* so no additional
dependencies is needed.

[[BookDataFormatAppendix-JAXB]]
JAXB
~~~~

JAXB is a link:data-format.html[Data Format] which uses the JAXB2 XML
marshalling standard which is included in Java 6 to unmarshal an XML
payload into Java objects or to marshal Java objects into an XML
payload.

[[BookDataFormatAppendix-UsingtheJavaDSL]]
Using the Java DSL
^^^^^^^^^^^^^^^^^^

For example the following uses a named DataFormat of _jaxb_ which is
configured with a number of Java package names to initialize the
http://java.sun.com/javase/6/docs/api/javax/xml/bind/JAXBContext.html[JAXBContext].

DataFormat jaxb = new JaxbDataFormat("com.acme.model");
from("activemq:My.Queue"). unmarshal(jaxb).
to("mqseries:Another.Queue");

You can if you prefer use a named reference to a data format which can
then be defined in your link:registry.html[Registry] such as via your
link:spring.html[Spring] XML file. e.g.

from("activemq:My.Queue"). unmarshal("myJaxbDataType").
to("mqseries:Another.Queue");

[[BookDataFormatAppendix-UsingSpringXML.1]]
Using Spring XML
^^^^^^^^^^^^^^^^

The following example shows how to use JAXB to unmarshal using
link:spring.html[Spring] configuring the jaxb data
type\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-jaxb/src/test/resources/org/apache/camel/example/springDataFormat.xml}This
example shows how to configure the data type just once and reuse it on
multiple
routes.\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-jaxb/src/test/resources/org/apache/camel/example/marshalAndUnmarshalWithRef.xml}

Multiple context paths

It is possible to use this data format with more than one context path.
You can specify context path using `:` as separator, for example
`com.mycompany:com.mycompany2`. Note that this is handled by JAXB
implementation and might change if you use different vendor than RI.

[[BookDataFormatAppendix-Partialmarshalling/unmarshalling]]
Partial marshalling/unmarshalling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*This feature is new to Camel 2.2.0.* +
JAXB 2 supports marshalling and unmarshalling XML tree fragments. By
default JAXB looks for `@XmlRootElement` annotation on given class to
operate on whole XML tree. This is useful but not always - sometimes
generated code does not have @XmlRootElement annotation, sometimes you
need unmarshall only part of tree. +
In that case you can use partial unmarshalling. To enable this
behaviours you need set property `partClass`. Camel will pass this class
to JAXB's
unmarshaler.\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-jaxb/src/test/resources/org/apache/camel/example/springDataFormatPartial.xml}For
marshalling you have to add `partNamespace` attribute with QName of
destination namespace. Example of Spring DSL you can find above.

[[BookDataFormatAppendix-Fragment]]
Fragment
^^^^^^^^

*This feature is new to Camel 2.8.0.* +
JaxbDataFormat has new property fragment which can set the the
`Marshaller.JAXB_FRAGMENT` encoding property on the JAXB Marshaller. If
you don't want the JAXB Marshaller to generate the XML declaration, you
can set this option to be true. The default value of this property is
false.

[[BookDataFormatAppendix-IgnoringtheNonXMLCharacter]]
Ignoring the NonXML Character
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*This feature is new to Camel 2.2.0.* +
JaxbDataFromat supports to ignore the
http://www.w3.org/TR/2004/REC-xml-20040204/#NT-Char[NonXML Character],
you just need to set the filterNonXmlChars property to be true,
JaxbDataFormat will replace the NonXML character with " " when it is
marshaling or unmarshaling the message. You can also do it by setting
the link:exchange.html[Exchange] property
`Exchange.FILTER_NON_XML_CHARS`.

[width="100%",cols="34%,33%,33%",]
|=================================================
|  |JDK 1.5 |JDK 1.6+
|Filtering in use |StAX API and implementation |No
|Filtering not in use |StAX API only |No
|=================================================

This feature has been tested with Woodstox 3.2.9 and Sun JDK 1.6 StAX
implementation.

*New for Camel 2.12.1* +
JaxbDataFormat now allows you to customize the XMLStreamWriter used to
marshal the stream to XML. Using this configuration, you can add your
own stream writer to completely remove, escape, or replace non-xml
characters.

java JaxbDataFormat customWriterFormat = new
JaxbDataFormat("org.apache.camel.foo.bar");
customWriterFormat.setXmlStreamWriterWrapper(new TestXmlStreamWriter());

The following example shows using the Spring DSL and also enabling
Camel's NonXML filtering:

xml<bean id="testXmlStreamWriterWrapper"
class="org.apache.camel.jaxb.TestXmlStreamWriter"/> <jaxb
filterNonXmlChars="true" contextPath="org.apache.camel.foo.bar"
xmlStreamWriterWrapper="#testXmlStreamWriterWrapper" />

[[BookDataFormatAppendix-WorkingwiththeObjectFactory]]
Working with the ObjectFactory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you use XJC to create the java class from the schema, you will get an
ObjectFactory for you JAXB context. Since the ObjectFactory uses
http://java.sun.com/javase/6/docs/api/javax/xml/bind/JAXBElement.html[JAXBElement]
to hold the reference of the schema and element instance value,
jaxbDataformat will ignore the JAXBElement by default and you will get
the element instance value instead of the JAXBElement object form the
unmarshaled message body. +
If you want to get the JAXBElement object form the unmarshaled message
body, you need to set the JaxbDataFormat object's ignoreJAXBElement
property to be false.

[[BookDataFormatAppendix-Settingencoding]]
Setting encoding
^^^^^^^^^^^^^^^^

You can set the *encoding* option to use when marshalling. Its the
`Marshaller.JAXB_ENCODING` encoding property on the JAXB Marshaller. +
You can setup which encoding to use when you declare the JAXB data
format. You can also provide the encoding in the
link:exchange.html[Exchange] property `Exchange.CHARSET_NAME`. This
property will overrule the encoding set on the JAXB data format.

In this Spring DSL we have defined to use `iso-8859-1` as the
encoding:\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-jaxb/src/test/resources/org/apache/camel/example/springDataFormatWithEncoding.xml}

[[BookDataFormatAppendix-Controllingnamespaceprefixmapping]]
Controlling namespace prefix mapping
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.11*

When marshalling using link:jaxb.html[JAXB] or link:soap.html[SOAP] then
the JAXB implementation will automatic assign namespace prefixes, such
as ns2, ns3, ns4 etc. To control this mapping, Camel allows you to refer
to a map which contains the desired mapping.

Notice this requires having JAXB-RI 2.1 or better (from SUN) on the
classpath, as the mapping functionality is dependent on the
implementation of JAXB, whether its supported.

For example in Spring XML we can define a Map with the mapping. In the
mapping file below, we map SOAP to use soap as prefix. While our custom
namespace "http://www.mycompany.com/foo/2" is not using any prefix.

xml <util:map id="myMap"> <entry
key="http://www.w3.org/2003/05/soap-envelope" value="soap"/> <!-- we
dont want any prefix for our namespace --> <entry
key="http://www.mycompany.com/foo/2" value=""/> </util:map>

To use this in link:jaxb.html[JAXB] or link:soap.html[SOAP] you refer to
this map, using the `namespacePrefixRef` attribute as shown below. Then
Camel will lookup in the link:registry.html[Registry] a `java.util.Map`
with the id "myMap", which was what we defined above.

xml <marshal> <soapjaxb version="1.2" contextPath="com.mycompany.foo"
namespacePrefixRef="myMap"/> </marshal>

[[BookDataFormatAppendix-Schemavalidation]]
Schema validation
^^^^^^^^^^^^^^^^^

*Available as of Camel 2.11*

The JAXB link:data-format.html[Data Format] supports validation by
marshalling and unmarshalling from/to XML. Your can use the prefix
*classpath:*, *file:* or *http:* to specify how the resource should by
resolved. You can separate multiple schema files by using the *','*
character.

Known issue

Camel 2.11.0 and 2.11.1 has a known issue by validation multiple
`Exchange`'s in parallel. See
https://issues.apache.org/jira/browse/CAMEL-6630[CAMEL-6630]. This is
fixed with Camel 2.11.2/2.12.0.

Using the Java DSL, you can configure it in the following way:

javaJaxbDataFormat jaxbDataFormat = new JaxbDataFormat();
jaxbDataFormat.setContextPath(Person.class.getPackage().getName());
jaxbDataFormat.setSchema("classpath:person.xsd,classpath:address.xsd");

You can do the same using the XML DSL:

xml<marshal> <jaxb id="jaxb"
schema="classpath:person.xsd,classpath:address.xsd"/> </marshal>

Camel will create and pool the underling `SchemaFactory` instances on
the fly, because the `SchemaFactory` shipped with the JDK is not thread
safe. +
However, if you have a `SchemaFactory` implementation which is thread
safe, you can configure the JAXB data format to use this one:

javaJaxbDataFormat jaxbDataFormat = new JaxbDataFormat();
jaxbDataFormat.setSchemaFactory(thradSafeSchemaFactory);

[[BookDataFormatAppendix-SchemaLocation]]
Schema Location
^^^^^^^^^^^^^^^

*Available as of Camel 2.14*

The JAXB link:data-format.html[Data Format] supports to specify the
SchemaLocation when marshaling the XML. 

Using the Java DSL, you can configure it in the following way:

javaJaxbDataFormat jaxbDataFormat = new JaxbDataFormat();
jaxbDataFormat.setContextPath(Person.class.getPackage().getName());
jaxbDataFormat.setSchemaLocation("schema/person.xsd");

You can do the same using the XML DSL:

xml<marshal> <jaxb id="jaxb" schemaLocation="schema/person.xsd"/>
</marshal>

[[BookDataFormatAppendix-MarshaldatathatisalreadyXML]]
Marshal data that is already XML
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.14.1*

The JAXB marshaller requires that the message body is JAXB compatible,
eg its a JAXBElement, eg a java instance that has JAXB annotations, or
extend JAXBElement. There can be situations where the message body is
already in XML, eg from a String type. There is a new
option `mustBeJAXBElement` you can set to false, to relax this check, so
the JAXB marshaller only attempts to marshal JAXBElements
(javax.xml.bind.JAXBIntrospector#isElement returns true). And in those
situations the marshaller fallbacks to marshal the message body as-is.

[[BookDataFormatAppendix-XmlRootElementobjects]]
XmlRootElement objects
^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.17.2*

The JAXB link:data-format.html[Data Format] option objectFactory has a
default value equals to false. This is related to a performance
degrading. For more information look at the issue
https://issues.apache.org/jira/browse/CAMEL-10043[CAMEL-10043]

For the marshalling of non-XmlRootElement JaxB objects you'll need to
call JaxbDataFormat#setObjectFactory(true)

[[BookDataFormatAppendix-Dependencies.1]]
Dependencies
^^^^^^^^^^^^

To use JAXB in your camel routes you need to add the a dependency on
*camel-jaxb* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jaxb</artifactId> <version>x.x.x</version>
</dependency>

[[BookDataFormatAppendix-XmlBeans]]
XmlBeans
~~~~~~~~

XmlBeans is a link:data-format.html[Data Format] which uses the
http://xmlbeans.apache.org/[XmlBeans library] to unmarshal an XML
payload into Java objects or to marshal Java objects into an XML
payload.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:My.Queue").
  unmarshal().xmlBeans().
  to("mqseries:Another.Queue");
----

[[BookDataFormatAppendix-Dependencies.2]]
Dependencies
^^^^^^^^^^^^

To use XmlBeans in your camel routes you need to add the dependency on
*camel-xmlbeans* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-xmlbeans</artifactId>
  <version>x.x.x</version>
  <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookDataFormatAppendix-XStream]]
XStream
~~~~~~~

XStream is a link:data-format.html[Data Format] which uses the
http://xstream.codehaus.org/[XStream library] to marshal and unmarshal
Java objects to and from XML.

To use XStream in your camel routes you need to add the a dependency
on *camel-xstream* which implements this data format.

Maven users will need to add the following dependency to their
`pom.xml` for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-xstream</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookDataFormatAppendix-UsingtheJavaDSL.1]]
Using the Java DSL
^^^^^^^^^^^^^^^^^^

// lets turn Object messages into XML then send to MQSeries
from("activemq:My.Queue"). marshal().xstream().
to("mqseries:Another.Queue");

If you would like to configure the `XStream` instance used by the Camel
for the message transformation, you can simply pass a reference to that
instance on the DSL level.

XStream xStream = new XStream(); xStream.aliasField("money",
PurchaseOrder.class, "cash"); // new Added setModel option since Camel
2.14 xStream.setModel("NO_REFERENCES"); ... from("direct:marshal").
marshal(new XStreamDataFormat(xStream)). to("mock:marshaled");

[[BookDataFormatAppendix-XMLInputFactoryandXMLOutputFactory]]
XMLInputFactory and XMLOutputFactory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

http://xstream.codehaus.org/[The XStream library] uses the
`javax.xml.stream.XMLInputFactory` and
`javax.xml.stream.XMLOutputFactory`, you can control which
implementation of this factory should be used.

The Factory is discovered using this algorithm: +
1. Use the `javax.xml.stream.XMLInputFactory` ,
`javax.xml.stream.XMLOutputFactory` system property. +
2. Use the `lib/xml.stream.properties` file in the `JRE_HOME`
directory. +
3. Use the Services API, if available, to determine the classname by
looking in the `META-INF/services/javax.xml.stream.XMLInputFactory`,
`META-INF/services/javax.xml.stream.XMLOutputFactory` files in jars
available to the JRE. +
4. Use the platform default XMLInputFactory,XMLOutputFactory instance.

[[BookDataFormatAppendix-HowtosettheXMLencodinginXstreamDataFormat?]]
How to set the XML encoding in Xstream DataFormat?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

From Camel 2.2.0, you can set the encoding of XML in Xstream DataFormat
by setting the Exchange's property with the key `Exchange.CHARSET_NAME`,
or setting the encoding property on Xstream from DSL or Spring config.

from("activemq:My.Queue"). marshal().xstream("UTF-8").
to("mqseries:Another.Queue");

\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-xstream/src/test/resources/org/apache/camel/dataformat/xstream/SpringMarshalListTest.xml}

[[BookDataFormatAppendix-SettingthetypepermissionsofXstreamDataFormat]]
Setting the type permissions of Xstream DataFormat
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In Camel, one can always use its own processing step in the route to
filter and block certain XML documents to be routed to the XStream's
unmarhall step. From Camel 2.16.1, 2.15.5, you can
set http://x-stream.github.io/security.html[XStream's type
permissions] to automatically allow or deny the instantiation of certain
types.

The default type permissions setting used by Camel denies all types
except for those from java.lang and java.util packages. This setting can
be changed by setting System property
org.apache.camel.xstream.permissions. Its value is a string of
comma-separated permission terms, each representing a type being allowed
or denied, depending on whether the term is prefixed with '+' (note '+'
may be omitted) or with '-', respectively.

Each term may contain a wildcard character '*'. For example, value
"-*,java.lang.*,java.util.*" indicates denying all types except for
java.lang.* and java.util.* classes. Setting this value to an empty
string "" reverts to the default XStream's type permissions handling
which denies certain blacklisted classes and allow others.

The type permissions setting can be extended at an individual XStream
DataFormat instance by setting its type permissions property.

<dataFormats> <xstream id="xstream-default"
permissions="org.apache.camel.samples.xstream.*"/> ...

[[BookDataFormatAppendix-CSV]]
CSV
~~~

The CSV link:data-format.html[Data Format] uses
http://commons.apache.org/proper/commons-csv/[Apache Commons CSV] to
handle CSV payloads (Comma Separated Values) such as those
exported/imported by Excel.

As of Camel 2.15.0, it now uses
the http://commons.apache.org/proper/commons-csv/archives/1.1/index.html[Apache
Commons CSV 1.1] which is based on a completely different set of
options.

[[BookDataFormatAppendix-AvailableoptionsuntilCamel2.15]]
Available options until Camel 2.15
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Type |Description
|config |CSVConfig |Can be used to set a custom `CSVConfig` object.

|strategy |CSVStrategy |Can be used to set a custom `CSVStrategy`; the
default is `CSVStrategy.DEFAULT_STRATEGY`.

|autogenColumns |boolean |Whether or not columns are auto-generated in
the resulting CSV. The default value is `true`; subsequent messages use
the previously created columns with new fields being added at the end of
the line.

|delimiter |String |*Camel 2.4:* The column delimiter to use; the
default value is "`,`".

|skipFirstLine |boolean |*Camel 2.10:* Whether or not to skip the first
line of CSV input when unmarshalling (e.g. if the content has headers on
the first line); the default value is `false`.

|lazyLoad |boolean |**Camel 2.12.2:** Whether or not to Sequential
access CSV input through an iterator which could avoid OOM exception
when processing huge CSV file; the default value is false

|useMaps |boolean |*Camel 2.13:* Whether to use List<Map> when
unmarshalling instead of List<List>.
|=======================================================================

[[BookDataFormatAppendix-AvailableoptionsasofCamel2.15]]
Available options as of Camel 2.15
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Type |Description
|`format` |`CSVFormat` |The reference format to use, it will be updated
with the other format options, the default value is `CSVFormat.DEFAULT`

|`commentMarkerDisabled` |`boolean` a|
Disables the comment marker of the reference format.

This option is `false` by default.

|`commentMarker` |`Character` a|
Overrides the comment marker of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `null` for `CSVFormat.DEFAULT`.

|`delimiter` |`Character` a|
Overrides the delimiter of the reference format.

This option is `null` by defaut. When `null` it keeps the value of the
reference format which is `','` for `CSVFormat.DEFAULT`.

|`escapeDisabled` |`boolean` a|
Disables the escape character of the reference format.

This option is `false` by default.

|`escape` |`Character` a|
Overrides the escape character of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `null` for `CSVFormat.DEFAULT`.

|`headerDisabled` |`boolean` a|
Disables the header of the reference format.

This option is `false` by default.

|`header` |`String[]` a|
Overrides the header of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `null` for `CSVFormat.DEFAULT`.

In the XML DSL, this option is configured using
children `<header>` tags:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<csv >
    <header>orderId</header>
    <header>amount</header>
</csv>
----

|`allowMissingColumnNames` |`Boolean` a|
Overrides the missing column names behavior of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `false` for `CSVFormat.DEFAULT`.

|`ignoreEmptyLines` |`Boolean` a|
Overrides the empty line behavior of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `true` for `CSVFormat.DEFAULT`.

|`ignoreSurroundingSpaces` |`Boolean` a|
Overrides the surrounding spaces behavior of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `false` for `CSVFormat.DEFAULT`.

|`nullStringDisabled` |`boolean` a|
Disables the null string representation of the reference format.

This option is `false` by default.

|`nullString` |`String` a|
Overrides the null string representation of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `null` for `CSVFormat.DEFAULT`.

|`quoteDisabled` |`boolean` a|
Disables the quote of the reference format.

This option is `false` by default.

|`quote` |`Character` a|
Overrides the quote symbol of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `'"'` (double quote) for `CSVFormat.DEFAULT`.

|`quoteMode` |`QuoteMode` a|
Overrides the quote mode of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `null` for `CSVFormat.DEFAULT`.

|`recordSeparatorDisabled` |`boolean` a|
Disables the record separator of the reference format.

This option is `false` by default.

|`recordSeparator` |`String` a|
Overrides the record separator of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `\r\n` (CRLF) for `CSVFormat.DEFAULT`.

|`skipHeaderRecord` |`Boolean` a|
Overrides the header record behavior of the reference format.

This option is `null` by default. When `null` it keeps the value of the
reference format which is `false` for `CSVFormat.DEFAULT`.

|`lazyLoad` |`boolean` a|
Whether the unmarshalling should produce an iterator that reads the
lines on the fly or if all the lines must be read at one.

This option is `false` by default.

|`useMaps` |`boolean` a|
Whether the unmarshalling should produce maps for the lines values
instead of lists. It requires to have header (either defined or
collected).

This options is `false` by default.

|`recordConverter` |`CsvRecordConverter` a|
Sets the record converter to use. If defines the `useMaps` options is
disabled.

This option is `null` by default.

|=======================================================================

[[BookDataFormatAppendix-MarshallingaMaptoCSV]]
Marshalling a Map to CSV
^^^^^^^^^^^^^^^^^^^^^^^^

The component allows you to marshal a Java Map (or any other message
type that can be link:type-converter.html[converted] in a Map) into a
CSV payload.

[width="100%",cols="50%,50%",]
|==================================================
|Considering the following body a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
Map<String, Object> body = new LinkedHashMap<>();
body.put("foo", "abc");
body.put("bar", 123);
----

|and this Java route definition a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start")
    .marshal().csv()
    .to("mock:result");
----

|or this XML route definition a|
[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:start" />
    <marshal>
        <csv />
    </marshal>
    <to uri="mock:result" />
</route>
----

|then it will produce a|
[source,brush:,text;,gutter:,false;,theme:,Default]
----
abc,123
----

|==================================================

[[BookDataFormatAppendix-UnmarshallingaCSVmessageintoaJavaList]]
Unmarshalling a CSV message into a Java List
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Unmarshalling will transform a CSV messsage into a Java List with CSV
file lines (containing another List with all the field values).

An example: we have a CSV file with names of persons, their IQ and their
current activity.

[source,brush:,text;,gutter:,false;,theme:,Default]
----
Jack Dalton, 115, mad at Averell
Joe Dalton, 105, calming Joe
William Dalton, 105, keeping Joe from killing Averell
Averell Dalton, 80, playing with Rantanplan
Lucky Luke, 120, capturing the Daltons
----

We can now use the CSV component to unmarshal this file:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file:src/test/resources/?fileName=daltons.csv&noop=true")
    .unmarshal().csv()
    .to("mock:daltons");
----

The resulting message will contain a `List<List<String>>` like...

[source,brush:,java;,gutter:,false;,theme:,Default]
----
List<List<String>> data = (List<List<String>>) exchange.getIn().getBody();
for (List<String> line : data) {
    LOG.debug(String.format("%s has an IQ of %s and is currently %s", line.get(0), line.get(1), line.get(2)));
}
----

[[BookDataFormatAppendix-MarshallingaList<Map>toCSV]]
Marshalling a List<Map> to CSV
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.1*

If you have multiple rows of data you want to be marshalled into CSV
format you can now store the message payload as a
`List<Map<String, Object>>` object where the list contains a Map for
each row.

[[BookDataFormatAppendix-FilePollerofCSV,thenunmarshaling]]
File Poller of CSV, then unmarshaling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Given a bean which can handle the incoming data...

*MyCsvHandler.java*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Some comments here
public void doHandleCsvData(List<List<String>> csvData)
{
    // do magic here
}
----

... your route then looks as follows

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<route>
        <!-- poll every 10 seconds -->
        <from uri="file:///some/path/to/pickup/csvfiles?delete=true&amp;consumer.delay=10000" />
        <unmarshal><csv /></unmarshal>
        <to uri="bean:myCsvHandler?method=doHandleCsvData" />
</route>
----

[[BookDataFormatAppendix-Marshalingwithapipeasdelimiter]]
Marshaling with a pipe as delimiter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 

 

[width="100%",cols="50%,50%",]
|==================================================
|Considering the following body a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
Map<String, Object> body = new LinkedHashMap<>();
body.put("foo", "abc");
body.put("bar", 123);
----

|and this Java route definition a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Camel version < 2.15
CsvDataFormat oldCSV = new CsvDataFormat();
oldCSV.setDelimiter("|");
from("direct:start")
    .marshal(oldCSV)
    .to("mock:result")
 
// Camel version >= 2.15
from("direct:start")
    .marshal(new CsvDataFormat().setDelimiter('|'))
    .to("mock:result")
----

|or this XML route definition a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
  <from uri="direct:start" />
  <marshal>
    <csv delimiter="|" />
  </marshal>
  <to uri="mock:result" />
</route>
----

|then it will produce a|
[source,brush:,text;,gutter:,false;,theme:,Default]
----
abc|123
----

|==================================================

[[BookDataFormatAppendix-UsingautogenColumns,configRefandstrategyRefattributesinsideXMLDSL]]
Using autogenColumns, configRef and strategyRef attributes inside XML
DSL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.9.2 / 2.10 and deleted for Camel 2.15*

You can customize the CSV link:data-format.html[Data Format] to make use
of your own `CSVConfig` and/or `CSVStrategy`. Also note that the default
value of the `autogenColumns` option is true. The following example
should illustrate this customization.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
  <from uri="direct:start" />
  <marshal>
    <!-- make use of a strategy other than the default one which is 'org.apache.commons.csv.CSVStrategy.DEFAULT_STRATEGY' -->
    <csv autogenColumns="false" delimiter="|" configRef="csvConfig" strategyRef="excelStrategy" />
  </marshal>
  <convertBodyTo type="java.lang.String" />
  <to uri="mock:result" />
</route>

<bean id="csvConfig" class="org.apache.commons.csv.writer.CSVConfig">
  <property name="fields">
    <list>
      <bean class="org.apache.commons.csv.writer.CSVField">
        <property name="name" value="orderId" />
      </bean>
      <bean class="org.apache.commons.csv.writer.CSVField">
        <property name="name" value="amount" />
      </bean>
    </list>
  </property>
</bean>

<bean id="excelStrategy" class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean">
  <property name="staticField" value="org.apache.commons.csv.CSVStrategy.EXCEL_STRATEGY" />
</bean>
----

[[BookDataFormatAppendix-UsingskipFirstLineoptionwhileunmarshaling]]
Using skipFirstLine option while unmarshaling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.10 and deleted for Camel 2.15*

You can instruct the CSV link:data-format.html[Data Format] to skip the
first line which contains the CSV headers. Using the Spring/XML DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
  <from uri="direct:start" />
  <unmarshal>
    <csv skipFirstLine="true" />
  </unmarshal>
  <to uri="bean:myCsvHandler?method=doHandleCsv" />
</route>
----

Or the Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
CsvDataFormat csv = new CsvDataFormat();
csv.setSkipFirstLine(true);

from("direct:start")
  .unmarshal(csv)
.to("bean:myCsvHandler?method=doHandleCsv");
----

[[BookDataFormatAppendix-Unmarshalingwithapipeasdelimiter]]
Unmarshaling with a pipe as delimiter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Using the Spring/XML DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
  <from uri="direct:start" />
  <unmarshal>
    <csv delimiter="|" />
  </unmarshal>
  <to uri="bean:myCsvHandler?method=doHandleCsv" />
</route>
----

Or the Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
CsvDataFormat csv = new CsvDataFormat();
CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;
strategy.setDelimiter('|');
csv.setStrategy(strategy);

from("direct:start")
  .unmarshal(csv)
  .to("bean:myCsvHandler?method=doHandleCsv");
----

[source,brush:,java;,gutter:,false;,theme:,Default]
----
CsvDataFormat csv = new CsvDataFormat();
csv.setDelimiter("|");

from("direct:start")
  .unmarshal(csv)
  .to("bean:myCsvHandler?method=doHandleCsv");
----

[source,brush:,java;,gutter:,false;,theme:,Default]
----
CsvDataFormat csv = new CsvDataFormat();
CSVConfig csvConfig = new CSVConfig();
csvConfig.setDelimiter(";");
csv.setConfig(csvConfig);

from("direct:start")
  .unmarshal(csv)
  .to("bean:myCsvHandler?method=doHandleCsv");
----

**Issue in CSVConfig**

It looks like that

[source,brush:,java;,gutter:,false;,theme:,Default]
----
CSVConfig csvConfig = new CSVConfig();
csvConfig.setDelimiter(';');
----

doesn't work. You have to set the delimiter as a String!

[[BookDataFormatAppendix-Dependencies.3]]
Dependencies
^^^^^^^^^^^^

To use CSV in your Camel routes you need to add a dependency on
*camel-csv*, which implements this data format.

If you use Maven you can just add the following to your pom.xml,
substituting the version number for the latest and greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-csv</artifactId>
  <version>x.x.x</version>
</dependency>
----

The String link:data-format.html[Data Format] is a textual based format
that supports encoding.

[[BookDataFormatAppendix-Options]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|charset |null |To use a specific charset for encoding. If not provided
Camel will use the JVM default charset.
|=======================================================================

[[BookDataFormatAppendix-Marshal]]
Marshal
^^^^^^^

In this example we marshal the file content to String object in UTF-8
encoding.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://data.csv").marshal().string("UTF-8").to("jms://myqueue");
----

[[BookDataFormatAppendix-Unmarshal]]
Unmarshal
^^^^^^^^^

In this example we unmarshal the payload from the JMS queue to a String
object using UTF-8 encoding, before its processed by the newOrder
processor.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("jms://queue/order").unmarshal().string("UTF-8").processRef("newOrder");
----

[[BookDataFormatAppendix-Dependencies.4]]
Dependencies
^^^^^^^^^^^^

This data format is provided in *camel-core* so no additional
dependencies is needed.

[[BookDataFormatAppendix-HL7DataFormat]]
HL7 DataFormat
^^^^^^^^^^^^^^

The link:hl7.html[HL7] component ships with a HL7 data format that can
be used to marshal or unmarshal HL7 model objects.

* `marshal` = from Message to byte stream (can be used when responding
using the HL7 MLLP codec)
* `unmarshal` = from byte stream to Message (can be used when receiving
streamed data from the HL7 MLLP

To use the data format, simply instantiate an instance and invoke the
marshal or unmarshal operation in the route builder:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  DataFormat hl7 = new HL7DataFormat();
  ...
  from("direct:hl7in").marshal(hl7).to("jms:queue:hl7out");
----

In the sample above, the HL7 is marshalled from a HAPI Message object to
a byte stream and put on a JMS queue. +
The next example is the opposite:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  DataFormat hl7 = new HL7DataFormat();
  ...
  from("jms:queue:hl7out").unmarshal(hl7).to("patientLookupService");
----

Here we unmarshal the byte stream into a HAPI Message object that is
passed to our patient lookup service.

[Tip]
====
 **Serializable messages**

As of HAPI 2.0 (used by *Camel 2.11*), the HL7v2 model classes are fully
serializable. So you can put HL7v2 messages directly into a JMS queue
(i.e. without calling `marshal()` and read them again directly from the
queue (i.e. without calling `unmarshal()`.

====

[Note]
====
 **Segment separators**

As of *Camel 2.11*, `unmarshal` does not automatically fix segment
separators anymore by converting `\n` to `\r`. If you +
need this conversion, `org.apache.camel.component.hl7.HL7#convertLFToCR`
provides a handy `Expression` for this purpose.

====

[Note]
====
 **Charset**

As of *Camel 2.14.1*, both `marshal and unmarshal` evaluate the charset
provided in the field `MSH-18`. If this field is empty, by default the
charset contained in the corresponding Camel charset property/header is
assumed. You can even change this default behavior by overriding the
`guessCharsetName` method when inheriting from the `HL7DataFormat`
class.

====

 

There is a shorthand syntax in Camel for well-known data formats that
are commonly used. +
Then you don't need to create an instance of the `HL7DataFormat` object:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  from("direct:hl7in").marshal().hl7().to("jms:queue:hl7out");
  from("jms:queue:hl7out").unmarshal().hl7().to("patientLookupService");
----

 

 

[[BookDataFormatAppendix-EDIDataFormat]]
EDI DataFormat
~~~~~~~~~~~~~~

We encourage end users to look at the
http://milyn.codehaus.org/Home[Smooks] which supports EDI and Camel
natively.

[[BookDataFormatAppendix-FlatpackDataFormat]]
Flatpack DataFormat
~~~~~~~~~~~~~~~~~~~

The link:flatpack.html[Flatpack] component ships with the Flatpack data
format that can be used to format between fixed width or delimited text
messages to a `List` of rows as `Map`.

* marshal = from `List<Map<String, Object>>` to `OutputStream` (can be
converted to `String`)
* unmarshal = from `java.io.InputStream` (such as a `File` or `String`)
to a `java.util.List` as an
`org.apache.camel.component.flatpack.DataSetList` instance. +
The result of the operation will contain all the data. If you need to
process each row one by one you can split the exchange, using
link:splitter.html[Splitter].

*Notice:* The Flatpack library does currently not support header and
trailers for the marshal operation.

[[BookDataFormatAppendix-Options.1]]
Options
^^^^^^^

The data format has the following options:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`definition` |`null` |The flatpack pzmap configuration file. Can be
omitted in simpler situations, but its preferred to use the pzmap.

|`fixed` |`false` |Delimited or fixed.

|`ignoreFirstRecord` |`true` |Whether the first line is ignored for
delimited files (for the column headers).

|`textQualifier` |`"` |If the text is qualified with a char such as `"`.

|`delimiter` |`,` |The delimiter char (could be `;` `,` or similar)

|`parserFactory` |`null` |Uses the default Flatpack parser factory.

|`allowShortLines` |`false` |*Camel 2.9.7 and 2.10.5 onwards*: Allows
for lines to be shorter than expected and ignores the extra characters.

|`ignoreExtraColumns` |`false` |*Camel 2.9.7 and 2.10.5 onwards*: Allows
for lines to be longer than expected and ignores the extra characters.
|=======================================================================

[[BookDataFormatAppendix-Usage]]
Usage
^^^^^

To use the data format, simply instantiate an instance and invoke the
marshal or unmarshal operation in the route builder:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  FlatpackDataFormat fp = new FlatpackDataFormat();
  fp.setDefinition(new ClassPathResource("INVENTORY-Delimited.pzmap.xml"));
  ...
  from("file:order/in").unmarshal(df).to("seda:queue:neworder");
----

The sample above will read files from the `order/in` folder and
unmarshal the input using the Flatpack configuration file
`INVENTORY-Delimited.pzmap.xml` that configures the structure of the
files. The result is a `DataSetList` object we store on the SEDA queue.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
FlatpackDataFormat df = new FlatpackDataFormat();
df.setDefinition(new ClassPathResource("PEOPLE-FixedLength.pzmap.xml"));
df.setFixed(true);
df.setIgnoreFirstRecord(false);

from("seda:people").marshal(df).convertBodyTo(String.class).to("jms:queue:people");
----

In the code above we marshal the data from a Object representation as a
`List` of rows as `Maps`. The rows as `Map` contains the column name as
the key, and the the corresponding value. This structure can be created
in Java code from e.g. a processor. We marshal the data according to the
Flatpack format and convert the result as a `String` object and store it
on a JMS queue.

[[BookDataFormatAppendix-Dependencies.5]]
Dependencies
^^^^^^^^^^^^

To use Flatpack in your camel routes you need to add the a dependency on
*camel-flatpack* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-flatpack</artifactId>
  <version>x.x.x</version>
</dependency>
----

[[BookDataFormatAppendix-JSON]]
JSON
~~~~

JSON is a link:data-format.html[Data Format] to marshal and unmarshal
Java objects to and from http://www.json.org/[JSON].

For JSON to object marshalling, Camel provides integration with three
popular JSON libraries:

* The http://xstream.codehaus.org/[XStream library] and
http://jettison.codehaus.org/[Jettsion]
* The https://github.com/FasterXML/jackson[Jackson library]
* *Camel 2.10:* The http://code.google.com/p/google-gson/[GSon library]

Every library requires adding the special camel component (see
"Dependency..." paragraphs further down). By default Camel uses the
XStream library.

Direct, bi-directional JSON <=> XML conversions

As of Camel 2.10, Camel supports direct, bi-directional JSON <=> XML
conversions via the link:xmljson.html[camel-xmljson] data format, which
is documented separately.

[[BookDataFormatAppendix-UsingJSONDataFormatWiththeXStreamLibrary]]
Using JSON Data Format With the `XStream` Library
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

java// Let's turn Object messages into JSON then send to MQSeries
from("activemq:My.Queue") .marshal().json()
.to("mqseries:Another.Queue");

[[BookDataFormatAppendix-UsingJSONDataFormatWiththeJacksonLibrary]]
Using JSON Data Format With the `Jackson` Library
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

java// Let's turn Object messages into JSON then send to MQSeries
from("activemq:My.Queue") .marshal().json(JsonLibrary.Jackson)
.to("mqseries:Another.Queue");

[[BookDataFormatAppendix-UsingJSONDataFormatWiththeGSONLibrary]]
Using JSON Data Format With the GSON Library
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

java// Let's turn Object messages into JSON then send to MQSeries
from("activemq:My.Queue") .marshal().json(JsonLibrary.Gson)
.to("mqseries:Another.Queue");

[[BookDataFormatAppendix-UsingJSONinSpringDSL]]
Using JSON in Spring DSL
++++++++++++++++++++++++

When using link:data-format.html[Data Format] in Spring DSL you need to
declare the data formats first. This is done in the *`DataFormats`* XML
tag.

xml<dataFormats> <!-- Here we define a Json data format with the id jack
and that it should use the TestPojo as the class type when doing
unmarshal. The unmarshalTypeName is optional, if not provided Camel will
use a Map as the type. --> <json id="jack" library="Jackson"
unmarshalTypeName="org.apache.camel.component.jackson.TestPojo"/>
</dataFormats>

And then you can refer to this id in the route:

xml<route> <from uri="direct:back"/> <unmarshal ref="jack"/> <to
uri="mock:reverse"/> </route>

[[BookDataFormatAppendix-ExcludingPOJOFieldsFromMarshalling]]
Excluding POJO Fields From Marshalling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*As of Camel 2.10* +
When marshaling a POJO to JSON you might want to exclude certain fields
from the JSON output. With Jackson you can use
http://wiki.fasterxml.com/JacksonJsonViews[JSON views] to accomplish
this.

First create one or more marker
classes:\{snippet:id=marker|lang=java|url=camel/trunk/components/camel-jackson/src/test/java/org/apache/camel/component/jackson/Views.java}Second,
use the marker classes with the *`@JsonView`* annotation to
include/exclude certain fields. The annotation also works on
getters:\{snippet:id=jsonview|lang=java|url=camel/trunk/components/camel-jackson/src/test/java/org/apache/camel/component/jackson/TestPojoView.java}Finally,
use the Camel *`JacksonDataFormat`* to marshal the above POJO to
JSON.\{snippet:id=format|lang=java|url=camel/trunk/components/camel-jackson/src/test/java/org/apache/camel/component/jackson/JacksonMarshalViewTest.java}*Note*:
the height field is missing in the resulting JSON.

\{"age":30, "weight":70}

The GSON library supports a similar feature through the notion of
http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html[ExclusionStrategies]:\{snippet:id=strategy|lang=java|url=camel/trunk/components/camel-gson/src/test/java/org/apache/camel/component/gson/GsonMarshalExclusionTest.java}The
*`GsonDataFormat`* accepts an *`ExclusionStrategy`* in its
constructor:\{snippet:id=format|lang=java|url=camel/trunk/components/camel-gson/src/test/java/org/apache/camel/component/gson/GsonMarshalExclusionTest.java}The
line above will exclude fields annotated with *`@ExcludeAge`* when
marshaling to JSON.

[[BookDataFormatAppendix-ConfiguringFieldNamingPolicy]]
Configuring Field Naming Policy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.11*

The GSON library supports specifying policies and strategies for mapping
from JSON to POJO fields. A common naming convention is to map JSON
fields using lower case with underscores.

We may have this JSON string

\{ "id" : 123, "first_name" : "Donald" "last_name" : "Duck" }

Which we want to map to a POJO that has getter/setters as:

javaPersonPojo.javaPersonPojo.javapublic class PersonPojo \{ private int
id; private String firstName; private String lastName; public int
getId() \{ return id; } public void setId(int id) \{ this.id = id; }
public String getFirstName() \{ return firstName; } public void
setFirstName(String firstName) \{ this.firstName = firstName; } public
String getLastName() \{ return lastName; } public void
setLastName(String lastName) \{ this.lastName = lastName; } }

Then we can configure the
*`org.apache.camel.component.gson.GsonDataFormat`* in a Spring XML files
as shown below. Notice we use *`fieldNamingPolicy`* property to set the
field mapping. This property is an enum from GSon
*`com.google.gson.FieldNamingPolicy`* which has a number of predefined
mappings.

If you need full control you can use the property
*`FieldNamingStrategy`* and implement a custom
*`com.google.gson.FieldNamingStrategy`* where you can control the
mapping.

Configuring GsonDataFormat in Spring XML filexmlConfiguring
GsonDataFromat in Spring XML file<!-- define the gson data format, where
we configure the data format using the properties --> <bean id="gson"
class="org.apache.camel.component.gson.GsonDataFormat"> <!-- we want to
unmarshal to person pojo --> <property name="unmarshalType"
value="org.apache.camel.component.gson.PersonPojo"/> <!-- we want to map
fields to use lower case and underscores --> <property
name="fieldNamingPolicy" value="LOWER_CASE_WITH_UNDERSCORES"/> </bean>

And use it in Camel routes by referring to its bean id as shown:

Using gson from Camel routesxmlUsing gson from Camel Routes<camelContext
xmlns="http://camel.apache.org/schema/spring"> <route> <from
uri="direct:inPojo"/> <marshal ref="gson"/> </route> <route> <from
uri="direct:backPojo"/> <unmarshal ref="gson"/> </route> </camelContext>

[[BookDataFormatAppendix-Include/ExcludeFieldsUsingthejsonViewAttributeWithJacksonDataFormat]]
Include/Exclude Fields Using the *`jsonView`* Attribute With
`JacksonDataFormat`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.12*

As an example of using this attribute you can instead of:

javaJacksonDataFormat ageViewFormat = new
JacksonDataFormat(TestPojoView.class, Views.Age.class);
from("direct:inPojoAgeView") .marshal(ageViewFormat);

Directly specify your http://wiki.fasterxml.com/JacksonJsonViews[JSON
view] inside the Java DSL as:

javafrom("direct:inPojoAgeView") .marshal().json(TestPojoView.class,
Views.Age.class);

And the same in XML DSL:

xml<from uri="direct:inPojoAgeView"/> <marshal> <json library="Jackson"
unmarshalTypeName="org.apache.camel.component.jackson.TestPojoView"
jsonView="org.apache.camel.component.jackson.Views$Age"/> </marshal>

[[BookDataFormatAppendix-SettingSerializationIncludeOptionforJacksonMarshal]]
Setting Serialization Include Option for Jackson Marshal
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.13.3/2.14*

If you want to marshal a POJO to JSON, and the POJO has some fields with
null values. And you want to skip these null values, then you need to
set either an annotation on the POJO, 

java@JsonInclude(Include.NON_NULL) public class MyPojo \{ // ... }

But this requires you to include that annotation in your POJO source
code. You can also configure the Camel *`JsonDataFormat`* to set the
include option, as shown below:

javaJacksonDataFormat format = new JacksonDataFormat();
format.setInclude("NON_NULL");

Or from XML DSL you configure this as

xml<dataFormats> <json id="json" library="Jackson" include="NON_NULL"/>
</dataFormats>

[[BookDataFormatAppendix-UnmarshalingfromJSONtoPOJOwithDynamicClassName]]
Unmarshaling from JSON to POJO with Dynamic Class Name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.14*

If you use Jackson to unmarshal JSON to POJO, then you can now specify a
header in the message that indicate which class name to unmarshal to.
The header has key **`CamelJacksonUnmarshalType`** if that header is
present in the message, then Jackson will use that as FQN for the POJO
class to unmarshal the JSON payload as. Notice that behavior is enabled
out of the box from *Camel 2.14*. 

 For JMS end users there is the *`JMSType`* header from the JMS spec
that indicates that also. To enable support for *`JMSType`* you would
need to turn that on, on the Jackson data format as shown:

javaJacksonDataFormat format = new JacksonDataFormat();
format.setAllowJmsType(true);

Or from XML DSL you configure this as

xml<dataFormats> <json id="json" library="Jackson" allowJmsType="true"/>
</dataFormats>

[[BookDataFormatAppendix-UnmarshalingFromJSONtoList<Map>orList<pojo>]]
Unmarshaling From JSON to `List<Map>` or `List<pojo>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.14*

If you are using Jackson to unmarshal JSON to a list of map/POJO, you
can now specify this by setting *`useList="true"`* or use
the *`org.apache.camel.component.jackson.ListJacksonDataFormat`*.

For example, with Java you can do as shown below:

javaJacksonDataFormat format = new ListJacksonDataFormat(); // or
JacksonDataFormat format = new JacksonDataFormat(); format.useList(); //
and you can specify the pojo class type also
format.setUnmarshalType(MyPojo.class);

And if you use XML DSL then you configure to use list using `useList`
attribute as shown below:

xml<dataFormats> <json id="json" library="Jackson" useList="true"/>
</dataFormats>

And you can specify the pojo type also

xml<dataFormats> <json id="json" library="Jackson" useList="true"
unmarshalTypeName="com.foo.MyPojo"/> </dataFormats>

[[BookDataFormatAppendix-UsingCustomJackson'sObjectMapper]]
Using Custom Jackson's `ObjectMapper`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available from Camel 2.17*

You can use custom Jackson *`ObjectMapper`* instance, can be configured
as shown below.

xml<dataFormats> <json id="json" library="Jackson"
objectMapper="myMapper"/> </dataFormats>

Where *`myMapper`* is the id of the custom instance that Camel will
lookup in the link:registry.html[Registry.]

[[BookDataFormatAppendix-UsingCustomJacksonModules]]
Using Custom Jackson Modules
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.15*

You can use custom Jackson modules by specifying the class names of
those using the *`moduleClassNames`* option as shown below.

xml<dataFormats> <json id="json" library="Jackson" useList="true"
unmarshalTypeName="com.foo.MyPojo"
moduleClassNames="com.foo.MyModule,com.foo.MyOtherModule"/>
</dataFormats>

When using *`moduleClassNames`* then the custom Jackson modules are not
configured, by created using default constructor and used as-is. If a
custom module needs any custom configuration, then an instance of the
module can be created and configured, and then use *`modulesRefs`* to
refer to the module as shown below:

xml<bean id="myJacksonModule" class="com.foo.MyModule"> ... // configure
the module as you want </bean>   <dataFormats> <json id="json"
library="Jackson" useList="true" unmarshalTypeName="com.foo.MyPojo"
moduleRefs="myJacksonModule"/> </dataFormats>

 Multiple modules can be specified separated by comma, such as
*`moduleRefs="myJacksonModule,myOtherModule"`*.

[[BookDataFormatAppendix-EnablingorDisableFeaturesUsingJackson]]
Enabling or Disable Features Using Jackson
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.15*

Jackson has a number of features you can enable or disable, which
its *`ObjectMapper`* uses. For example to disable failing on unknown
properties when marshaling, you can configure this using the
*`disableFeatures`*:

xml<dataFormats> <json id="json" library="Jackson"
unmarshalTypeName="com.foo.MyPojo"
disableFeatures="FAIL_ON_UNKNOWN_PROPERTIES"/> </dataFormats>

You can disable multiple features by separating the values using comma.
The values for the features must be the name of the enums from Jackson
from the following enum classes

* `com.fasterxml.jackson.databind.SerializationFeature`
* `com.fasterxml.jackson.databind.DeserializationFeature`
* `com.fasterxml.jackson.databind.MapperFeature`

To enable a feature use the *`enableFeatures`* options instead.

From Java code you can use the type safe methods from *`camel-jackson`*
module:

javaJacksonDataFormat df = new JacksonDataFormat(MyPojo.class);
df.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
df.disableFeature(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);

[[BookDataFormatAppendix-ConvertingMapstoPOJOUsingJackson]]
Converting Maps to POJO Using Jackson
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Available since *Camel 2.16*. Jackson *`ObjectMapper`* can be used to
convert maps to POJO objects. Jackson component comes with the data
converter that can be used to convert *`java.util.Map`* instance to
non-String, non-primitive and non-Number objects.

javaMap<String, Object> invoiceData = new HashMap<String, Object>();
invoiceData.put("netValue", 500);
producerTemplate.sendBody("direct:mapToInvoice", invoiceData); ... //
Later in the processor Invoice invoice =
exchange.getIn().getBody(Invoice.class);

If there is a single *`ObjectMapper`* instance available in the Camel
registry, it will used by the converter to perform the conversion.
Otherwise the default mapper will be used.  

[[BookDataFormatAppendix-FormattedJSONmarshalling(pretty-printing)]]
Formatted JSON marshalling (pretty-printing)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.16*

Using the *`prettyPrint`* option one can output a well formatted JSON
while marshaling:

xml<dataFormats> <json id="xstream" prettyPrint="true"/> <json
id="jackson" prettyPrint="true" library="Jackson"/> <json id="gson"
prettyPrint="true" library="Gson"/> </dataFormats>

And in Java DSL:

javafrom("direct:inPretty").marshal().json(true);  
from("direct:inPretty").marshal().json(JsonLibrary.Jackson, true);  
from("direct:inPretty").marshal().json(JsonLibrary.Gson, true);

Please note that as of Camel 2.16 there are five different overloaded
*`json()`* DSL methods which support the *`prettyPrint`* option in
combination with other settings for *`JsonLibrary`*, *`unmarshalType`*,
*`jsonView`* etc. 

[[BookDataFormatAppendix-IntegratingJacksonwithCamel'sTypeConverters]]
 Integrating Jackson with Camel's TypeConverters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookDataFormatAppendix-AvailableasofCamel2.17]]
 **Available as of Camel 2.17**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The *`camel-jackson`* module allows to integrate Jackson as
a link:type-converter.html[Type Converter] in the Camel registry. This
works in similar ways that *`camel-jaxb`* integrates with the type
converter as well. However *`camel-jackson`* must be explicit enabled,
which is done by setting some options on the *`CamelContext`*
properties, as shown below:

java// Enable Jackson JSON type converter.
getContext().getProperties().put("CamelJacksonEnableTypeConverter",
"true"); // Allow Jackson JSON to convert to pojo types also (by default
Jackson only converts to String and other simple types).
getContext().getProperties().put("CamelJacksonTypeConverterToPojo",
"true");

The *`camel-jackson`* type converter integrates with JAXB which means
you can annotate POJO class with JAXB annotations that Jackson can
leverage. 

[[BookDataFormatAppendix-DependenciesforXStream]]
Dependencies for XStream
^^^^^^^^^^^^^^^^^^^^^^^^

To use JSON in your camel routes you need to add the a dependency
on *`camel-xstream`* which implements this data format.

If you use maven you could just add the following to your *`pom.xml`*,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-xstream</artifactId> <version>2.9.2</version>
</dependency>

[[BookDataFormatAppendix-DependenciesforJackson]]
Dependencies for Jackson
^^^^^^^^^^^^^^^^^^^^^^^^

To use JSON in your camel routes you need to add the a dependency
on *`camel-jackson`* which implements this data format.

If you use maven you could just add the following to your *`pom.xml`*,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jackson</artifactId> <version>2.9.2</version>
</dependency>

[[BookDataFormatAppendix-DependenciesforGSON]]
Dependencies for GSON
^^^^^^^^^^^^^^^^^^^^^

To use JSON in your camel routes you need to add the a dependency
on *`camel-gson`* which implements this data format.

If you use maven you could just add the following to your *`pom.xml`*,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-gson</artifactId> <version>2.10.0</version>
</dependency> The Zip link:data-format.html[Data Format] is a message
compression and de-compression format. Messages marshalled using Zip
compression can be unmarshalled using Zip decompression just prior to
being consumed at the endpoint. The compression capability is quite
useful when you deal with large XML and Text based payloads. It
facilitates more optimal use of network bandwidth while incurring a
small cost in order to compress and decompress payloads at the endpoint.
[Info]
====
 **About using with Files**

The Zip data format, does not (yet) have special support for files.
Which means that when using big files, the entire file content is loaded
into memory. +
This is subject to change in the future, to allow a streaming based
solution to have a low memory footprint.

====

[[BookDataFormatAppendix-Options.2]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|compressionLevel |null |To specify a specific compression Level use
`java.util.zip.Deflater` settings. The possible settings are  +
          - `Deflater.BEST_SPEED` +
          - `Deflater.BEST_COMPRESSION` +
          - `Deflater.DEFAULT_COMPRESSION` +
 +
If compressionLevel is not explicitly specified the compressionLevel
employed is `Deflater.DEFAULT_COMPRESSION`
|=======================================================================

[[BookDataFormatAppendix-Marshal.1]]
Marshal
^^^^^^^

In this example we marshal a regular text/XML payload to a compressed
payload employing zip compression `Deflater.BEST_COMPRESSION` and send
it an ActiveMQ queue called MY_QUEUE.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start").marshal().zip(Deflater.BEST_COMPRESSION).to("activemq:queue:MY_QUEUE");
----

Alternatively if you would like to use the default setting you could
send it as

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start").marshal().zip().to("activemq:queue:MY_QUEUE");
----

[[BookDataFormatAppendix-Unmarshal.1]]
Unmarshal
^^^^^^^^^

In this example we unmarshal a zipped payload from an ActiveMQ queue
called MY_QUEUE to its original format, and forward it for processing to
the UnZippedMessageProcessor. Note that the compression Level employed
during the marshalling should be identical to the one employed during
unmarshalling to avoid errors.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:queue:MY_QUEUE").unmarshal().zip().process(new UnZippedMessageProcessor()); 
----

[[BookDataFormatAppendix-Dependencies.6]]
Dependencies
^^^^^^^^^^^^

This data format is provided in *camel-core* so no additional
dependencies are needed.

[[BookDataFormatAppendix-TidyMarkup]]
TidyMarkup
~~~~~~~~~~

TidyMarkup is a link:data-format.html[Data Format] that uses the
http://www.ccil.org/~cowan/XML/tagsoup/[TagSoup] to tidy up HTML. It can
be used to parse ugly HTML and return it as pretty wellformed HTML.

**Camel eats our own -dog food- soap**

We had some issues in our pdf link:manual.html[Manual] where we had some
strange symbols. So http://janstey.blogspot.com/[Jonathan] used this
data format to tidy up the wiki html pages that are used as base for
rendering the pdf manuals. And then the mysterious symbols vanished.

link:tidymarkup.html[TidyMarkup] only supports the *unmarshal* operation
as we really don't want to turn well formed HTML into ugly HTML
image:https://cwiki.apache.org/confluence/s/en_GB/5997/6f42626d00e36f53fe51440403446ca61552e2a2.1/_/images/icons/emoticons/smile.png[(smile)]

[[BookDataFormatAppendix-JavaDSLExample]]
Java DSL Example
^^^^^^^^^^^^^^^^

An example where the consumer provides some HTML

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://site/inbox").unmarshal().tidyMarkup().to("file://site/blogs");
----

[[BookDataFormatAppendix-SpringXMLExample]]
Spring XML Example
^^^^^^^^^^^^^^^^^^

The following example shows how to use link:tidymarkup.html[TidyMarkup]
to unmarshal using Spring

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="file://site/inbox"/>
    <unmarshal>
      <tidyMarkup/>
    </unmarshal>
    <to uri="file://site/blogs"/>
  </route>
</camelContext>
----

[[BookDataFormatAppendix-Dependencies.7]]
Dependencies
^^^^^^^^^^^^

To use TidyMarkup in your camel routes you need to add the a dependency
on *camel-tagsoup* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-tagsoup</artifactId>
  <version>x.x.x</version>
</dependency>
----

[[BookDataFormatAppendix-Bindy]]
Bindy
~~~~~

The goal of this component is to allow the parsing/binding of
non-structured data (or to be more precise non-XML data) +
to/from Java Beans that have binding mappings defined with annotations.
Using Bindy, you can bind data from sources such as :

* CSV records,
* Fixed-length records,
* FIX messages,
* or almost any other non-structured data

to one or many Plain Old Java Object (POJO). Bindy converts the data
according to the type of the java property. POJOs can be linked together
with one-to-many relationships available in some cases. Moreover, for
data type like Date, Double, Float, Integer, Short, Long and BigDecimal,
you can provide the pattern to apply during the formatting of the
property.

For the BigDecimal numbers, you can also define the precision and the
decimal or grouping separators.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Type |Format Type |Pattern example |Link
|Date |DateFormat |"dd-MM-yyyy"
|http://java.sun.com/j2se/1.5.0/docs/api/java/text/SimpleDateFormat.html

|Decimal* |Decimalformat |"##.###.###"
|http://java.sun.com/j2se/1.5.0/docs/api/java/text/DecimalFormat.html
|=======================================================================

Decimal* = Double, Integer, Float, Short, Long

[Note]
====
 **Format supported**

This first release only support comma separated values fields and key
value pair fields (e.g. : FIX messages).

====

To work with camel-bindy, you must first define your model in a package
(e.g. com.acme.model) and for each model class (e.g. Order, Client,
Instrument, ...) add the required annotations (described hereafter) to
the Class or field.

[Note]
====
 **Multiple models**

If you use multiple models, each model has to be placed in it's own
package to prevent unpredictable results.

From *Camel 2.16* onwards this is no longer the case, as you can safely
have multiple models in the same package, as you configure bindy using
class names instead of package names now.

====

[[BookDataFormatAppendix-Annotations]]
Annotations
~~~~~~~~~~~

The annotations created allow to map different concept of your model to
the POJO like :

* Type of record (csv, key value pair (e.g. FIX message), fixed length
...),
* Link (to link object in another object),
* DataField and their properties (int, type, ...),
* KeyValuePairField (for key = value format like we have in FIX
financial messages),
* Section (to identify header, body and footer section),
* OneToMany

This section will describe them :

[[BookDataFormatAppendix-1.CsvRecord]]
1. CsvRecord
^^^^^^^^^^^^

The CsvRecord annotation is used to identified the root class of the
model. It represents a record = a line of a CSV file and can be linked
to several children model classes.

[width="100%",cols="34%,33%,33%",options="header",]
|===================================
|Annotation name |Record type |Level
|*CsvRecord* |csv |Class
|===================================

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter name |type |Info
|separator |string |mandatory - can be ',' or ';' or 'anything'. This
value is interpreted as a regular expression. If you want to use a sign
which has a special meaning in regular expressions, e.g. the '|' sign,
than you have to mask it, like ' +
|'

|skipFirstLine |boolean |optional - default value = false - allow to
skip the first line of the CSV file

|crlf |string |optional - possible values = WINDOWS,UNIX,MAC, or custom;
default value = WINDOWS - allow to define the carriage return character
to use. If you specify a value other than the three listed before, the
value you enter (custom) will be used as the CRLF character(s)

|generateHeaderColumns |boolean |optional - default value = false - uses
to generate the header columns of the CSV generates

|autospanLine |boolean |*Camel 2.13/2.12.2:* optional - default value =
false - if enabled then the last column is auto spanned to end of line,
for example if its a comment, etc this allows the line to contain all
characters, also the delimiter char.

|isOrdered |boolean |optional - default value = false - allow to change
the order of the fields when CSV is generated

|quote |String |*Camel 2.8.3/2.9:* option - allow to specify a quote
character of the fields when CSV is generated

|  |  |This annotation is associated to the root class of the model and
must be declared one time.

|quoting |boolean |**Camel 2.11:**optional - default value = false
- Indicate if the values must be quoted when marshaling when CSV is
generated.
|=======================================================================

*case 1 : separator = ','*

The separator used to segregate the fields in the CSV record is ',' :

10, J, Pauline, M, XD12345678, Fortis Dynamic 15/15, 2500,
USD,08-01-2009

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord( separator = "," )
public Class Order {
...
}
----

*case 2 : separator = ';'*

Compare to the previous case, the separator here is ';' instead of ',' :

10; J; Pauline; M; XD12345678; Fortis Dynamic 15/15; 2500; USD;
08-01-2009

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord( separator = ";" )
public Class Order {
...
}
----

*case 3 : separator = '|'*

Compare to the previous case, the separator here is '|' instead of ';' :

10| J| Pauline| M| XD12345678| Fortis Dynamic 15/15| 2500| USD|
08-01-2009

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord( separator = "\\|" )
public Class Order {
...
}
----

*case 4 : separator = '\",\"'* +
*Applies for Camel 2.8.2 or older*

When the field to be parsed of the CSV record contains ',' or ';' which
is also used as separator, we whould find another strategy +
to tell camel bindy how to handle this case. To define the field
containing the data with a comma, you will use simple or double quotes +
as delimiter (e.g : '10', 'Street 10, NY', 'USA' or "10", "Street 10,
NY", "USA"). +
Remark : In this case, the first and last character of the line which
are a simple or double quotes will removed by bindy

"10","J","Pauline"," M","XD12345678","Fortis Dynamic 15,15"
2500","USD","08-01-2009"

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord( separator = "\",\"" )
public Class Order {
...
}
----

From *Camel 2.8.3/2.9 or never* bindy will automatic detect if the
record is enclosed with either single or double quotes and automatic
remove those quotes when unmarshalling from CSV to Object. Therefore do
*not* include the quotes in the separator, but simple do as below:

"10","J","Pauline"," M","XD12345678","Fortis Dynamic 15,15"
2500","USD","08-01-2009"

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord( separator = "," )
public Class Order {
...
}
----

Notice that if you want to marshal from Object to CSV and use quotes,
then you need to specify which quote character to use, using the `quote`
attribute on the @CsvRecord as shown below:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord( separator = ",", quote = "\"" )
public Class Order {
...
}
----

*case 5 : separator & skipfirstline*

The feature is interesting when the client wants to have in the first
line of the file, the name of the data fields :

order id, client id, first name, last name, isin code, instrument name,
quantity, currency, date

To inform bindy that this first line must be skipped during the parsing
process, then we use the attribute :

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",", skipFirstLine = true)
public Class Order {
...
}
----

*case 6 : generateHeaderColumns*

To add at the first line of the CSV generated, the attribute
generateHeaderColumns must be set to true in the annotation like this :

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord( generateHeaderColumns = true )
public Class Order {
...
}
----

As a result, Bindy during the unmarshaling process will generate CSV
like this :

order id, client id, first name, last name, isin code, instrument name,
quantity, currency, date +
10, J, Pauline, M, XD12345678, Fortis Dynamic 15/15, 2500,
USD,08-01-2009

*case 7 : carriage return*

If the platform where camel-bindy will run is not Windows but Macintosh
or Unix, than you can change the crlf property like this. Three values
are available : WINDOWS, UNIX or MAC

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",", crlf="MAC")
public Class Order {
...
}
----

Additionally, if for some reason you need to add a different line ending
character, you can opt to specify it using the crlf parameter. In the
following example, we can end the line with a comma followed by the
newline character:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",", crlf=",\n")
public Class Order {
...
}
----

*case 8 : isOrdered*

Sometimes, the order to follow during the creation of the CSV record
from the model is different from the order used during the parsing.
Then, in this case, we can use the attribute isOrdered = true to
indicate this in combination with attribute 'position' of the DataField
annotation.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(isOrdered = true)
public Class Order {

   @DataField(pos = 1, position = 11)
   private int orderNr;

   @DataField(pos = 2, position = 10)
   private String clientNr;

...
}
----

Remark : pos is used to parse the file, stream while positions is used
to generate the CSV

[[BookDataFormatAppendix-2.Link]]
2. Link
^^^^^^^

The link annotation will allow to link objects together.

[width="100%",cols="34%,33%,33%",options="header",]
|===================================
|Annotation name |Record type |Level
|*Link* |all |Class & Property
|===================================

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter name |type |Info
|linkType |LinkType |optional - by default the value is
LinkType.oneToOne - so you are not obliged to mention it

|  |  |Only one-to-one relation is allowed.
|=======================================================================

e.g : If the model Class Client is linked to the Order class, then use
annotation Link in the Order class like this :

*Property Link*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {

    @DataField(pos = 1)
    private int orderNr;

    @Link
    private Client client;
...
----

AND for the class Client :

*Class Link*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Link
public class Client {
...
}
----

[[BookDataFormatAppendix-3.DataField]]
3. DataField
^^^^^^^^^^^^

The DataField annotation defines the property of the field. Each
datafield is identified by its position in the record, a type (string,
int, date, ...) and optionally of a pattern

[width="100%",cols="34%,33%,33%",options="header",]
|===================================
|Annotation name |Record type |Level
|*DataField* |all |Property
|===================================

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter name |type |Info
|pos |int |mandatory - The *input* position of the field. digit number
starting from 1 to ... - See the position parameter.

|pattern |string |optional - default value = "" - will be used to format
Decimal, Date, ...

|length |int |optional - represents the length of the field for fixed
length format

|precision |int |optional - represents the precision to be used when the
Decimal number will be formatted/parsed

|pattern |string |optional - default value = "" - is used by the Java
formatter (SimpleDateFormat by example) to format/validate data. If
using pattern, then setting locale on bindy data format is recommended.
Either set to a known locale such as "us" or use "default" to use
platform default locale. Notice that "default" requires Camel
2.14/2.13.3/2.12.5.

|position |int |optional - must be used when the position of the field
in the CSV generated (output message) must be different compare to input
position (pos). See the pos parameter.

|required |boolean |optional - default value = "false"

|trim |boolean |optional - default value = "false"

|defaultValue |string |*Camel 2.10:* optional - default value = "" -
defines the field's default value when the respective CSV field is
empty/not available

|impliedDecimalSeparator |boolean |*Camel 2.11:* optional - default
value = "false" - Indicates if there is a decimal point implied at a
specified location

|lengthPos |int |*Camel 2.11*: optional - can be used to identify a data
field in a fixed-length record that defines the fixed length for this
field

|delimiter |string |*Camel 2.11:* optional - can be used to demarcate
the end of a variable-length field within a fixed-length record
|=======================================================================

*case 1 : pos*

This parameter/attribute represents the position of the field in the csv
record

*Position*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {

    @DataField(pos = 1)
    private int orderNr;

    @DataField(pos = 5)
    private String isinCode;

...
}
----

As you can see in this example the position starts at '1' but continues
at '5' in the class Order. The numbers from '2' to '4' are defined in
the class Client (see here after).

*Position continues in another model class*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
public class Client {

    @DataField(pos = 2)
    private String clientNr;

    @DataField(pos = 3)
    private String firstName;

    @DataField(pos = 4)
    private String lastName;
...
}
----

*case 2 : pattern*

The pattern allows to enrich or validates the format of your data

*Pattern*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {

    @DataField(pos = 1)
    private int orderNr;

    @DataField(pos = 5)
    private String isinCode;

    @DataField(name = "Name", pos = 6)
    private String instrumentName;

    @DataField(pos = 7, precision = 2)
    private BigDecimal amount;

    @DataField(pos = 8)
    private String currency;

    @DataField(pos = 9, pattern = "dd-MM-yyyy") -- pattern used during parsing or when the date is created
    private Date orderDate;
...
}
----

*case 3 : precision*

The precision is helpful when you want to define the decimal part of
your number

*Precision*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {

    @DataField(pos = 1)
    private int orderNr;

    @Link
    private Client client;

    @DataField(pos = 5)
    private String isinCode;

    @DataField(name = "Name", pos = 6)
    private String instrumentName;

    @DataField(pos = 7, precision = 2) -- precision
    private BigDecimal amount;

    @DataField(pos = 8)
    private String currency;

    @DataField(pos = 9, pattern = "dd-MM-yyyy")
    private Date orderDate;
...
}
----

*case 4 : Position is different in output*

The position attribute will inform bindy how to place the field in the
CSV record generated. By default, the position used corresponds to the
position defined with the attribute 'pos'. If the position is different
(that means that we have an asymetric processus comparing marshaling
from unmarshaling) than we can use 'position' to indicate this.

Here is an example

*Position is different in output*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {
@CsvRecord(separator = ",", isOrdered = true)
public class Order {

    // Positions of the fields start from 1 and not from 0

    @DataField(pos = 1, position = 11)
    private int orderNr;

    @DataField(pos = 2, position = 10)
    private String clientNr;

    @DataField(pos = 3, position = 9)
    private String firstName;

    @DataField(pos = 4, position = 8)
    private String lastName;

    @DataField(pos = 5, position = 7)
    private String instrumentCode;

    @DataField(pos = 6, position = 6)
    private String instrumentNumber;
...
}
----

[Note]
====


This attribute of the annotation @DataField must be used in combination
with attribute isOrdered = true of the annotation @CsvRecord

====

*case 5 : required*

If a field is mandatory, simply use the attribute 'required' setted to
true

*Required*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {

    @DataField(pos = 1)
    private int orderNr;

    @DataField(pos = 2, required = true)
    private String clientNr;

    @DataField(pos = 3, required = true)
    private String firstName;

    @DataField(pos = 4, required = true)
    private String lastName;
...
}
----

If this field is not present in the record, than an error will be raised
by the parser with the following information :

Some fields are missing (optional or mandatory), line :

*case 6 : trim*

If a field has leading and/or trailing spaces which should be removed
before they are processed, simply use the attribute 'trim' setted to
true

*Trim*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {

    @DataField(pos = 1, trim = true)
    private int orderNr;

    @DataField(pos = 2, trim = true)
    private Integer clientNr;

    @DataField(pos = 3, required = true)
    private String firstName;

    @DataField(pos = 4)
    private String lastName;
...
}
----

*case 7 : defaultValue*

If a field is not defined then uses the value indicated by the
defaultValue attribute

*Default value*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator = ",")
public class Order {

    @DataField(pos = 1)
    private int orderNr;

    @DataField(pos = 2)
    private Integer clientNr;

    @DataField(pos = 3, required = true)
    private String firstName;

    @DataField(pos = 4, defaultValue = "Barin")
    private String lastName;
...
}
----

[Note]
====


This attribute is only applicable to optional fields.

====

[[BookDataFormatAppendix-4.FixedLengthRecord]]
4. FixedLengthRecord
^^^^^^^^^^^^^^^^^^^^

The FixedLengthRecord annotation is used to identified the root class of
the model. It represents a record = a line of a file/message containing
data fixed length formatted and can be linked to several children model
classes. This format is a bit particular beause data of a field can be
aligned to the right or to the left. +
When the size of the data does not fill completely the length of the
field, we can then add 'padd' characters.

[width="100%",cols="34%,33%,33%",options="header",]
|===================================
|Annotation name |Record type |Level
|*FixedLengthRecord* |fixed |Class
|===================================

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter name |type |Info
|crlf |string |optional - possible values = WINDOWS,UNIX,MAC, or custom;
default value = WINDOWS - allow to define the carriage return character
to use. If you specify a value other than the three listed before, the
value you enter (custom) will be used as the CRLF character(s)

|paddingChar |char |mandatory - default value = ' '

|length |int |mandatory = size of the fixed length record

|hasHeader |boolean |*Camel 2.11* - optional - Indicates that the
record(s) of this type may be preceded by a single header record at the
beginning of the file / stream

|hasFooter |boolean |*Camel 2.11* - optional - Indicates that the
record(s) of this type may be followed by a single footer record at the
end of the file / stream

|skipHeader |boolean |*Camel 2.11* - optional - Configures the data
format to skip marshalling / unmarshalling of the header record.
Configure this parameter on the primary record (e.g., not the header or
footer).

|skipFooter |boolean |*Camel 2.11* - optional - Configures the data
format to skip marshalling / unmarshalling of the footer record
Configure this parameter on the primary record (e.g., not the header or
footer)..

|isHeader |boolean |*Camel 2.11* - optional - Identifies this
FixedLengthRecord as a header record

|isFooter |boolean |*Camel 2.11* - optional - Identifies this
FixedLengthRecords as a footer record

|ignoreTrailingChars |boolean |*Camel 2.11.1* - optional - Indicates
that characters beyond the last mapped filed can be ignored when
unmarshalling / parsing.

|  |  |This annotation is associated to the root class of the model and
must be declared one time.
|=======================================================================

[Note]
====


The hasHeader/hasFooter parameters are mutually exclusive with
isHeader/isFooter. A record may not be both a header/footer and a
primary fixed-length record.

====

*case 1 : Simple fixed length record*

This simple example shows how to design the model to parse/format a
fixed message

10A9PaulineMISINXD12345678BUYShare2500.45USD01-08-2009

*Fixed-simple*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
   @FixedLengthRecord(length=54, paddingChar=' ')
    public static class Order {

        @DataField(pos = 1, length=2)
        private int orderNr;

        @DataField(pos = 3, length=2)
        private String clientNr;

        @DataField(pos = 5, length=7)
        private String firstName;

        @DataField(pos = 12, length=1, align="L")
        private String lastName;

        @DataField(pos = 13, length=4)
        private String instrumentCode;

        @DataField(pos = 17, length=10)
        private String instrumentNumber;

        @DataField(pos = 27, length=3)
        private String orderType;

        @DataField(pos = 30, length=5)
        private String instrumentType;

        @DataField(pos = 35, precision = 2, length=7)
        private BigDecimal amount;

        @DataField(pos = 42, length=3)
        private String currency;

        @DataField(pos = 45, length=10, pattern = "dd-MM-yyyy")
        private Date orderDate;
        ...
----

*case 2 : Fixed length record with alignment and padding*

This more elaborated example show how to define the alignment for a
field and how to assign a padding character which is ' ' here''

10A9 PaulineM ISINXD12345678BUYShare2500.45USD01-08-2009

*Fixed-padding-align*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
   @FixedLengthRecord(length=60, paddingChar=' ')
    public static class Order {

        @DataField(pos = 1, length=2)
        private int orderNr;

        @DataField(pos = 3, length=2)
        private String clientNr;

        @DataField(pos = 5, length=9)
        private String firstName;

        @DataField(pos = 14, length=5, align="L")   // align text to the LEFT zone of the block
        private String lastName;

        @DataField(pos = 19, length=4)
        private String instrumentCode;

        @DataField(pos = 23, length=10)
        private String instrumentNumber;

        @DataField(pos = 33, length=3)
        private String orderType;

        @DataField(pos = 36, length=5)
        private String instrumentType;

        @DataField(pos = 41, precision = 2, length=7)
        private BigDecimal amount;

        @DataField(pos = 48, length=3)
        private String currency;

        @DataField(pos = 51, length=10, pattern = "dd-MM-yyyy")
        private Date orderDate;
        ...
----

*case 3 : Field padding*

Sometimes, the default padding defined for record cannnot be applied to
the field as we have a number format where we would like to padd with
'0' instead of ' '. In this case, you can use in the model the attribute
paddingField to set this value.

10A9 PaulineM ISINXD12345678BUYShare000002500.45USD01-08-2009

*Fixed-padding-field*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    @FixedLengthRecord(length = 65, paddingChar = ' ')
    public static class Order {

        @DataField(pos = 1, length = 2)
        private int orderNr;

        @DataField(pos = 3, length = 2)
        private String clientNr;

        @DataField(pos = 5, length = 9)
        private String firstName;

        @DataField(pos = 14, length = 5, align = "L")
        private String lastName;

        @DataField(pos = 19, length = 4)
        private String instrumentCode;

        @DataField(pos = 23, length = 10)
        private String instrumentNumber;

        @DataField(pos = 33, length = 3)
        private String orderType;

        @DataField(pos = 36, length = 5)
        private String instrumentType;

        @DataField(pos = 41, precision = 2, length = 12, paddingChar = '0')
        private BigDecimal amount;

        @DataField(pos = 53, length = 3)
        private String currency;

        @DataField(pos = 56, length = 10, pattern = "dd-MM-yyyy")
        private Date orderDate;
        ...
----

*case 4: Fixed length record with delimiter*

Fixed-length records sometimes have delimited content within the record.
The firstName and lastName fields are delimited with the '^' character
in the following example:

10A9Pauline^M^ISINXD12345678BUYShare000002500.45USD01-08-2009

*Fixed-delimited*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    @FixedLengthRecord()
    public static class Order {

        @DataField(pos = 1, length = 2)
        private int orderNr;

        @DataField(pos = 2, length = 2)
        private String clientNr;

        @DataField(pos = 3, delimiter = "^")
        private String firstName;

        @DataField(pos = 4, delimiter = "^")
        private String lastName;

        @DataField(pos = 5, length = 4)
        private String instrumentCode;

        @DataField(pos = 6, length = 10)
        private String instrumentNumber;

        @DataField(pos = 7, length = 3)
        private String orderType;

        @DataField(pos = 8, length = 5)
        private String instrumentType;

        @DataField(pos = 9, precision = 2, length = 12, paddingChar = '0')
        private BigDecimal amount;

        @DataField(pos = 10, length = 3)
        private String currency;

        @DataField(pos = 11, length = 10, pattern = "dd-MM-yyyy")
        private Date orderDate;
----

[Note]
====


As of *Camel 2.11* the 'pos' value(s) in a fixed-length record may
optionally be defined using ordinal, sequential values instead of
precise column numbers.

====

*case 5 : Fixed length record with record-defined field length*

Occasionally a fixed-length record may contain a field that define the
expected length of another field within the same record. In the
following example the length of the instrumentNumber field value is
defined by the value of instrumentNumberLen field in the record.

10A9Pauline^M^ISIN10XD12345678BUYShare000002500.45USD01-08-2009

*Fixed-delimited*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    @FixedLengthRecord()
    public static class Order {

        @DataField(pos = 1, length = 2)
        private int orderNr;

        @DataField(pos = 2, length = 2)
        private String clientNr;

        @DataField(pos = 3, delimiter = "^")
        private String firstName;

        @DataField(pos = 4, delimiter = "^")
        private String lastName;

        @DataField(pos = 5, length = 4)
        private String instrumentCode;

        @DataField(pos = 6, length = 2, align = "R", paddingChar = '0')
        private int instrumentNumberLen;
        
        @DataField(pos = 7, lengthPos=6)
        private String instrumentNumber;

        @DataField(pos = 8, length = 3)
        private String orderType;

        @DataField(pos = 9, length = 5)
        private String instrumentType;

        @DataField(pos = 10, precision = 2, length = 12, paddingChar = '0')
        private BigDecimal amount;

        @DataField(pos = 11, length = 3)
        private String currency;

        @DataField(pos = 12, length = 10, pattern = "dd-MM-yyyy")
        private Date orderDate;
----

*case 6 : Fixed length record with header and footer*

Bindy will discover fixed-length header and footer records that are
configured as part of the model – provided that the annotated classes
exist either in the same package as the primary @FixedLengthRecord
class, or within one of the configured scan packages. The following text
illustrates two fixed-length records that are bracketed by a header
record and footer record.

101-08-2009 +
10A9 PaulineM ISINXD12345678BUYShare000002500.45USD01-08-2009 +
10A9 RichN ISINXD12345678BUYShare000002700.45USD01-08-2009 +
9000000002

*Fixed-header-and-footer-main-class*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@FixedLengthRecord(hasHeader = true, hasFooter = true)
public class Order {

    @DataField(pos = 1, length = 2)
    private int orderNr;

    @DataField(pos = 2, length = 2)
    private String clientNr;

    @DataField(pos = 3, length = 9)
    private String firstName;

    @DataField(pos = 4, length = 5, align = "L")
    private String lastName;

    @DataField(pos = 5, length = 4)
    private String instrumentCode;

    @DataField(pos = 6, length = 10)
    private String instrumentNumber;

    @DataField(pos = 7, length = 3)
    private String orderType;

    @DataField(pos = 8, length = 5)
    private String instrumentType;

    @DataField(pos = 9, precision = 2, length = 12, paddingChar = '0')
    private BigDecimal amount;

    @DataField(pos = 10, length = 3)
    private String currency;

    @DataField(pos = 11, length = 10, pattern = "dd-MM-yyyy")
    private Date orderDate;
...
}


@FixedLengthRecord(isHeader = true)
public  class OrderHeader {
    @DataField(pos = 1, length = 1)
    private int recordType = 1;
    
    @DataField(pos = 2, length = 10, pattern = "dd-MM-yyyy")
    private Date recordDate;
    
...
}


@FixedLengthRecord(isFooter = true)
public class OrderFooter {
    
    @DataField(pos = 1, length = 1)
    private int recordType = 9;
    
    @DataField(pos = 2, length = 9, align = "R", paddingChar = '0')
    private int numberOfRecordsInTheFile;

...
}
----

*case 7 : Skipping content when parsing a fixed length record. (Camel
2.11.1)*

It is common to integrate with systems that provide fixed-length records
containing more information than needed for the target use case. It is
useful in this situation to skip the declaration and parsing of those
fields that we do not need. To accomodate this, Bindy will skip forward
to the next mapped field within a record if the 'pos' value of the next
declared field is beyond the cursor position of the last parsed field.
Using absolute 'pos' locations for the fields of interest (instead of
ordinal values) causes Bindy to skip content between two fields.

Similarly, it is possible that none of the content beyond some field is
of interest. In this case, you can tell Bindy to skip parsing of
everything beyond the last mapped field by setting the
*ignoreTrailingChars* property on the @FixedLengthRecord declaration.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@FixedLengthRecord(ignoreTrailingChars = true)
public static class Order {

        @DataField(pos = 1, length = 2)
        private int orderNr;

        @DataField(pos = 3, length = 2)
        private String clientNr;

    ... any characters that appear beyond the last mapped field will be ignored

}
----

[[BookDataFormatAppendix-5.Message]]
5. Message
^^^^^^^^^^

The Message annotation is used to identified the class of your model who
will contain key value pairs fields. This kind of format is used mainly
in Financial Exchange Protocol Messages (FIX). Nevertheless, this
annotation can be used for any other format where data are identified by
keys. The key pair values are separated each other by a separator which
can be a special character like a tab delimitor (unicode representation
: \u0009) or a start of heading (unicode representation : \u0001)

[Note]
====
 **"FIX information"**

More information about FIX can be found on this web site :
http://www.fixprotocol.org/. To work with FIX messages, the model must
contain a Header and Trailer classes linked to the root message class
which could be a Order class. This is not mandatory but will be very
helpful when you will use camel-bindy in combination with camel-fix
which is a Fix gateway based on quickFix project
http://www.quickfixj.org/.

====

[width="100%",cols="34%,33%,33%",options="header",]
|===================================
|Annotation name |Record type |Level
|*Message* |key value pair |Class
|===================================

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter name |type |Info
|pairSeparator |string |mandatory - can be '=' or ';' or 'anything'

|keyValuePairSeparair |string |mandatory - can be '\u0001', '\u0009',
'#' or 'anything'

|crlf |string |optional - possible values = WINDOWS,UNIX,MAC, or custom;
default value = WINDOWS - allow to define the carriage return character
to use. If you specify a value other than the three listed before, the
value you enter (custom) will be used as the CRLF character(s)

|type |string |optional - define the type of message (e.g. FIX, EMX,
...)

|version |string |optional - version of the message (e.g. 4.1)

|isOrdered |boolean |optional - default value = false - allow to change
the order of the fields when FIX message is generated

|  |  |This annotation is associated to the message class of the model
and must be declared one time.
|=======================================================================

*case 1 : separator = 'u0001'*

The separator used to segregate the key value pair fields in a FIX
message is the ASCII '01' character or in unicode format '\u0001'. This
character must be escaped a second time to avoid a java runtime error.
Here is an example :

8=FIX.4.1 9=20 34=1 35=0 49=INVMGR 56=BRKR 1=BE.CHM.001 11=CHM0001-01
22=4 ...

and how to use the annotation

*FIX - message*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Message(keyValuePairSeparator = "=", pairSeparator = "\u0001", type="FIX", version="4.1")
public class Order {
...
}
----

[Note]
====
 **Look at test cases**

The ASCII character like tab, ... cannot be displayed in WIKI page. So,
have a look to the test case of camel-bindy to see exactly how the FIX
message looks like (src\test\data\fix\fix.txt) and the Order, Trailer,
Header classes
(src\test\java\org\apache\camel\dataformat\bindy\model\fix\simple\Order.java)

====

[[BookDataFormatAppendix-6.KeyValuePairField]]
6. KeyValuePairField
^^^^^^^^^^^^^^^^^^^^

The KeyValuePairField annotation defines the property of a key value
pair field. Each KeyValuePairField is identified by a tag (= key) and
its value associated, a type (string, int, date, ...), optionaly a
pattern and if the field is required

[width="100%",cols="34%,33%,33%",options="header",]
|===================================================
|Annotation name |Record type |Level
|*KeyValuePairField* |Key Value Pair - FIX |Property
|===================================================

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter name |type |Info
|tag |int |mandatory - digit number identifying the field in the message
- must be unique

|pattern |string |optional - default value = "" - will be used to format
Decimal, Date, ...

|precision |int |optional - digit number - represents the precision to
be used when the Decimal number will be formatted/parsed

|position |int |optional - must be used when the position of the key/tag
in the FIX message must be different

|required |boolean |optional - default value = "false"

|impliedDecimalSeparator |boolean |*Camel 2.11:* optional - default
value = "false" - Indicates if there is a decimal point implied at a
specified location
|=======================================================================

*case 1 : tag*

This parameter represents the key of the field in the message

*FIX message - Tag*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Message(keyValuePairSeparator = "=", pairSeparator = "\u0001", type="FIX", version="4.1")
public class Order {

    @Link Header header;

    @Link Trailer trailer;

    @KeyValuePairField(tag = 1) // Client reference
    private String Account;

    @KeyValuePairField(tag = 11) // Order reference
    private String ClOrdId;

    @KeyValuePairField(tag = 22) // Fund ID type (Sedol, ISIN, ...)
    private String IDSource;

    @KeyValuePairField(tag = 48) // Fund code
    private String SecurityId;

    @KeyValuePairField(tag = 54) // Movement type ( 1 = Buy, 2 = sell)
    private String Side;

    @KeyValuePairField(tag = 58) // Free text
    private String Text;

...
}
----

*case 2 : Different position in output*

If the tags/keys that we will put in the FIX message must be sorted
according to a predefine order, then use the attribute 'position' of the
annotation @KeyValuePairField

*FIX message - Tag - sort*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Message(keyValuePairSeparator = "=", pairSeparator = "\\u0001", type = "FIX", version = "4.1", isOrdered = true)
public class Order {

    @Link Header header;

    @Link Trailer trailer;

    @KeyValuePairField(tag = 1, position = 1) // Client reference
    private String account;

    @KeyValuePairField(tag = 11, position = 3) // Order reference
    private String clOrdId;

...
}
----

[[BookDataFormatAppendix-7.Section]]
7. Section
^^^^^^^^^^

In FIX message of fixed length records, it is common to have different
sections in the representation of the information : header, body and
section. The purpose of the annotation @Section is to inform bindy about
which class of the model represents the header (= section 1), body (=
section 2) and footer (= section 3)

Only one attribute/parameter exists for this annotation.

[width="100%",cols="34%,33%,33%",options="header",]
|===================================
|Annotation name |Record type |Level
|*Section* |FIX |Class
|===================================

[width="100%",cols="34%,33%,33%",options="header",]
|==========================================================
|Parameter name |type |Info
|number |int |digit number identifying the section position
|==========================================================

*case 1 : Section*

A. Definition of the header section

*FIX message - Section - Header*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Section(number = 1)
public class Header {

    @KeyValuePairField(tag = 8, position = 1) // Message Header
    private String beginString;

    @KeyValuePairField(tag = 9, position = 2) // Checksum
    private int bodyLength;
...
}
----

B. Definition of the body section

*FIX message - Section - Body*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Section(number = 2)
@Message(keyValuePairSeparator = "=", pairSeparator = "\\u0001", type = "FIX", version = "4.1", isOrdered = true)
public class Order {

    @Link Header header;

    @Link Trailer trailer;

    @KeyValuePairField(tag = 1, position = 1) // Client reference
    private String account;

    @KeyValuePairField(tag = 11, position = 3) // Order reference
    private String clOrdId;
----

C. Definition of the footer section

*FIX message - Section - Footer*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Section(number = 3)
public class Trailer {

    @KeyValuePairField(tag = 10, position = 1)
    // CheckSum
    private int checkSum;

    public int getCheckSum() {
        return checkSum;
    }
----

[[BookDataFormatAppendix-8.OneToMany]]
8. OneToMany
^^^^^^^^^^^^

The purpose of the annotation @OneToMany is to allow to work with a
List<?> field defined a POJO class or from a record containing
repetitive groups.

[Note]
====
 **Restrictions OneToMany**

Be careful, the one to many of bindy does not allow to handle
repetitions defined on several levels of the hierarchy

====

The relation OneToMany ONLY WORKS in the following cases :

* Reading a FIX message containing repetitive groups (= group of
tags/keys)
* Generating a CSV with repetitive data

[width="100%",cols="34%,33%,33%",options="header",]
|===================================
|Annotation name |Record type |Level
|*OneToMany* |all |property
|===================================

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter name |type |Info
|mappedTo |string |optional - string - class name associated to the type
of the List<Type of the Class>
|=======================================================================

*case 1 : Generating CSV with repetitive data*

Here is the CSV output that we want :

Claus,Ibsen,Camel in Action 1,2010,35 +
Claus,Ibsen,Camel in Action 2,2012,35 +
Claus,Ibsen,Camel in Action 3,2013,35 +
Claus,Ibsen,Camel in Action 4,2014,35

Remark : the repetitive data concern the title of the book and its
publication date while first, last name and age are common

and the classes used to modeling this. The Author class contains a List
of Book.

*Generate CSV with repetitive data*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@CsvRecord(separator=",")
public class Author {

    @DataField(pos = 1)
    private String firstName;

    @DataField(pos = 2)
    private String lastName;

    @OneToMany
    private List<Book> books;

    @DataField(pos = 5)
    private String Age;
...


public class Book {

    @DataField(pos = 3)
    private String title;

    @DataField(pos = 4)
    private String year;
----

Very simple isn't it !!!

*case 2 : Reading FIX message containing group of tags/keys*

Here is the message that we would like to process in our model :

"8=FIX 4.19=2034=135=049=INVMGR56=BRKR" +
"1=BE.CHM.00111=CHM0001-0158=this is a camel - bindy test" +
"22=448=BE000124567854=1" +
"22=548=BE000987654354=2" +
"22=648=BE000999999954=3" +
"10=220"

tags 22, 48 and 54 are repeated

and the code

*Reading FIX message containing group of tags/keys*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
public class Order {

    @Link Header header;

    @Link Trailer trailer;

    @KeyValuePairField(tag = 1) // Client reference
    private String account;

    @KeyValuePairField(tag = 11) // Order reference
    private String clOrdId;

    @KeyValuePairField(tag = 58) // Free text
    private String text;

    @OneToMany(mappedTo = "org.apache.camel.dataformat.bindy.model.fix.complex.onetomany.Security")
    List<Security> securities;
...

public class Security {

    @KeyValuePairField(tag = 22) // Fund ID type (Sedol, ISIN, ...)
    private String idSource;

    @KeyValuePairField(tag = 48) // Fund code
    private String securityCode;

    @KeyValuePairField(tag = 54) // Movement type ( 1 = Buy, 2 = sell)
    private String side;
----

[[BookDataFormatAppendix-UsingtheJavaDSL.2]]
Using the Java DSL
^^^^^^^^^^^^^^^^^^

The next step consists in instantiating the DataFormat _bindy_ class
associated with this record type and providing Java package name(s) as
parameter.

For example the following uses the class `BindyCsvDataFormat` (who
correspond to the class associated with the CSV record type) which is
configured with "com.acme.model" +
package name to initialize the model objects configured in this package.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Camel 2.15 or older (configure by package name)
DataFormat bindy = new BindyCsvDataFormat("com.acme.model");

 
// Camel 2.16 onwards (configure by class name)
DataFormat bindy = new BindyCsvDataFormat(com.acme.model.MyModel.class);
----

[[BookDataFormatAppendix-Settinglocale]]
Setting locale
++++++++++++++

Bindy supports configuring the locale on the dataformat, such as 

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Camel 2.15 or older (configure by package name)
BindyCsvDataFormat bindy = new BindyCsvDataFormat("com.acme.model");
// Camel 2.16 onwards (configure by class name)
BindyCsvDataFormat bindy = new BindyCsvDataFormat(com.acme.model.MyModel.class);

bindy.setLocale("us");
----

Or to use the platform default locale then use "default" as the locale
name. Notice this requires Camel 2.14/2.13.3/2.12.5.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Camel 2.15 or older (configure by package name)
BindyCsvDataFormat bindy = new BindyCsvDataFormat("com.acme.model");
// Camel 2.16 onwards (configure by class name)
BindyCsvDataFormat bindy = new BindyCsvDataFormat(com.acme.model.MyModel.class);

bindy.setLocale("default");
----

for older releases you can set it using Java code as shown

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Camel 2.15 or older (configure by package name)
BindyCsvDataFormat bindy = new BindyCsvDataFormat("com.acme.model");
// Camel 2.16 onwards (configure by class name)
BindyCsvDataFormat bindy = new BindyCsvDataFormat(com.acme.model.MyModel.class);


bindy.setLocale(Locale.getDefault().getISO3Country());
----

[[BookDataFormatAppendix-Unmarshaling]]
Unmarshaling
++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://inbox")
  .unmarshal(bindy)
  .to("direct:handleOrders");
----

Alternatively, you can use a named reference to a data format which can
then be defined in your link:registry.html[Registry] e.g. your
link:spring.html[Spring] XML file:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://inbox")
  .unmarshal("myBindyDataFormat")
  .to("direct:handleOrders");
----

The Camel route will pick-up files in the inbox directory, unmarshall
CSV records into a collection of model objects and send the collection +
to the route referenced by 'handleOrders'.

The collection returned is a *List of Map* objects. Each Map within the
list contains the model objects that were marshalled out of each line of
the CSV. The reason behind this is that _each line can correspond to
more than one object_. This can be confusing when you simply expect one
object to be returned per line.

Each object can be retrieve using its class name.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    List<Map<String, Object>> unmarshaledModels = (List<Map<String, Object>>) exchange.getIn().getBody();

    int modelCount = 0;
    for (Map<String, Object> model : unmarshaledModels) {
      for (String className : model.keySet()) {
         Object obj = model.get(className);
         LOG.info("Count : " + modelCount + ", " + obj.toString());
      }
     modelCount++;
    }

    LOG.info("Total CSV records received by the csv bean : " + modelCount);
----

Assuming that you want to extract a single Order object from this map
for processing in a route, you could use a combination of a
link:splitter.html[Splitter] and a link:processor.html[Processor] as per
the following:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://inbox")
    .unmarshal(bindy)
    .split(body())
        .process(new Processor() {
            public void process(Exchange exchange) throws Exception {
                Message in = exchange.getIn();
                Map<String, Object> modelMap = (Map<String, Object>) in.getBody();
                in.setBody(modelMap.get(Order.class.getCanonicalName()));
            }
        })
        .to("direct:handleSingleOrder")
    .end();
----

Take care of the fact that Bindy uses CHARSET_NAME property or the
CHARSET_NAME header as define in the Exchange interface to do a
characterset conversion of the inputstream received for unmarshalling.
In some producers (e.g. file-endpoint) you can define a characterset.
The characterset conversion can already been done by this producer.
Sometimes you need to remove this property or header from the exchange
before sending it to the unmarshal. If you don't remove it the
conversion might be done twice which might lead to unwanted results.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("file://inbox?charset=Cp922")
  .removeProperty(Exchange.CHARSET_NAME)
  .unmarshal("myBindyDataFormat")
  .to("direct:handleOrders");
----

[[BookDataFormatAppendix-Marshaling]]
Marshaling
++++++++++

To generate CSV records from a collection of model objects, you create
the following route :

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:handleOrders")
   .marshal(bindy)
   .to("file://outbox")
----

[[BookDataFormatAppendix-UsingSpringXML.2]]
Using Spring XML
^^^^^^^^^^^^^^^^

This is really easy to use Spring as your favorite DSL language to
declare the routes to be used for camel-bindy. The following example
shows two routes where the first will pick-up records from files,
unmarshal the content and bind it to their model. The result is then
send to a pojo (doing nothing special) and place them into a queue.

The second route will extract the pojos from the queue and marshal the
content to generate a file containing the csv record. The example above
is for using Camel 2.16 onwards.

*spring dsl*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://camel.apache.org/schema/spring
       http://camel.apache.org/schema/spring/camel-spring.xsd">

        <!-- Queuing engine - ActiveMq - work locally in mode virtual memory -->
    <bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent">
        <property name="brokerURL" value="vm://localhost:61616"/>
    </bean>


    <camelContext xmlns="http://camel.apache.org/schema/spring">

 
        <dataFormats>
          <bindy id="bindyDataformat" type="Csv" classType="org.apache.camel.bindy.model.Order"/>
        </dataFormats>

        <route>
            <from uri="file://src/data/csv/?noop=true" />
            <unmarshal ref="bindyDataformat" />
            <to uri="bean:csv" />
            <to uri="activemq:queue:in" />
        </route>

        <route>
            <from uri="activemq:queue:in" />
            <marshal ref="bindyDataformat" />
            <to uri="file://src/data/csv/out/" />
        </route>
    </camelContext>
</beans>
----

[Note]
====
 **Be careful**

Please verify that your model classes implements serializable otherwise
the queue manager will raise an error

====

[[BookDataFormatAppendix-Dependencies.8]]
Dependencies
^^^^^^^^^^^^

To use Bindy in your camel routes you need to add the a dependency on
*camel-bindy* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-bindy</artifactId>
  <version>x.x.x</version>
</dependency>
----

[[BookDataFormatAppendix-XMLSecurityDataFormat]]
XMLSecurity Data Format
~~~~~~~~~~~~~~~~~~~~~~~

The XMLSecurity Data Format facilitates encryption and decryption of XML
payloads at the Document, Element, and Element Content levels (including
simultaneous multi-node encryption/decryption using XPath). To sign
messages using the XML Signature specification, please see the Camel XML
Security link:xml-security-component.html[component].

The encryption capability is based on formats supported using the Apache
XML Security (Santuario) project. Symmetric encryption/decryption is
currently supported using Triple-DES and AES (128, 192, and 256)
encryption formats. Additional formats can be easily added later as
needed. This capability allows Camel users to encrypt/decrypt payloads
while being dispatched or received along a route.

*Available as of Camel 2.9* +
The XMLSecurity Data Format supports asymmetric key encryption. In this
encryption model a symmetric key is generated and used to perform XML
content encryption or decryption. This "content encryption key" is then
itself encrypted using an asymmetric encryption algorithm that leverages
the recipient's public key as the "key encryption key". Use of an
asymmetric key encryption algorithm ensures that only the holder of the
recipient's private key can access the generated symmetric encryption
key. Thus, only the private key holder can decode the message. The
XMLSecurity Data Format handles all of the logic required to encrypt and
decrypt the message content and encryption key(s) using asymmetric key
encryption.

The XMLSecurity Data Format also has improved support for namespaces
when processing the XPath queries that select content for encryption. A
namespace definition mapping can be included as part of the data format
configuration. This enables true namespace matching, even if the prefix
values in the XPath query and the target xml document are not equivalent
strings.

[[BookDataFormatAppendix-BasicOptions]]
Basic Options
^^^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`secureTag` |`null` |The XPath reference to the XML Element selected
for encryption/decryption. If no tag is specified, the entire payload is
encrypted/decrypted.

|`secureTagContents` |`false` a|
A boolean value to specify whether the XML Element is to be encrypted or
the contents of the XML Element

* `false` = Element Level
* `true` = Element Content Level

|`passPhrase` |`null` |A String used as passPhrase to encrypt/decrypt
content. The passPhrase has to be provided. If no passPhrase is
specified, a default passPhrase is used. The passPhrase needs to be put
together in conjunction with the appropriate encryption algorithm. For
example using `TRIPLEDES` the passPhase can be a
`"Only another 24 Byte key"`

|`xmlCipherAlgorithm` |`TRIPLEDES` a|
The cipher algorithm to be used for encryption/decryption of the XML
message content. The available choices are:

* `XMLCipher.TRIPLEDES`
* `XMLCipher.AES_128`
* `XMLCipher.AES_128_GCM` *Camel 2.12*
* `XMLCipher.AES_192`
* `XMLCipher.AES_192_GCM` *Camel 2.12*
* `XMLCipher.AES_256`
* `XMLCipher.AES_256_GCM` *Camel 2.12*
* XMLCipher.SEED_128 *Camel 2.15*
* XMLCipher.CAMELLIA_128, XMLCipher.CAMELLIA_192, XMLCipher.CAMELLIA_256
*Camel 2.15*

|`namespaces` |`null` |A map of namespace values indexed by prefix. The
index values must match the prefixes used in the `secureTag` XPath
query.
|=======================================================================

[[BookDataFormatAppendix-AsymmetricEncryptionOptions]]
Asymmetric Encryption Options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These options can be applied in addition to relevant the Basic options
to use asymmetric key encryption.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`recipientKeyAlias` |`null` |The key alias to be used when retrieving
the recipient's public or private key from a KeyStore when performing
asymmetric key encryption or decryption.

|`keyCipherAlgorithm` |*Camel 2.12* `XMLCipher.RSA_OAEP` a|
The cipher algorithm to be used for encryption/decryption of the
asymmetric key. The available choices are:

* `XMLCipher.RSA_v1dot5`
* `XMLCipher.RSA_OAEP`
* `XMLCipher.RSA_OAEP_11`

|`keyOrTrustStoreParameters` |`null` |Configuration options for creating
and loading a KeyStore instance that represents the sender's trustStore
or recipient's keyStore.

|`keyPassword` |`null` |*Camel 2.10.2 / 2.11:* The password to be used
for retrieving the private key from the KeyStore. This key is used for
asymmetric decryption.

|`digestAlgorithm` |XMLCipher.SHA1 a|
*Camel 2.12* The digest algorithm to use with the RSA OAEP algorithm.
The available choices are:

* `XMLCipher.SHA1`
* `XMLCipher.SHA256`
* `XMLCipher.SHA512`

|`mgfAlgorithm` |EncryptionConstants.MGF1_SHA1 a|
*Camel 2.12* The MGF Algorithm to use with the RSA OAEP algorithm. The
available choices are:

* `EncryptionConstants.MGF1_SHA1`
* `EncryptionConstants.MGF1_SHA256`
* `EncryptionConstants.MGF1_SHA512`

|addKeyValueForEncryptedKey |true |*Camel 2.14.1* Whether to add the
public key used to encrypt the session key as a KeyValue in the
EncryptedKey structure or not.
|=======================================================================

[[BookDataFormatAppendix-KeyCipherAlgorithm]]
Key Cipher Algorithm
++++++++++++++++++++

As of Camel 2.12.0, the default Key Cipher Algorithm is now
XMLCipher.RSA_OAEP instead of XMLCipher.RSA_v1dot5. Usage of
XMLCipher.RSA_v1dot5 is discouraged due to various attacks. Requests
that use RSA v1.5 as the key cipher algorithm will be rejected unless it
has been explicitly configured as the key cipher algorithm.

[[BookDataFormatAppendix-Marshal.2]]
Marshal
^^^^^^^

In order to encrypt the payload, the `marshal` processor needs to be
applied on the route followed by the *`secureXML()`* tag.

[[BookDataFormatAppendix-Unmarshal.2]]
Unmarshal
^^^^^^^^^

In order to decrypt the payload, the `unmarshal` processor needs to be
applied on the route followed by the *`secureXML()`* tag.

[[BookDataFormatAppendix-Examples]]
Examples
^^^^^^^^

Given below are several examples of how marshalling could be performed
at the Document, Element, and Content levels.

[[BookDataFormatAppendix-FullPayloadencryption/decryption]]
Full Payload encryption/decryption
++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start")
    .marshal().secureXML()
    .unmarshal().secureXML()
    .to("direct:end");
----

[[BookDataFormatAppendix-PartialPayloadContentOnlyencryption/decryption]]
Partial Payload Content Only encryption/decryption
++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
String tagXPATH = "//cheesesites/italy/cheese";
boolean secureTagContent = true;
...
from("direct:start")
    .marshal().secureXML(tagXPATH, secureTagContent)
    .unmarshal().secureXML(tagXPATH, secureTagContent)
    .to("direct:end");
----

[[BookDataFormatAppendix-PartialMultiNodePayloadContentOnlyencryption/decryption]]
Partial Multi Node Payload Content Only encryption/decryption
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
String tagXPATH = "//cheesesites/*/cheese";
boolean secureTagContent = true;
...
from("direct:start")
    .marshal().secureXML(tagXPATH, secureTagContent)
    .unmarshal().secureXML(tagXPATH, secureTagContent)
    .to("direct:end");
----

[[BookDataFormatAppendix-PartialPayloadContentOnlyencryption/decryptionwithchoiceofpassPhrase(password)]]
Partial Payload Content Only encryption/decryption with choice of
passPhrase(password)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
String tagXPATH = "//cheesesites/italy/cheese";
boolean secureTagContent = true;
...
String passPhrase = "Just another 24 Byte key";
from("direct:start")
    .marshal().secureXML(tagXPATH, secureTagContent, passPhrase)
    .unmarshal().secureXML(tagXPATH, secureTagContent, passPhrase)
    .to("direct:end");
----

[[BookDataFormatAppendix-PartialPayloadContentOnlyencryption/decryptionwithpassPhrase(password)andAlgorithm]]
Partial Payload Content Only encryption/decryption with
passPhrase(password) and Algorithm
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
import org.apache.xml.security.encryption.XMLCipher;
....
String tagXPATH = "//cheesesites/italy/cheese";
boolean secureTagContent = true;
String passPhrase = "Just another 24 Byte key";
String algorithm= XMLCipher.TRIPLEDES;
from("direct:start")
    .marshal().secureXML(tagXPATH, secureTagContent, passPhrase, algorithm)
    .unmarshal().secureXML(tagXPATH, secureTagContent, passPhrase, algorithm)
    .to("direct:end");
----

[[BookDataFormatAppendix-PartialPayloadContentwithNamespacesupport]]
Partial Payload Content with Namespace support
++++++++++++++++++++++++++++++++++++++++++++++

[[BookDataFormatAppendix-JavaDSL]]
Java DSL

[source,brush:,java;,gutter:,false;,theme:,Default]
----
final Map<String, String> namespaces = new HashMap<String, String>();
namespaces.put("cust", "http://cheese.xmlsecurity.camel.apache.org/");

final KeyStoreParameters tsParameters = new KeyStoreParameters();
tsParameters.setPassword("password");
tsParameters.setResource("sender.ts");

context.addRoutes(new RouteBuilder() {
    public void configure() {
        from("direct:start")
           .marshal().secureXML("//cust:cheesesites/italy", namespaces, true, "recipient",
                                testCypherAlgorithm, XMLCipher.RSA_v1dot5, tsParameters)
           .to("mock:encrypted");
    }
}
----

[[BookDataFormatAppendix-SpringXML]]
Spring XML

A namespace prefix that is defined as part of the `camelContext`
definition can be re-used in context within the data format `secureTag`
attribute of the `secureXML` element.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="springXmlSecurityDataFormatTestCamelContext" 
              xmlns="http://camel.apache.org/schema/spring"
              xmlns:cheese="http://cheese.xmlsecurity.camel.apache.org/">        
    <route>
        <from uri="direct://start"/>
            <marshal>
                <secureXML secureTag="//cheese:cheesesites/italy"
                           secureTagContents="true"/>
            </marshal> 
            ...
----

[[BookDataFormatAppendix-AsymmetricKeyEncryption]]
Asymmetric Key Encryption
+++++++++++++++++++++++++

[[BookDataFormatAppendix-SpringXMLSender]]
Spring XML Sender

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<!--  trust store configuration -->                          
<camel:keyStoreParameters id="trustStoreParams" resource="./sender.ts" password="password"/>

<camelContext id="springXmlSecurityDataFormatTestCamelContext" 
              xmlns="http://camel.apache.org/schema/spring"
              xmlns:cheese="http://cheese.xmlsecurity.camel.apache.org/">        
    <route>
        <from uri="direct://start"/>
            <marshal>
                <secureXML secureTag="//cheese:cheesesites/italy"
                           secureTagContents="true"
                           xmlCipherAlgorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"       
                           keyCipherAlgorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5"
                           recipientKeyAlias="recipient"
                           keyOrTrustStoreParametersId="trustStoreParams"/>
            </marshal> 
            ...
----

[[BookDataFormatAppendix-SpringXMLRecipient]]
Spring XML Recipient

[source,brush:,java;,gutter:,false;,theme:,Default]
----
 
<!--  key store configuration -->
<camel:keyStoreParameters id="keyStoreParams" resource="./recipient.ks" password="password" />

<camelContext id="springXmlSecurityDataFormatTestCamelContext" 
              xmlns="http://camel.apache.org/schema/spring"
              xmlns:cheese="http://cheese.xmlsecurity.camel.apache.org/">
    <route>    
        <from uri="direct://encrypted"/>
            <unmarshal>
                <secureXML secureTag="//cheese:cheesesites/italy"
                           secureTagContents="true"
                           xmlCipherAlgorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"
                           keyCipherAlgorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5"
                           recipientKeyAlias="recipient"
                           keyOrTrustStoreParametersId="keyStoreParams"
                           keyPassword="privateKeyPassword" />
            </unmarshal>
            ...
----

[[BookDataFormatAppendix-Dependencies.9]]
Dependencies
^^^^^^^^^^^^

This data format is provided within the *camel-xmlsecurity* component.

The GZip link:data-format.html[Data Format] is a message compression and
de-compression format. It uses the same deflate algorithm that is used
in link:zip-dataformat.html[Zip DataFormat], although some additional
headers are provided. This format is produced by popular `gzip`/`gunzip`
tool. Messages marshalled using GZip compression can be unmarshalled
using GZip decompression just prior to being consumed at the endpoint.
The compression capability is quite useful when you deal with large XML
and Text based payloads or when you read messages previously comressed
using `gzip` tool.

[[BookDataFormatAppendix-Options.3]]
Options
^^^^^^^

There are no options provided for this data format.

[[BookDataFormatAppendix-Marshal.3]]
Marshal
^^^^^^^

In this example we marshal a regular text/XML payload to a compressed
payload employing gzip compression format and send it an ActiveMQ queue
called MY_QUEUE.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start").marshal().gzip().to("activemq:queue:MY_QUEUE");
----

[[BookDataFormatAppendix-Unmarshal.3]]
Unmarshal
^^^^^^^^^

In this example we unmarshal a gzipped payload from an ActiveMQ queue
called MY_QUEUE to its original format, and forward it for processing to
the `UnGZippedMessageProcessor`.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:queue:MY_QUEUE").unmarshal().gzip().process(new UnGZippedMessageProcessor()); 
----

[[BookDataFormatAppendix-Dependencies.10]]
Dependencies
^^^^^^^^^^^^

This data format is provided in *camel-core* so no additional
dependencies is needed.

[[BookDataFormatAppendix-Castor]]
Castor
~~~~~~

*Available as of Camel 2.1*

Castor is a link:data-format.html[Data Format] which uses the
http://www.castor.org/[Castor XML library] to unmarshal an XML payload
into Java objects or to marshal Java objects into an XML payload.

As usually you can use either Java DSL or Spring XML to work with Castor
Data Format.

[[BookDataFormatAppendix-UsingtheJavaDSL.3]]
Using the Java DSL
^^^^^^^^^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:order").
  marshal().castor().
  to("activemq:queue:order");
----

For example the following uses a named DataFormat of Castor which uses
default Castor data binding features.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
CastorDataFormat castor = new CastorDataFormat ();

from("activemq:My.Queue").
  unmarshal(castor).
  to("mqseries:Another.Queue");
----

If you prefer to use a named reference to a data format which can then
be defined in your Registry such as via your Spring XML file. e.g.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:My.Queue").
  unmarshal("mycastorType").
  to("mqseries:Another.Queue");
----

If you want to override default mapping schema by providing a mapping
file you can set it as follows.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
CastorDataFormat castor = new CastorDataFormat ();
castor.setMappingFile("mapping.xml");
----

Also if you want to have more control on Castor Marshaller and
Unmarshaller you can access them as below.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
castor.getMarshaller();
castor.getUnmarshaller();
----

[[BookDataFormatAppendix-UsingSpringXML.3]]
Using Spring XML
^^^^^^^^^^^^^^^^

The following example shows how to use Castor to unmarshal using Spring
configuring the castor data type

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:start"/>
    <unmarshal>
      <castor validation="true" />
    </unmarshal>
    <to uri="mock:result"/>
  </route>
</camelContext>
----

This example shows how to configure the data type just once and reuse it
on multiple routes. You have to set the <castor> element directly in
<camelContext>.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext>
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <dataFormats>
    <castor id="myCastor"/>
  </dataFormats>

  <route>
    <from uri="direct:start"/>
    <marshal ref="myCastor"/>
    <to uri="direct:marshalled"/>
  </route>
  <route>
    <from uri="direct:marshalled"/>
    <unmarshal ref="myCastor"/>
    <to uri="mock:result"/>
  </route>

</camelContext>
----

[[BookDataFormatAppendix-Options.4]]
Options
^^^^^^^

Castor supports the following options

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |Type |Default |Description
|encoding |String |UTF-8 |Encoding to use when marshalling an Object to
XML

|validation |Boolean |false |Whether validation is turned on or off.

|mappingFile |String |null |Path to a Castor mapping file to load from
the classpath.

|packages |String[] |null |Add additional packages to Castor XmlContext

|classNames |String[] |null |Add additional class names to Castor
XmlContext
|=======================================================================

[[BookDataFormatAppendix-Dependencies.11]]
Dependencies
^^^^^^^^^^^^

To use Castor in your camel routes you need to add the a dependency on
*camel-castor* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-castor</artifactId>
  <version>x.x.x</version>
</dependency>
----

[[BookDataFormatAppendix-Protobuf-ProtocolBuffers]]
Protobuf - Protocol Buffers
---------------------------

"Protocol Buffers - Google's data interchange format"

[Info]
====


Available from Camel 2.2

====

Camel provides a link:data-format.html[Data Format] to serialse between
Java and the Protocol Buffer protocol. The project's site details why
you may wish to
http://code.google.com/apis/protocolbuffers/docs/overview.html[choose
this format over xml]. Protocol Buffer is language-neutral and
platform-neutral, so messages produced by your Camel routes may be
consumed by other language implementations.

http://code.google.com/apis/protocolbuffers/[API Site] +
http://code.google.com/p/protobuf/[Protobuf Implementation] +
http://code.google.com/apis/protocolbuffers/docs/javatutorial.html[Protobuf
Java Tutorial]

[[BookDataFormatAppendix-Protobufoverview]]
Protobuf overview
~~~~~~~~~~~~~~~~~

This quick overview of how to use Protobuf. For more detail see the
http://code.google.com/apis/protocolbuffers/docs/javatutorial.html[complete
tutorial]

[[BookDataFormatAppendix-Definingtheprotoformat]]
Defining the proto format
^^^^^^^^^^^^^^^^^^^^^^^^^

The first step is to define the format for the body of your exchange.
This is defined in a .proto file as so:

*addressbook.proto*

[source,brush:,java;,gutter:,false;,theme:,Default]
----

package org.apache.camel.component.protobuf;

option java_package = "org.apache.camel.component.protobuf";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

message AddressBook {
  repeated Person person = 1;
}
----

[[BookDataFormatAppendix-GeneratingJavaclasses]]
Generating Java classes
^^^^^^^^^^^^^^^^^^^^^^^

The Protobuf SDK provides a compiler which will generate the Java
classes for the format we defined in our .proto file. You can run the
compiler for any additional supported languages you require.

`protoc --java_out=. ./addressbook.proto`

This will generate a single Java class named AddressBookProtos which
contains inner classes for Person and AddressBook. Builders are also
implemented for you. The generated classes implement
com.google.protobuf.Message which is required by the serialisation
mechanism. For this reason it important that only these classes are used
in the body of your exchanges. Camel will throw an exception on route
creation if you attempt to tell the link:data-format.html[Data Format]
to use a class that does not implement com.google.protobuf.Message. Use
the generated builders to translate the data from any of your existing
domain classes.

[[BookDataFormatAppendix-JavaDSL.1]]
Java DSL
~~~~~~~~

You can use create the ProtobufDataFormat instance and pass it to Camel
DataFormat marshal and unmarsha API like this.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
   ProtobufDataFormat format = new ProtobufDataFormat(Person.getDefaultInstance());

   from("direct:in").marshal(format);
   from("direct:back").unmarshal(format).to("mock:reverse");
----

Or use the DSL protobuf() passing the unmarshal default instance or
default instance class name like this.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
   // You don't need to specify the default instance for protobuf marshaling               
   from("direct:marshal").marshal().protobuf();
   from("direct:unmarshalA").unmarshal().
       protobuf("org.apache.camel.dataformat.protobuf.generated.AddressBookProtos$Person").
       to ("mock:reverse");
                
   from("direct:unmarshalB").unmarshal().protobuf(Person.getDefaultInstance()).to("mock:reverse");
----

[[BookDataFormatAppendix-SpringDSL]]
Spring DSL
~~~~~~~~~~

The following example shows how to use Castor to unmarshal using Spring
configuring the protobuf data type

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:start"/>
    <unmarshal>
      <protobuf instanceClass="org.apache.camel.dataformat.protobuf.generated.AddressBookProtos$Person" />
    </unmarshal>
    <to uri="mock:result"/>
  </route>
</camelContext>
----

[[BookDataFormatAppendix-Dependencies.12]]
Dependencies
^^^^^^^^^^^^

To use Protobuf in your camel routes you need to add the a dependency on
*camel-protobuf* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-protobuf</artifactId>
  <version>2.2.0</version>
</dependency>
----

[[BookDataFormatAppendix-SOAPDataFormat]]
SOAP DataFormat
~~~~~~~~~~~~~~~

*Available as of Camel 2.3*

SOAP is a link:data-format.html[Data Format] which uses JAXB2 and JAX-WS
annotations to marshal and unmarshal SOAP payloads. It provides the
basic features of Apache CXF without need for the CXF Stack.

**Supported SOAP versions**

SOAP 1.1 is supported by default. SOAP 1.2 is supported from Camel 2.11
onwards.

**Namespace prefix mapping**

See link:jaxb.html[JAXB] for details how you can control namespace
prefix mappings when marshalling using link:soap.html[SOAP] data format.

[[BookDataFormatAppendix-ElementNameStrategy]]
ElementNameStrategy
^^^^^^^^^^^^^^^^^^^

An element name strategy is used for two purposes. The first is to find
a xml element name for a given object and soap action when marshaling
the object into a SOAP message. The second is to find an Exception class
for a given soap fault name.

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Strategy |Usage
|QNameStrategy |Uses a fixed qName that is configured on instantiation.
Exception lookup is not supported

|TypeNameStrategy |Uses the name and namespace from the @XMLType
annotation of the given type. If no namespace is set then package-info
is used. Exception lookup is not supported

|ServiceInterfaceStrategy |Uses information from a webservice interface
to determine the type name and to find the exception class for a SOAP
fault
|=======================================================================

If you have generated the web service stub code with cxf-codegen or a
similar tool then you probably will want to use the
ServiceInterfaceStrategy. In the case you have no annotated service
interface you should use QNameStrategy or TypeNameStrategy.

[[BookDataFormatAppendix-UsingtheJavaDSL.4]]
Using the Java DSL
^^^^^^^^^^^^^^^^^^

The following example uses a named DataFormat of _soap_ which is
configured with the package com.example.customerservice to initialize
the
http://java.sun.com/javase/6/docs/api/javax/xml/bind/JAXBContext.html[JAXBContext].
The second parameter is the ElementNameStrategy. The route is able to
marshal normal objects as well as exceptions. (Note the below just sends
a SOAP Envelope to a queue. A web service provider would actually need
to be listening to the queue for a SOAP call to actually occur, in which
case it would be a one way SOAP request. If you need request reply then
you should look at the next example.)

[source,brush:,java;,gutter:,false;,theme:,Default]
----
SoapJaxbDataFormat soap = new SoapJaxbDataFormat("com.example.customerservice", new ServiceInterfaceStrategy(CustomerService.class));
from("direct:start")
  .marshal(soap)
  .to("jms:myQueue");
----

[Tip]
====
 **See also**

As the SOAP dataformat inherits from the link:jaxb.html[JAXB] dataformat
most settings apply here as well

====

[[BookDataFormatAppendix-UsingSOAP1.2]]
Using SOAP 1.2
++++++++++++++

*Available as of Camel 2.11*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
SoapJaxbDataFormat soap = new SoapJaxbDataFormat("com.example.customerservice", new ServiceInterfaceStrategy(CustomerService.class));
soap.setVersion("1.2");
from("direct:start")
  .marshal(soap)
  .to("jms:myQueue");
----

When using XML DSL there is a version attribute you can set on the
<soapjaxb> element.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    <!-- Defining a ServiceInterfaceStrategy for retrieving the element name when marshalling -->
    <bean id="myNameStrategy" class="org.apache.camel.dataformat.soap.name.ServiceInterfaceStrategy">
        <constructor-arg value="com.example.customerservice.CustomerService"/>
    <constructor-arg value="true"/>
    </bean>
----

And in the Camel route

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
  <from uri="direct:start"/>
  <marshal>
    <soapjaxb contentPath="com.example.customerservice" version="1.2" elementNameStrategyRef="myNameStrategy"/>
  </marshal>
  <to uri="jms:myQueue"/>
</route>
----

[[BookDataFormatAppendix-Multi-partMessages]]
Multi-part Messages
^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.8.1*

Multi-part SOAP messages are supported by the ServiceInterfaceStrategy.
The ServiceInterfaceStrategy must be initialized with a service
interface definition that is annotated in accordance with JAX-WS 2.2 and
meets the requirements of the Document Bare style. The target method
must meet the following criteria, as per the JAX-WS specification: 1) it
must have at most one `in` or `in/out` non-header parameter, 2) if it
has a return type other than `void` it must have no `in/out` or `out`
non-header parameters, 3) if it it has a return type of `void` it must
have at most one `in/out` or `out` non-header parameter.

The ServiceInterfaceStrategy should be initialized with a boolean
parameter that indicates whether the mapping strategy applies to the
request parameters or response parameters.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ServiceInterfaceStrategy strat =  new ServiceInterfaceStrategy(com.example.customerservice.multipart.MultiPartCustomerService.class, true);
SoapJaxbDataFormat soapDataFormat = new SoapJaxbDataFormat("com.example.customerservice.multipart", strat);
----

[[BookDataFormatAppendix-Multi-partRequest]]
Multi-part Request
++++++++++++++++++

The payload parameters for a multi-part request are initiazlied using a
`BeanInvocation` object that reflects the signature of the target
operation. The camel-soap DataFormat maps the content in the
`BeanInvocation` to fields in the SOAP header and body in accordance
with the JAX-WS mapping when the `marshal()` processor is invoked.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
BeanInvocation beanInvocation = new BeanInvocation();

// Identify the target method
beanInvocation.setMethod(MultiPartCustomerService.class.getMethod("getCustomersByName", 
    GetCustomersByName.class, com.example.customerservice.multipart.Product.class));

// Populate the method arguments
GetCustomersByName getCustomersByName = new GetCustomersByName();
getCustomersByName.setName("Dr. Multipart");
                
Product product = new Product();
product.setName("Multiuse Product");
product.setDescription("Useful for lots of things.");
                
Object[] args = new Object[] {getCustomersByName, product};

// Add the arguments to the bean invocation
beanInvocation.setArgs(args);

// Set the bean invocation object as the message body
exchange.getIn().setBody(beanInvocation); 
----

[[BookDataFormatAppendix-Multi-partResponse]]
Multi-part Response
+++++++++++++++++++

A multi-part soap response may include an element in the soap body and
will have one or more elements in the soap header. The camel-soap
DataFormat will unmarshall the element in the soap body (if it exists)
and place it onto the body of the out message in the exchange. Header
elements will *not* be marshaled into their JAXB mapped object types.
Instead, these elements are placed into the camel out message header
`org.apache.camel.dataformat.soap.UNMARSHALLED_HEADER_LIST`. The
elements will appear either as element instance values, or as
JAXBElement values, depending upon the setting for the
`ignoreJAXBElement` property. This property is inherited from
camel-jaxb.

You can also have the camel-soap DataFormate ignore header content
all-together by setting the `ignoreUnmarshalledHeaders` value to `true`.

[[BookDataFormatAppendix-HolderObjectmapping]]
Holder Object mapping
+++++++++++++++++++++

JAX-WS specifies the use of a type-parameterized `javax.xml.ws.Holder`
object for `In/Out` and `Out` parameters. A `Holder` object may be used
when building the `BeanInvocation`, or you may use an instance of the
parameterized-type directly. The camel-soap DataFormat marshals Holder
values in accordance with the JAXB mapping for the class of the
`Holder`'s value. No mapping is provided for `Holder` objects in an
unmarshalled response.

[[BookDataFormatAppendix-Examples.1]]
Examples
^^^^^^^^

[[BookDataFormatAppendix-Webserviceclient]]
Webservice client
+++++++++++++++++

The following route supports marshalling the request and unmarshalling a
response or fault.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
String WS_URI = "cxf://http://myserver/customerservice?serviceClass=com.example.customerservice&dataFormat=MESSAGE";
SoapJaxbDataFormat soapDF = new SoapJaxbDataFormat("com.example.customerservice", new ServiceInterfaceStrategy(CustomerService.class));
from("direct:customerServiceClient")
  .onException(Exception.class)
    .handled(true)
    .unmarshal(soapDF)
  .end()
  .marshal(soapDF)
  .to(WS_URI)
  .unmarshal(soapDF);
----

The below snippet creates a proxy for the service interface and makes a
SOAP call to the above route.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.ProxyHelper;
...

Endpoint startEndpoint = context.getEndpoint("direct:customerServiceClient");
ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
// CustomerService below is the service endpoint interface, *not* the javax.xml.ws.Service subclass
CustomerService proxy = ProxyHelper.createProxy(startEndpoint, classLoader, CustomerService.class);
GetCustomersByNameResponse response = proxy.getCustomersByName(new GetCustomersByName());
----

[[BookDataFormatAppendix-WebserviceServer]]
Webservice Server
+++++++++++++++++

Using the following route sets up a webservice server that listens on
jms queue customerServiceQueue and processes requests using the class
CustomerServiceImpl. The customerServiceImpl of course should implement
the interface CustomerService. Instead of directly instantiating the
server class it could be defined in a spring context as a regular bean.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
SoapJaxbDataFormat soapDF = new SoapJaxbDataFormat("com.example.customerservice", new ServiceInterfaceStrategy(CustomerService.class));
CustomerService serverBean = new CustomerServiceImpl();
from("jms://queue:customerServiceQueue")
  .onException(Exception.class)
    .handled(true)
    .marshal(soapDF)
  .end()
  .unmarshal(soapDF)
  .bean(serverBean)
  .marshal(soapDF);
----

[[BookDataFormatAppendix-Dependencies.13]]
Dependencies
^^^^^^^^^^^^

To use the SOAP dataformat in your camel routes you need to add the
following dependency to your pom.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-soap</artifactId>
  <version>2.3.0</version>
</dependency>
----

[[BookDataFormatAppendix-Crypto]]
Crypto
~~~~~~

*Available as of Camel 2.3* +
*PGP Available as of Camel 2.9*

The Crypto link:data-format.html[Data Format] integrates the Java
Cryptographic Extension into Camel, allowing simple and flexible
encryption and decryption of messages using Camel's familiar marshall
and unmarshal formatting mechanism. It assumes marshalling to mean
encryption to cyphertext and unmarshalling to mean decryption back to
the original plaintext. This data format implements only symmetric
(shared-key) encryption and decyption.

[[BookDataFormatAppendix-Options.5]]
Options
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Type |Default |Description
|`algorithm` |`String` |`DES/CBC/PKCS5Padding` |The JCE algorithm name
indicating the cryptographic algorithm that will be used.

|`algorithmParameterSpec` |`java.security.spec.AlgorithmParameterSpec`
|`null` |A JCE AlgorithmParameterSpec used to initialize the Cipher.

|`bufferSize` |`Integer` |`4096` |the size of the buffer used in the
signature process.

|`cryptoProvider` |`String` |`null` |The name of the JCE Security
Provider that should be used.

|`initializationVector` |`byte[]` |`null` |A byte array containing the
Initialization Vector that will be used to initialize the Cipher.

|`inline` |`boolean` |`false` |Flag indicating that the configured IV
should be inlined into the encrypted data stream.

|`macAlgorithm` |`String` |`null` |The JCE algorithm name indicating the
Message Authentication algorithm.

|`shouldAppendHMAC` |`boolean` |`null` |Flag indicating that a Message
Authentication Code should be calculated and appended to the encrypted
data.
|=======================================================================

[[BookDataFormatAppendix-BasicUsage]]
Basic Usage
^^^^^^^^^^^

At its most basic all that is required to encrypt/decrypt an exchange is
a shared secret key. If one or more instances of the Crypto data format
are configured with this key the format can be used to encrypt the
payload in one route (or part of one) and decrypted in another. For
example, using the Java DSL as
follows:\{snippet:id=basic|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/CryptoDataFormatTest.java}In
Spring the dataformat is configured first and then used in routes

xml<camelContext id="camel"
xmlns="http://camel.apache.org/schema/spring"> <dataFormats> <crypto
id="basic" algorithm="DES" keyRef="desKey" /> </dataFormats> ... <route>
<from uri="direct:basic-encryption" /> <marshal ref="basic" /> <to
uri="mock:encrypted" /> <unmarshal ref="basic" /> <to
uri="mock:unencrypted" /> </route> </camelContext>

[[BookDataFormatAppendix-SpecifyingtheEncryptionAlgorithm]]
Specifying the Encryption Algorithm
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Changing the algorithm is a matter of supplying the JCE algorithm name.
If you change the algorithm you will need to use a compatible
key.\{snippet:id=algorithm|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/CryptoDataFormatTest.java}A
list of the available algorithms in Java 7 is available via the
http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html[Java
Cryptography Architecture Standard Algorithm Name Documentation].

[[BookDataFormatAppendix-SpecifyinganInitializationVector]]
Specifying an Initialization Vector
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some crypto algorithms, particularly block algorithms, require
configuration with an initial block of data known as an Initialization
Vector. In the JCE this is passed as an AlgorithmParameterSpec when the
Cipher is initialized. To use such a vector with the CryptoDataFormat
you can configure it with a byte[] containing the required data
e.g.\{snippet:id=init-vector|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/CryptoDataFormatTest.java}or
with spring, suppling a reference to a
byte[]\{snippet:id=init-vector|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringCryptoDataFormatTest.xml}The
same vector is required in both the encryption and decryption phases. As
it is not necessary to keep the IV a secret, the DataFormat allows for
it to be inlined into the encrypted data and subsequently read out in
the decryption phase to initialize the Cipher. To inline the IV set the
/oinline
flag.\{snippet:id=inline-init-vector|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/CryptoDataFormatTest.java}or
with
spring.\{snippet:id=inline|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringCryptoDataFormatTest.xml}For
more information of the use of Initialization Vectors, consult

* http://en.wikipedia.org/wiki/Initialization_vector
* http://www.herongyang.com/Cryptography/
* http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation

[[BookDataFormatAppendix-HashedMessageAuthenticationCodes(HMAC)]]
Hashed Message Authentication Codes (HMAC)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To avoid attacks against the encrypted data while it is in transit the
CryptoDataFormat can also calculate a Message Authentication Code for
the encrypted exchange contents based on a configurable MAC algorithm.
The calculated HMAC is appended to the stream after encryption. It is
separated from the stream in the decryption phase. The MAC is
recalculated and verified against the transmitted version to insure
nothing was tampered with in transit.For more information on Message
Authentication Codes see
http://en.wikipedia.org/wiki/HMAC\{snippet:id=hmac|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/CryptoDataFormatTest.java}or
with
spring.\{snippet:id=hmac|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringCryptoDataFormatTest.xml}By
default the HMAC is calculated using the HmacSHA1 mac algorithm though
this can be easily changed by supplying a different algorithm name. See
https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=here&linkCreation=true&fromPageId=17268915[here]
for how to check what algorithms are available through the configured
security
providers\{snippet:id=hmac-algorithm|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/CryptoDataFormatTest.java}or
with
spring.\{snippet:id=hmac-algorithm|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringCryptoDataFormatTest.xml}

[[BookDataFormatAppendix-SupplyingKeysDynamically]]
Supplying Keys Dynamically
^^^^^^^^^^^^^^^^^^^^^^^^^^

When using a Recipient list or similar EIP the recipient of an exchange
can vary dynamically. Using the same key across all recipients may
neither be feasible or desirable. It would be useful to be able to
specify keys dynamically on a per exchange basis. The exchange could
then be dynamically enriched with the key of its target recipient before
being processed by the data format. To facilitate this the DataFormat
allow for keys to be supplied dynamically via the message headers below

* `CryptoDataFormat.KEY` `"CamelCryptoKey"`

\{snippet:id=key-in-header|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/CryptoDataFormatTest.java}or
with
spring.\{snippet:id=header-key|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringCryptoDataFormatTest.xml}

[[BookDataFormatAppendix-PGPMessage]]
PGP Message
^^^^^^^^^^^

The PGP Data Formater can create and decrypt/verify PGP Messages of the
following PGP packet structure (entries in brackets are optional and
ellipses indicate repetition, comma represents  sequential composition,
and vertical bar separates alternatives):

    Public Key Encrypted Session Key ..., Symmetrically Encrypted Data |
Sym. Encrypted and Integrity Protected Data, (Compressed Data,) (One
Pass Signature ...,) Literal Data, (Signature ...,)

*Since Camel 2.16*.*0* the Compressed Data packet is optional, before it
was mandatory.

 

[[BookDataFormatAppendix-PGPDataFormatOptions]]
PGPDataFormat Options
^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Type |Default |Description
|`keyUserid` |`String` |`null` |The user ID of the key in the PGP
keyring used during encryption. See also option `keyUserids`. Can also
be only a part of a user ID. For example, if the user ID is "Test User
<test@camel.com>" then you can use the part "Test User" or
"<test@camel.com>" to address the user ID.

|`keyUserids` |`List<String>` |`null` |*Since camel 2.12.2*: PGP allows
to encrypt the symmetric key by several asymmetric public receiver keys.
You can specify here the User IDs or parts of User IDs of several public
keys contained in the PGP keyring. If you just have one User ID, then
you can also use the option `keyUserid`. The User ID specified in
`keyUserid` and the User IDs in `keyUserids` will be merged together and
the corresponding public keys will be used for the encryption.

|`password` |`String` |`null` |Password used when opening the private
key (not used for encryption).

|`keyFileName` |`String` |`null` |Filename of the keyring; must be
accessible as a classpath resource (but you can specify a location in
the file system by using the "file:" prefix).

|`encryptionKeyRing` |`byte[]` |`null` |*Since camel 2.12.1*: encryption
keyring; you can not set the keyFileName and encryptionKeyRing at the
same time.

|`signatureKeyUserid` |`String` |`null` |*Since Camel 2.11.0*; optional
User ID of the key in the PGP keyring used for signing (during
encryption) or signature verification (during decryption). During the
signature verification process the specified User ID restricts the
public keys from the public keyring which can be used for the
verification. If no User ID is specified for the signature verficiation
then any public key in the public keyring can be used for the
verification. Can also be only a part of a user ID. For example, if the
user ID is "Test User <test@camel.com>" then you can use the part "Test
User" or "<test@camel.com>" to address the User ID.

|`signatureKeyUserids` |`List<String>` |`null` |*Since Camel 2.12.3*:
optional list of User IDs of the key in the PGP keyring used for signing
(during encryption) or signature verification (during decryption). You
can specify here the User IDs or parts of User IDs of several keys
contained in the PGP keyring. If you just have one User ID, then you can
also use the option `keyUserid`. The User ID specified in `keyUserid`
and the User IDs in `keyUserids` will be merged together and the
corresponding keys will be used for the signing or signature
verification. If the specified User IDs reference several keys then for
each key a signature is added to the PGP result during the
encryption-signing process. In the decryption-verifying process the list
of User IDs restricts the list of public keys which can be used for
signature verification. If the list of User IDs is empty then any public
key in the public keyring can be used for the signature verification.

|`signaturePassword` |`String` |`null` |*Since Camel 2.11.0*: optional
password used when opening the private key used for signing (during
encryption).

|`signatureKeyFileName` |`String` |`null` |*Since Camel 2.11.0*:
optional filename of the keyring to use for signing (during encryption)
or for signature verification (during decryption); must be accessible as
a classpath resource (but you can specify a location in the file system
by using the "file:" prefix).

|`signatureKeyRing` |`byte[]` |`null` |*Since camel 2.12.1*: signature
keyring; you can not set the signatureKeyFileName and signatureKeyRing
at the same time.

|`algorithm` |`int` |`SymmetricKeyAlgorithmTags.CAST5` |*Since camel
2.12.2*: symmetric key encryption algorithm; possible values are defined
in `org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags`; for example 2 (=
TRIPLE DES), 3 (= CAST5), 4 (= BLOWFISH), 6 (= DES), 7 (= AES_128). Only
relevant for encrypting.

|`compressionAlgorithm` |`int` |`CompressionAlgorithmTags.ZIP` |*Since
camel 2.12.2*: compression algorithm; possible values are defined in
`org.bouncycastle.bcpg.CompressionAlgorithmTags`; for example 0 (=
UNCOMPRESSED), 1 (= ZIP), 2 (= ZLIB), 3 (= BZIP2). Only relevant for
encrypting.

|`hashAlgorithm` |`int` |`HashAlgorithmTags.SHA1` |*Since camel 2.12.2*:
signature hash algorithm; possible values are defined in
`org.bouncycastle.bcpg.HashAlgorithmTags`; for example 2 (= SHA1), 8 (=
SHA256), 9 (= SHA384), 10 (= SHA512), 11 (=SHA224). Only relevant for
signing.

|`armored` |`boolean` |`false` |This option will cause PGP to base64
encode the encrypted text, making it available for copy/paste, etc.

|`integrity` |`boolean` |`true` |Adds an integrity check/sign into the
encryption file.

|`passphraseAccessor` |`PGPPassphraseAccessor` |`null` |*Since Camel
2.12.2*: provides passphrases corresponding to user Ids. If no
passpharase can be found from the option `password` or
`signaturePassword` and from the headers `CamelPGPDataFormatKeyPassword`
or `CamelPGPDataFormatSignatureKeyPassword` then the passphrase is
fetched from the passphrase accessor. You provide a bean which
implements the interface
https://github.com/apache/camel/blob/master/components/camel-crypto/src/main/java/org/apache/camel/converter/crypto/PGPPassphraseAccessor.java[PGPPassphraseAccessor].
A default implementation is given by
https://github.com/apache/camel/blob/master/components/camel-crypto/src/main/java/org/apache/camel/converter/crypto/DefaultPGPPassphraseAccessor.java[DefaultPGPPassphraseAccessor].
The passphrase accessor is especially useful in the decrypt case; see
chapter 'PGP Decrypting/Verifying of Messages Encrypted/Signed by
Different Private/Public Keys' below.

|`signatureVerificationOption` |`String` |`"optional"` a|
*Since Camel 2.13.0*: controls the behavior for verifying the signature
during unmarshaling. There are three values possible:

* `"optional"`: The PGP message may or may not contain signatures; if it
does contain signatures, then a signature verification is executed. Use
the constant
PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_OPTIONAL.
* `"required"`: The PGP message must contain at least one signature; if
this is not the case an exception (PGPException) is thrown. A signature
verification is executed. Use the constant
PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_REQUIRED.
* `"ignore"`: Contained signatures in the PGP message are ignored; no
signature verification is executed. Use the constant
PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_IGNORE.
* `"no_signature_allowed"`: The PGP message must not contain a
signature; otherwise an exception (PGPException) is thrown. Use the
constant
PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED.

|`FileName` |`String` |`"_CONSOLE"` a|
*Since camel 2.15.0*: Sets the file name for the literal data packet.
Can be overwritten by the  header \{@link Exchange#FILE_NAME}.

"`_CONSOLE`" indicates that the message is considered to be "for your
eyes only". This advises that the message data is unusually sensitive,
and the receiving program should process it more carefully, perhaps
avoiding storing the received data to disk, for example.Only used for
marshaling.

|`withCompressedDataPacket` |boolean |`true` |*Since Camel 2.16.0*:
Indicator whether the PGP Message shall be created with or without a
Compressed Data packet. If the value is set to false, then no Compressed
Data packet is added and the compressionAlgorithm value is ignored. Only
used for marshaling.
|=======================================================================

[[BookDataFormatAppendix-PGPDataFormatMessageHeaders]]
PGPDataFormat Message Headers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can override the PGPDataFormat options by applying below headers
into message dynamically.

 

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelPGPDataFormatKeyFileName` |`String` |*Since Camel 2.11.0*;
filename of the keyring; will override existing setting directly on the
PGPDataFormat.

|`CamelPGPDataFormatEncryptionKeyRing` |`byte[]` |*Since Camel 2.12.1*;
the encryption keyring; will override existing setting directly on the
PGPDataFormat.

|`CamelPGPDataFormatKeyUserid` |`String` |*Since Camel 2.11.0*; the User
ID of the key in the PGP keyring; will override existing setting
directly on the PGPDataFormat.

|`CamelPGPDataFormatKeyUserids` |`List<String>` |*Since camel 2.12.2*:
the User IDs of the key in the PGP keyring; will override existing
setting directly on the PGPDataFormat.

|`CamelPGPDataFormatKeyPassword` |`String` |*Since Camel 2.11.0*;
password used when opening the private key; will override existing
setting directly on the PGPDataFormat.

|`CamelPGPDataFormatSignatureKeyFileName` |`String` |*Since Camel
2.11.0*; filename of the signature keyring; will override existing
setting directly on the PGPDataFormat.

|`CamelPGPDataFormatSignatureKeyRing` |`byte[]` |*Since Camel 2.12.1*;
the signature keyring; will override existing setting directly on the
PGPDataFormat.

|`CamelPGPDataFormatSignatureKeyUserid` |`String` |*Since Camel 2.11.0*;
the User ID of the signature key in the PGP keyring; will override
existing setting directly on the PGPDataFormat.

|`CamelPGPDataFormatSignatureKeyUserids` |`List<String>` |*Since Camel
2.12.3*; the User IDs of the signature keys in the PGP keyring; will
override existing setting directly on the PGPDataFormat.

|`CamelPGPDataFormatSignatureKeyPassword` |`String` |*Since Camel
2.11.0*; password used when opening the signature private key; will
override existing setting directly on the PGPDataFormat.

|`CamelPGPDataFormatEncryptionAlgorithm` |`int` |*Since Camel 2.12.2*;
symmetric key encryption algorithm; will override existing setting
directly on the PGPDataFormat.

|`CamelPGPDataFormatSignatureHashAlgorithm` |`int` |*Since Camel
2.12.2*; signature hash algorithm; will override existing setting
directly on the PGPDataFormat.

|`CamelPGPDataFormatCompressionAlgorithm` |`int` |*Since Camel 2.12.2*;
compression algorithm; will override existing setting directly on the
PGPDataFormat.

|`CamelPGPDataFormatNumberOfEncryptionKeys` |`Integer` |*Since* *Camel
2.12.3; * number of public keys used for encrypting the symmectric key,
set by PGPDataFormat during encryptiion process

|`CamelPGPDataFormatNumberOfSigningKeys` |`Integer` |*Since* *Camel
2.12.3; * number of private keys used for creating signatures, set by
PGPDataFormat during signing process
|=======================================================================

[[BookDataFormatAppendix-EncryptingwithPGPDataFormat]]
Encrypting with PGPDataFormat
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following sample uses the popular PGP format for
encrypting/decrypting files using the
http://www.bouncycastle.org/java.html[Bouncy Castle Java
libraries]:\{snippet:id=pgp-format|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/PGPDataFormatTest.java}The
following sample performs signing + encryption, and then signature
verification + decryption. It uses the same keyring for both signing and
encryption, but you can obviously use different
keys:\{snippet:id=pgp-format-signature|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/converter/crypto/PGPDataFormatTest.java}Or
using
Spring:\{snippet:id=pgp-xml-basic|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringPGPDataFormatTest.xml}

[[BookDataFormatAppendix-Toworkwiththepreviousexampleyouneedthefollowing]]
To work with the previous example you need the following
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

* A public keyring file which contains the public keys used to encrypt
the data
* A private keyring file which contains the keys used to decrypt the
data
* The keyring password

[[BookDataFormatAppendix-Managingyourkeyring]]
Managing your keyring
+++++++++++++++++++++

To manage the keyring, I use the command line tools, I find this to be
the simplest approach in managing the keys. There are also Java
libraries available from http://www.bouncycastle.org/java.html if you
would prefer to do it that way.

1.  Install the command line utilities on linux
+
apt-get install gnupg
2.  Create your keyring, entering a secure password
+
gpg --gen-key
3.  If you need to import someone elses public key so that you can
encrypt a file for them.
+
gpg --import <filename.key
4.  The following files should now exist and can be used to run the
example
+
ls -l ~/.gnupg/pubring.gpg ~/.gnupg/secring.gpg

[[BookDataFormatAppendix-PGPDecrypting/VerifyingofMessagesEncrypted/SignedbyDifferentPrivate/PublicKeys]]
PGP Decrypting/Verifying of Messages Encrypted/Signed by Different
Private/Public Keys
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since *Camel 2.12.2*.

A PGP Data Formater can decrypt/verify messages which have been
encrypted by different public keys or signed by different private keys.
Just, provide the corresponding private keys in the secret keyring, the
corresponding public keys in the public keyring, and the passphrases in
the passphrase accessor.

javaMap<String, String> userId2Passphrase = new HashMap<String,
String>(2); // add passphrases of several private keys whose
corresponding public keys have been used to encrypt the messages
userId2Passphrase.put("UserIdOfKey1","passphrase1"); // you must specify
the exact User ID! userId2Passphrase.put("UserIdOfKey2","passphrase2");
PGPPassphraseAccessor passphraseAccessor = new
PGPPassphraseAccessorDefault(userId2Passphrase); PGPDataFormat
pgpVerifyAndDecrypt = new PGPDataFormat();
pgpVerifyAndDecrypt.setPassphraseAccessor(passphraseAccessor); // the
method getSecKeyRing() provides the secret keyring as byte array
containing the private keys
pgpVerifyAndDecrypt.setEncryptionKeyRing(getSecKeyRing()); //
alternatively you can use setKeyFileName(keyfileName) // the method
getPublicKeyRing() provides the public keyring as byte array containing
the public keys
pgpVerifyAndDecrypt.setSignatureKeyRing((getPublicKeyRing()); //
alternatively you can use setSignatureKeyFileName(signatgureKeyfileName)
// it is not necessary to specify the encryption or signer User Id
from("direct:start") ... .unmarshal(pgpVerifyAndDecrypt) // can
decrypt/verify messages encrypted/signed by different private/public
keys ...

* The functionality is especially useful to support the key exchange. If
you want to exchange the private key for decrypting you can accept for a
period of time messages which are either encrypted with the old or new
corresponding public key. Or if the sender wants to exchange his signer
private key, you can accept for a period of time, the old or new signer
key.
* Technical background: The PGP encrypted data contains a Key ID of the
public key which was used to encrypt the data. This Key ID can be used
to locate the private key in the secret keyring to decrypt the data. The
same mechanism is also used to locate the public key for verifying a
signature. Therefore you no longer must specify User IDs for the
unmarshaling.

[[BookDataFormatAppendix-RestrictingtheSignerIdentitiesduringPGPSignatureVerification]]
Restricting the Signer Identities during PGP Signature Verification
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since *Camel 2.12.3.*

If you verify a signature you not only want to verify the correctness of
the signature but you also want check that the signature comes from a
certain identity or a specific set of identities. Therefore it is
possible to restrict the number of public keys from the public keyring
which can be used for the verification of a signature.  

javaSignature User IDs// specify the User IDs of the expected signer
identities List<String> expectedSigUserIds = new ArrayList<String>();
expectedSigUserIds.add("Trusted company1");
expectedSigUserIds.add("Trusted company2");   PGPDataFormat
pgpVerifyWithSpecificKeysAndDecrypt = new PGPDataFormat();
pgpVerifyWithSpecificKeysAndDecrypt.setPassword("my password"); // for
decrypting with private key
pgpVerifyWithSpecificKeysAndDecrypt.setKeyFileName(keyfileName);
pgpVerifyWithSpecificKeysAndDecrypt.setSignatureKeyFileName(signatgureKeyfileName);
pgpVerifyWithSpecificKeysAndDecrypt.setSignatureKeyUserids(expectedSigUserIds);
// if you have only one signer identity then you can also use
setSignatureKeyUserid("expected Signer")   from("direct:start") ...
.unmarshal(pgpVerifyWithSpecificKeysAndDecrypt) ...

* If the PGP content has several signatures the verification is
successful as soon as one signature can be verified.
* If you do not want to restrict the signer identities for verification
then do not specify the signature key User IDs. In this case all public
keys in the public keyring are taken into account.

[[BookDataFormatAppendix-SeveralSignaturesinOnePGPDataFormat]]
Several Signatures in One PGP Data Format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since *Camel 2.12.3.*

The PGP specification allows that one PGP data format can contain
several signatures from different keys. Since Camel 2.13.3 it is
possible to create such kind of PGP content via specifying signature
User IDs which relate to several private keys in the secret keyring.

javaSeveral Signatures PGPDataFormat pgpSignAndEncryptSeveralSignerKeys
= new PGPDataFormat();
pgpSignAndEncryptSeveralSignerKeys.setKeyUserid(keyUserid); // for
encrypting, you can also use setKeyUserids if you want to encrypt with
several keys
pgpSignAndEncryptSeveralSignerKeys.setKeyFileName(keyfileName);
pgpSignAndEncryptSeveralSignerKeys.setSignatureKeyFileName(signatgureKeyfileName);
pgpSignAndEncryptSeveralSignerKeys.setSignaturePassword("sdude"); //
here we assume that all private keys have the same password, if this is
not the case then you can use setPassphraseAccessor List<String>
signerUserIds = new ArrayList<String>(); signerUserIds.add("company old
key"); signerUserIds.add("company new key");
pgpSignAndEncryptSeveralSignerKeys.setSignatureKeyUserids(signerUserIds);
  from("direct:start") ... .marshal(pgpSignAndEncryptSeveralSignerKeys)
...

[[BookDataFormatAppendix-SupportofSub-KeysandKeyFlagsinPGPDataFormatMarshaler]]
Support of Sub-Keys and Key Flags in PGP Data Format Marshaler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since **Camel 2.12.3. +
**An https://tools.ietf.org/html/rfc4880#section-12.1[OpenPGP V4 key]
can have a primary key and sub-keys. The usage of the keys is indicated
by the so called
https://tools.ietf.org/html/rfc4880#section-5.2.3.21[Key Flags]. For
example, you can have a primary key with two sub-keys; the primary key
shall only be used for certifying other keys (Key Flag 0x01), the first
sub-key  shall only be used for signing (Key Flag 0x02), and the second
sub-key shall only be used for encryption (Key Flag 0x04 or 0x08). The
PGP Data Format marshaler takes into account these Key Flags of the
primary key and sub-keys in order to determine the right key for signing
and encryption. This is necessary because the primary key and its
sub-keys have the same User IDs.

[[BookDataFormatAppendix-SupportofCustomKeyAccessors]]
Support of Custom Key Accessors
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since **Camel 2.13.0. +
**You can implement custom key accessors for encryption/signing. The
above PGPDataFormat class selects in a certain predefined way the keys
which should be used for signing/encryption or verifying/decryption. If
you have special requirements how your keys should be selected you
should use the
https://github.com/apache/camel/blob/master/components/camel-crypto/src/main/java/org/apache/camel/converter/crypto/PGPKeyAccessDataFormat.java[PGPKeyAccessDataFormat]
class instead and implement the interfaces
https://github.com/apache/camel/blob/master/components/camel-crypto/src/main/java/org/apache/camel/converter/crypto/PGPPublicKeyAccessor.java[PGPPublicKeyAccessor]
and
https://github.com/apache/camel/blob/master/components/camel-crypto/src/main/java/org/apache/camel/converter/crypto/PGPSecretKeyAccessor.java[PGPSecretKeyAccessor]
as beans. There are default implementations
https://github.com/apache/camel/blob/master/components/camel-crypto/src/main/java/org/apache/camel/converter/crypto/DefaultPGPPublicKeyAccessor.java[DefaultPGPPublicKeyAccessor]
and
https://github.com/apache/camel/blob/master/components/camel-crypto/src/main/java/org/apache/camel/converter/crypto/DefaultPGPSecretKeyAccessor.java[DefaultPGPSecretKeyAccessor]
which cache the keys, so that not every time the keyring is parsed when
the processor is called.

PGPKeyAccessDataFormat has the same options as PGPDataFormat except
password, keyFileName, encryptionKeyRing, signaturePassword,
signatureKeyFileName, and signatureKeyRing.

[[BookDataFormatAppendix-Dependencies.14]]
Dependencies
^^^^^^^^^^^^

To use the link:crypto.html[Crypto] dataformat in your camel routes you
need to add the following dependency to your pom.

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-crypto</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookDataFormatAppendix-SeeAlso]]
See Also
^^^^^^^^

* link:data-format.html[Data Format]
* link:crypto-digital-signatures.html[Crypto (Digital Signatures)]
* http://www.bouncycastle.org/java.html

[[BookDataFormatAppendix-SyslogDataFormat]]
Syslog DataFormat
~~~~~~~~~~~~~~~~~

*Available as of Camel 2.6*

The *syslog* dataformat is used for working with
http://www.ietf.org/rfc/rfc3164.txt[RFC3164] and RFC5424 messages.

This component supports the following:

* UDP consumption of syslog messages
* Agnostic data format using either plain String objects or
SyslogMessage model objects.
* link:type-converter.html[Type Converter] from/to SyslogMessage and
String
* Integration with the link:mina.html[camel-mina] component.
* Integration with the link:netty.html[camel-netty] component.
* *Camel 2.14:* Encoder and decoder for
the link:netty.html[camel-netty] component.
* *Camel 2.14:* Support for RFC5424 also.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-syslog</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookDataFormatAppendix-RFC3164Syslogprotocol]]
RFC3164 Syslog protocol
^^^^^^^^^^^^^^^^^^^^^^^

Syslog uses the user datagram protocol (UDP)
https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=1&linkCreation=true&fromPageId=24185759[1]
as its underlying transport layer mechanism. +
The UDP port that has been assigned to syslog is 514.

To expose a Syslog listener service we reuse the existing
link:mina.html[camel-mina] component or link:netty.html[camel-netty]
where we just use the `Rfc3164SyslogDataFormat` to marshal and unmarshal
messages. Notice that from *Camel 2.14* onwards the syslog dataformat is
renamed to `SyslogDataFormat`.

[[BookDataFormatAppendix-RFC5424Syslogprotocol]]
RFC5424 Syslog protocol
^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.14*

To expose a Syslog listener service we reuse the
existing link:mina.html[camel-mina] component
or link:netty.html[camel-netty] where we just use
the `SyslogDataFormat` to marshal and unmarshal messages

[[BookDataFormatAppendix-ExposingaSysloglistener]]
Exposing a Syslog listener
++++++++++++++++++++++++++

In our Spring XML file, we configure an endpoint to listen for udp
messages on port 10514, note that in netty we disable the defaultCodec,
this +
will allow a fallback to a NettyTypeConverter and delivers the message
as an InputStream:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="myCamel" xmlns="http://camel.apache.org/schema/spring">

    <dataFormats>
          <syslog id="mySyslog"/>
    </dataFormats>

    <route>
          <from uri="netty:udp://localhost:10514?sync=false&amp;allowDefaultCodec=false"/>
          <unmarshal ref="mySyslog"/>
          <to uri="mock:stop1"/>
    </route>

</camelContext>
----

The same route using link:mina.html[camel-mina]

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="myCamel" xmlns="http://camel.apache.org/schema/spring">

    <dataFormats>
          <syslog id="mySyslog"/>
    </dataFormats>

    <route>
          <from uri="mina:udp://localhost:10514"/>
          <unmarshal ref="mySyslog"/>
          <to uri="mock:stop1"/>
    </route>

</camelContext>
----

[[BookDataFormatAppendix-Sendingsyslogmessagestoaremotedestination]]
Sending syslog messages to a remote destination
+++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="myCamel" xmlns="http://camel.apache.org/schema/spring">

    <dataFormats>
        <syslog id="mySyslog"/>
    </dataFormats>

    <route>
        <from uri="direct:syslogMessages"/>
        <marshal ref="mySyslog"/>
        <to uri="mina:udp://remotehost:10514"/>
    </route>

</camelContext>
----

[[BookDataFormatAppendix-SeeAlso.1]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]
