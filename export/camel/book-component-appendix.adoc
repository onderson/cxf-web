[[ConfluenceContent]]
[[chapter-component-appendix]]
[[BookComponentAppendix-ComponentAppendix]]
Component Appendix
------------------

There now follows the documentation on each Camel component.

[[BookComponentAppendix-ActiveMQComponent]]
ActiveMQ Component
~~~~~~~~~~~~~~~~~~

The ActiveMQ component allows messages to be sent to a
http://java.sun.com/products/jms/[JMS] Queue or Topic or messages to be
consumed from a JMS Queue or Topic using
http://activemq.apache.org/[Apache ActiveMQ]. This component is based on
link:jms.html[JMS Component] and uses Spring's JMS support for
declarative transactions, using Spring's *`JmsTemplate`* for sending and
a *`MessageListenerContainer`* for consuming. All the options from the
link:jms.html[JMS] component also applies for this component.

To use this component make sure you have the *`activemq.jar`* or
*`activemq-core.jar`* on your classpath along with any Camel
dependencies such as *`camel-core.jar`*, *`camel-spring.jar`* and
*`camel-jms.jar`*.

Transacted and caching

See section _Transactions and Cache Levels_ below on link:jms.html[JMS]
page if you are using transactions with link:jms.html[JMS] as it can
impact performance.

[[BookComponentAppendix-URIformat]]
URI format
^^^^^^^^^^

activemq:[queue:|topic:]destinationName

Where *`destinationName`* is an ActiveMQ queue or topic name. By
default, the *`destinationName`* is interpreted as a queue name. For
example, to connect to the queue, *`FOO.BAR`*, use:

activemq:FOO.BAR

You can include the optional *`queue:`* prefix, if you prefer:

activemq:queue:FOO.BAR

To connect to a topic, you must include the *`topic:`* prefix. For
example, to connect to the topic, *`Stocks.Prices`*, use:

activemq:topic:Stocks.Prices

[[BookComponentAppendix-Options]]
Options
^^^^^^^

See Options on the link:jms.html[JMS] component as all these options
also apply for this component.

[[BookComponentAppendix-ConfiguringtheConnectionFactory]]
Configuring the Connection Factory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This
http://svn.apache.org/repos/asf/activemq/trunk/activemq-camel/src/test/java/org/apache/activemq/camel/component/ActiveMQRouteTest.java[test
case] shows how to add an *`ActiveMQComponent`* to the
link:camelcontext.html[CamelContext] using the
http://activemq.apache.org/maven/5.5.0/activemq-camel/apidocs/org/apache/activemq/camel/component/ActiveMQComponent.html#activeMQComponent%28java.lang.String%29[`activeMQComponent()`
method] while specifying the
http://activemq.apache.org/configuring-transports.html[brokerURL] used
to connect to ActiveMQ.

camelContext.addComponent("activemq",
activeMQComponent("vm://localhost?broker.persistent=false"));

[[BookComponentAppendix-ConfiguringtheConnectionFactoryusingSpringXML]]
Configuring the Connection Factory using Spring XML
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can configure the ActiveMQ broker URL on the *`ActiveMQComponent`*
as follows

xml<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://camel.apache.org/schema/spring
http://camel.apache.org/schema/spring/camel-spring.xsd"> <camelContext
xmlns="http://camel.apache.org/schema/spring"> </camelContext> <bean
id="activemq"
class="org.apache.activemq.camel.component.ActiveMQComponent"> <property
name="brokerURL" value="tcp://somehost:61616"/> </bean> </beans>

[[BookComponentAppendix-UsingConnectionPooling]]
Using Connection Pooling
^^^^^^^^^^^^^^^^^^^^^^^^

When sending to an ActiveMQ broker using Camel it's recommended to use a
pooled connection factory to efficiently handle pooling of JMS
connections, sessions and producers. This is documented on the
http://activemq.apache.org/spring-support.html[ActiveMQ Spring Support]
page.

You can grab ActiveMQ's
*`org.apache.activemq.pool.PooledConnectionFactory`* with Maven:

xml<dependency> <groupId>org.apache.activemq</groupId>
<artifactId>activemq-pool</artifactId> <version>5.6.0</version>
</dependency>

And then setup the *`activemq`* Camel component as follows:

xml<bean id="jmsConnectionFactory"
class="org.apache.activemq.ActiveMQConnectionFactory"> <property
name="brokerURL" value="tcp://localhost:61616"/> </bean> <bean
id="pooledConnectionFactory"
class="org.apache.activemq.pool.PooledConnectionFactory"
init-method="start" destroy-method="stop"> <property
name="maxConnections" value="8"/> <property name="connectionFactory"
ref="jmsConnectionFactory"/> </bean> <bean id="jmsConfig"
class="org.apache.camel.component.jms.JmsConfiguration"> <property
name="connectionFactory" ref="pooledConnectionFactory"/> <property
name="concurrentConsumers" value="10"/> </bean> <bean id="activemq"
class="org.apache.activemq.camel.component.ActiveMQComponent"> <property
name="configuration" ref="jmsConfig"/> <!-- If transacted=true then
enable CACHE_CONSUMER (if not using XA) to run faster. See more details
at: http://camel.apache.org/jms --> <!--  <property name="transacted"
value="true"/> <property name="cacheLevelName" value="CACHE_CONSUMER"/>
--> </bean>

Notice the *`init`* and *`destroy`* methods on the pooled connection
factory. This is important to ensure the connection pool is properly
started and shutdown.

Important information about when using transactions

If you are using transactions then see more details at
link:jms.html[JMS]. And remember to set *`cacheLevelName`* to
*`CACHE_CONSUMER`* if you are not using XA transactions. This can
dramatically improve performance.

The *`PooledConnectionFactory`* will then create a connection pool with
up to 8 connections in use at the same time. Each connection can be
shared by many sessions. There is an option named *`maximumActive`* you
can use to configure the maximum number of sessions per connection; the
default value is *`500`*. From *ActiveMQ 5.7*: the option has been
renamed to better reflect its purpose, being named as
*`maximumActiveSessionPerConnection`*. Notice the
*`concurrentConsumers`* is set to a higher value than *`maxConnections`*
is. This is okay, as each consumer is using a session, and as a session
can share the same connection, we are in the safe. In this example we
can have *`8 * 500 = 4000`* active sessions at the same time.

[[BookComponentAppendix-InvokingMessageListenerPOJOsinaCamelroute]]
Invoking MessageListener POJOs in a Camel route
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ActiveMQ component also provides a helper
link:type-converter.html[Type Converter] from a JMS *`MessageListener`*
to a link:processor.html[Processor]. This means that the
link:bean.html[Bean] component is capable of invoking any
JMS *`MessageListener`* bean directly inside any route.

So for example you can create a *`MessageListener`* in JMS like this:

public class MyListener implements MessageListener \{ public void
onMessage(Message jmsMessage) \{ // ... } }

Then use it in your Camel route as follows

from("file://foo/bar") .bean(MyListener.class);

That is, you can reuse any of the Camel link:components.html[Components]
and easily integrate them into your JMS *`MessageListener`* POJO!

[[BookComponentAppendix-UsingActiveMQDestinationOptions]]
Using ActiveMQ Destination Options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of ActiveMQ 5.6*

You can configure the
http://activemq.apache.org/destination-options.html[Destination Options]
in the endpoint URI, using the *`destination.`* prefix. For example to
mark a consumer as exclusive, and set its prefetch size to *`50`*, you
can do as follows:

 

<from
uri="activemq:foo?destination.consumer.exclusive=true&amp;destination.consumer.prefetchSize=50"/>

[[BookComponentAppendix-ConsumingAdvisoryMessages]]
Consuming Advisory Messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^

ActiveMQ can generate
http://activemq.apache.org/advisory-message.html[Advisory messages]
which are put in topics that you can consume. Such messages can help you
send alerts in case you detect slow consumers or to build statistics
(number of messages/produced per day, etc.) The following Spring DSL
example shows you how to read messages from a topic.

The below route starts by reading the topic
_ActiveMQ.Advisory.Connection_. To watch another topic, simply change
the name according to the name provided in ActiveMQ Advisory Messages
documentation. The parameter *`mapJmsMessage=false`* allows for
converting the *`org.apache.activemq.command.ActiveMqMessage`* object
from the JMS queue. Next, the body received is converted into a String
for the purposes of this example and a carriage return is added.
Finally, the string is added to a file

<route> <from
uri="activemq:topic:ActiveMQ.Advisory.Connection?mapJmsMessage=false"/>
<convertBodyTo type="java.lang.String"/> <transform>
<simple>$\{in.body}&#13;</simple> </transform> <to
uri="file://data/activemq/?fileExist=Append&amp;fileName=advisoryConnection-$\{date:now:yyyyMMdd}.txt"/>
</route>

If you consume a message on a queue, you should see the following files
under the *`data/activemq`* folder :

*`advisoryConnection-20100312.txt`* +
*`advisoryProducer-20100312.txt`*

containing the following string:

ActiveMQMessage \{ commandId = 0, responseRequired = false, messageId =
ID:dell-charles-3258-1268399815140-1:0:0:0:221, originalDestination =
null, originalTransactionId = null, producerId =
ID:dell-charles-3258-1268399815140-1:0:0:0, destination =
topic://ActiveMQ.Advisory.Connection, transactionId = null, expiration =
0, timestamp = 0, arrival = 0, brokerInTime = 1268403383468,
brokerOutTime = 1268403383468, correlationId = null, replyTo = null,
persistent = false, type = Advisory, priority = 0, groupID = null,
groupSequence = 0, targetConsumerId = null, compressed = false, userID =
null, content = null, marshalledProperties =
org.apache.activemq.util.ByteSequence@17e2705, dataStructure =
ConnectionInfo \{ commandId = 1, responseRequired = true, connectionId =
ID:dell-charles-3258-1268399815140-2:50, clientId =
ID:dell-charles-3258-1268399815140-14:0, userName = , password = *****,
brokerPath = null, brokerMasterConnector = false, manageable = true,
clientMaster = true }, redeliveryCounter = 0, size = 0, properties = \{
originBrokerName=master,
originBrokerId=ID:dell-charles-3258-1268399815140-0:0,
originBrokerURL=vm://master }, readOnlyProperties = true, readOnlyBody =
true, droppable = false }

[[BookComponentAppendix-GettingComponentJAR]]
Getting Component JAR
^^^^^^^^^^^^^^^^^^^^^

You will need this dependency

* *`activemq-camel`*

link:activemq.html[ActiveMQ] is an extension of the link:jms.html[JMS]
component released with the http://activemq.apache.org[ActiveMQ
project].

<dependency> <groupId>org.apache.activemq</groupId>
<artifactId>activemq-camel</artifactId> <version>5.6.0</version>
</dependency>

link:endpoint-see-also.html[Endpoint See Also]

Unable to render \{include} The included page could not be found.

[[BookComponentAppendix-AMQP]]
AMQP
~~~~

The *amqp:* component supports the http://www.amqp.org/[AMQP 1.0
protocol] using the JMS Client API of the
https://github.com/apache/qpid-jms/[Qpid] project. In case you want to
use *AMQP 0.9* (in particular RabbitMQ) you might also be interested in
the link:rabbitmq.html[Camel RabbitMQ] component. Please keep in mind
that prior to the *Camel 2.17.0* AMQP component supported *AMQP 0.9* and
above, however since *Camel 2.17.0* it supports only *AMQP 1.0*.

Maven users will need to add the following dependency to their
*`pom.xml`* for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-amqp</artifactId>
    <version>${camel.version}</version> <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.1]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
amqp:[queue:|topic:]destinationName[?options]
----

[[BookComponentAppendix-AMQPOptions]]
AMQP Options
^^^^^^^^^^^^

You can specify all of the various configuration options of the
link:jms.html[JMS] component after the destination name.

[[BookComponentAppendix-Usage]]
Usage
^^^^^

As AMQP component inherits from the JMS component. The usage of the
former is almost identical to the latter:

*Using AMQP component*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Consuming from AMQP queue
from("amqp:queue:incoming")
  .to(...);
 
// Sending message to the AMQP topic
from(...)
  .to("amqp:topic:notify");
----

[[BookComponentAppendix-ConfiguringAMQPcomponent]]
Configuring AMQP component
^^^^^^^^^^^^^^^^^^^^^^^^^^

Starting from the *Camel 2.16.1* you can also use the
*`AMQPComponent#amqp10Component(String connectionURI)`* factory method
to return the *AMQP 1.0* component with the pre-configured topic
prefix: 

*Creating AMQP 1.0 component*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
 AMQPComponent amqp = AMQPComponent.amqp10Component("amqp://guest:guest@localhost:5672");
----

Keep in mind that starting from the
*Camel 2.17* the *`AMQPComponent#amqp10Component(String connectionURI)`* factory
method has been deprecated on the behalf of the
*`AMQPComponent#amqpComponent(String connectionURI)`*: 

*Creating AMQP 1.0 component*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
AMQPComponent amqp = AMQPComponent.amqpComponent("amqp://localhost:5672");
 
AMQPComponent authorizedAmqp = AMQPComponent.amqpComponent("amqp://localhost:5672", "user", "password");
----

Starting from *Camel 2.17*, in order to automatically configure the AMQP
component, you can also add an instance
of *`org.apache.camel.component.amqp.AMQPConnectionDetails`* to the
registry. For example for Spring Boot you just have to define bean:

*AMQP connection details auto-configuration*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Bean
AMQPConnectionDetails amqpConnection() {
  return new AMQPConnectionDetails("amqp://lcoalhost:5672"); 
}
 
@Bean
AMQPConnectionDetails securedAmqpConnection() {
  return new AMQPConnectionDetails("amqp://lcoalhost:5672", "username", "password"); 
}
----

 

You can also rely on the link:properties.html[Camel properties] to read
the AMQP connection details. The factory
method *`AMQPConnectionDetails.discoverAMQP()`* attempts to read Camel
properties in a Kubernetes-like convention, just as demonstrated on the
snippet below:

 

*AMQP connection details auto-configuration*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
export AMQP_SERVICE_HOST = "mybroker.com"
export AMQP_SERVICE_PORT = "6666"
export AMQP_SERVICE_USERNAME = "username"
export AMQP_SERVICE_PASSWORD = "password"
 
...
 
@Bean
AMQPConnectionDetails amqpConnection() {
  return AMQPConnectionDetails.discoverAMQP(); 
}
----

[[BookComponentAppendix-ConfiguringConnectionFactory]]
Configuring Connection Factory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Like with any other JMS-based component, usually it's important to
configure JMS connection factory. For example, you'd like to set your
broker URL or set proper connection credentials. Additionally, you would
always want to set some kind of pooling (or caching) on the connection
factory. An example of how to do both of these tasks is shown below.

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<bean id="jmsConnectionFactory" class="org.apache.qpid.jms.JmsConnectionFactory">
  <property name="remoteURI" value="amqp://localhost:5672" />
  <property name="username" value="admin"/>
  <property name="password" value="admin"/>
</bean>

<bean id="jmsCachingConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory">
  <property name="targetConnectionFactory" ref="jmsConnectionFactory" />
</bean>

<bean id="jmsConfig" class="org.apache.camel.component.jms.JmsConfiguration" >
  <property name="connectionFactory" ref="jmsCachingConnectionFactory" /> 
  <property name="cacheLevelName" value="CACHE_CONSUMER" />
</bean>    

<bean id="amqp" class="org.apache.camel.component.amqp.AMQPComponent">
    <property name="configuration" ref="jmsConfig" />
</bean>    

<camelContext xmlns="http://camel.apache.org/schema/blueprint" id="simple">
  <route>
    <from uri="timer:simple?period=5000"/>
    <setBody>
        <simple>Hello World</simple>
    </setBody>
    <to uri="amqp:test"/>
  </route>
</camelContext>
----

[[BookComponentAppendix-UsingamqpinsideKaraf]]
Using amqp inside Karaf
^^^^^^^^^^^^^^^^^^^^^^^

To use the *`amqp`* component inside Karaf use the predefined feature
called *`camel-amqp`* to install the necessary bundles.

Example:

[source,brush:,text;,gutter:,false;,theme:,Default]
----
karaf@root()> repo-add camel
karaf@root()> feature:install camel-amqp
----

and the environment would be set.

Use the *`camel-blueprint`* or *`camel-spring`* features to define
routes in those contexts.

 

[[BookComponentAppendix-SeeAlso]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

 

[[BookComponentAppendix-SQSComponent]]
SQS Component
~~~~~~~~~~~~~

*Available as of Camel 2.6*

The sqs component supports sending and receiving messages to
http://aws.amazon.com/sqs[Amazon's SQS] service.

[Info]
====
 **Prerequisites**

You must have a valid Amazon Web Services developer account, and be
signed up to use Amazon SQS. More information are available at
http://aws.amazon.com/sqs[Amazon SQS].

====

[[BookComponentAppendix-URIFormat]]
URI Format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
aws-sqs://queueName[?options]
aws-sqs://queueNameOrArn[?options] (from Camel 2.18)
----

The queue will be created if they don't already exists. You can append
query options to the URI in the following format:
*`?options=value&option2=value&...`*

[[BookComponentAppendix-URIOptions]]
URI Options
^^^^^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Default Value |Context |Description
|`accessKey` |`null` |`Shared` |Amazon AWS Access Key.

|`amazonSQSClient` |`null` |`Shared` |Reference to a
*`com.amazonaws.services.sqs.AmazonSQS`* in the
link:registry.html[Registry].

|`amazonSQSEndpoint` |`null` |`Shared` |The region with which
the *`aws-sqs`* client wants to work with. Only works if Camel creates
the *`aws-sqs`* client, i.e., if you explicitly set *`amazonSQSClient`*,
then this setting will have no effect. You would have to set it on the
client you create directly

|`attributeNames` |`null` |`Consumer` a|
A list of attribute names to receive when consuming.

*Camel 2.17:* Multiple names can be separated by comma.

*Camel 2.16* or older: The type is a Collection so its much harder to
configure and use.

|`concurrentConsumers` |`1` |`Consumer` |(*as of 2.15.0*) Allows you to
use multiple threads to poll the SQS queue to increase throughput. You
must also set the *`maxMessagesPerPoll`* option for this to work
properly.

|`defaultVisibilityTimeout` |`null` |`Shared` |The visibility timeout
(in seconds) to set in the
*`com.amazonaws.services.sqs.model.CreateQueueRequest`*.

|`delaySeconds` |`null` |`Producer` |*Camel 2.9.3:* Delay sending
messages for a number of seconds.

|`deleteAfterRead` |`true` |`Consumer` a|
Delete message from SQS after it has been read (and processed by the
route).

If this option is false, then the same objects will be retrieve over and
over again on the polls. Therefore you need to use the
link:idempotent-consumer.html[Idempotent Consumer EIP] in the route to
filter out duplicates. You can filter using
the *`S3Constants#BUCKET_NAME`* and *`S3Constants#KEY`* headers, or only
the *`S3Constants#KEY`* header.

|`deleteIfFiltered` |`true` |`Consumer` a|
*Camel 2.12.2, 2.13.0*: Whether or not to send the *`DeleteMessage`* to
the SQS queue if an exchange fails to get through a filter.

If *`false`* and exchange does not make it through a Camel filter
upstream in the route, then don't send *`DeleteMessage`*.

|`extendMessageVisibility` |`false` |`Consumer` a|
*Camel 2.10:* If enabled a scheduled background task will keep extending
the message visibility on SQS. This is needed if it takes a long time to
process the message. If set to true**` visibilityTimeout`** must be set.

See details at
http://docs.amazonwebservices.com/AWSSimpleQueueService/latest/APIReference/Query_QueryChangeMessageVisibility.html[Amazon
docs].

|`maximumMessageSize` |`null` |`Shared` |*Camel 2.8:*
The *`maximumMessageSize`* (in bytes) an SQS message can contain for
this queue, to set in the
*`com.amazonaws.services.sqs.model.SetQueueAttributesRequest`*.

|`maxMessagesPerPoll` |`null` |`Consumer` |The maximum number of
messages which can be received in one poll to set in the
*`com.amazonaws.services.sqs.model.ReceiveMessageRequest`*.

|`messageAttributeNames` |`null` |`Consumer` a|
A list of message attribute names to receive when consuming.

**Camel 2.17:** Multiple names can be separated by comma.  

*Camel 2.16* or older: The type is a Collection so its much harder to
configure and use.

|`messageRetentionPeriod` |`null` |`Shared` |*Camel 2.8:*
The *`messageRetentionPeriod`* (in seconds) a message will be retained
by SQS for this queue, to set in the
*`com.amazonaws.services.sqs.model.SetQueueAttributesRequest`*.

|`proxyHost` |`null` |`Shared` |*Camel 2.16*: Specify a proxy host to be
used inside the client definition.

|`proxyPort` |`null` |`Shared` |*Camel 2.16*: Specify a proxy port to be
used inside the client definition.

|`queueOwnerAWSAccountId` |`null` |`Shared` |*Camel 2.12:* Specify the
queue owner aws account id when you need to connect the queue with
different account owner.

|`policy` |`null` |`Shared` |*Camel 2.8:* The policy for this queue to
set in the
*`com.amazonaws.services.sqs.model.SetQueueAttributesRequest`*.

|`receiveMessageWaitTimeSeconds` |`0` |`Shared` |*Camel 2.11:* If you do
not specify *`WaitTimeSeconds`* in the request, the queue
attribute *`ReceiveMessageWaitTimeSeconds`* is used to determine how
long to wait.

|`redrivePolicy` |`null` |`Shared` |*Camel 2.15*: Specify the policy
that send message to *`DeadLetter`* queue. See detail at
http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-queues-redrivepolicy.html[Amazon
docs].

|`region` |`null` |`Shared` |*Camel 2.12.3:* Specify the queue region
which could be used with *`queueOwnerAWSAccountId`* to build the service
URL. +
*Note*: Region will still default to *`us-east-1`* if
 *`queueOwnerAWSAccountId`* is not specified

|`secretKey` |`null` |`Shared` |Amazon AWS Secret Key.

|`waitTimeSeconds` |`0` |`Producer` |*Camel 2.11:* Duration in seconds
(0 to 20) that the *`ReceiveMessage`* action call will wait until a
message is in the queue to include in the response.

|`visibilityTimeout` |`null` |`Shared` |The duration (in seconds) that
the received messages are hidden from subsequent retrieve requests after
being retrieved by a *`ReceiveMessage`* request. This only make sense if
its different from *`defaultVisibilityTimeout`*.
|=======================================================================

[Info]
====
 **Required SQS component options**

You have to provide the *`amazonSQSClient`* in the
link:registry.html[Registry] or your *`accessKey`* and *`secretKey`* to
access the http://aws.amazon.com/sqs[Amazon's SQS].

====

[[BookComponentAppendix-BatchConsumer]]
Batch Consumer
^^^^^^^^^^^^^^

This component implements the link:batch-consumer.html[Batch Consumer].

This allows you for instance to know how many messages exists in this
batch and for instance let the link:aggregator.html[Aggregator]
aggregate this number of messages.

[[BookComponentAppendix-Usage.1]]
Usage
^^^^^

[[BookComponentAppendix-MessageheaderssetbytheSQSproducer]]
Message headers set by the SQS producer
+++++++++++++++++++++++++++++++++++++++

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelAwsSqsMD5OfBody` |`String` |The MD5 checksum of the Amazon SQS
message.

|`CamelAwsSqsMessageId` |`String` |The Amazon SQS message ID.

|`CamelAwsSqsDelaySeconds` |`Integer` |Since *Camel 2.11*, the delay
seconds that the Amazon SQS message can be see by others.
|=======================================================================

[[BookComponentAppendix-MessageheaderssetbytheSQSconsumer]]
Message headers set by the SQS consumer
+++++++++++++++++++++++++++++++++++++++

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelAwsSqsMD5OfBody` |`String` |The MD5 checksum of the Amazon SQS
message.

|`CamelAwsSqsMessageId` |`String` |The Amazon SQS message ID.

|`CamelAwsSqsReceiptHandle` |`String` |The Amazon SQS message receipt
handle.

|`CamelAwsSqsAttributes` |`Map<String, String>` |The Amazon SQS message
attributes.
|=======================================================================

[[BookComponentAppendix-AdvancedAmazonSQSconfiguration]]
Advanced AmazonSQS configuration
++++++++++++++++++++++++++++++++

If your Camel Application is running behind a firewall or if you need to
have more control over the AmazonSQS instance configuration, you can
create your own instance:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
AWSCredentials awsCredentials = new BasicAWSCredentials("myAccessKey", "mySecretKey");

ClientConfiguration clientConfiguration = new ClientConfiguration();
clientConfiguration.setProxyHost("http://myProxyHost");
clientConfiguration.setProxyPort(8080);

AmazonSQS client = new AmazonSQSClient(awsCredentials, clientConfiguration);

registry.bind("client", client);
----

and refer to it in your Camel aws-sqs component configuration:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("aws-sqs://MyQueue?amazonSQSClient=#client&delay=5000&maxMessagesPerPoll=5")
  .to("mock:result");
----

[[BookComponentAppendix-Dependencies]]
Dependencies
^^^^^^^^^^^^

Maven users will need to add the following dependency to their
*`pom.xml`*.

*pom.xml*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-aws</artifactId>
    <version>${camel-version}</version>
</dependency>
----

where *`${camel-version`}* must be replaced by the actual version of
Camel (2.6 or higher).

[[BookComponentAppendix-JMS-styleSelectors]]
JMS-style Selectors
^^^^^^^^^^^^^^^^^^^

SQS does not allow selectors, but you can effectively achieve this by
using the link:message-filter.html[Camel Filter EIP] and setting an
appropriate *`visibilityTimeout`*. When SQS dispatches a message, it
will wait up to the visibility timeout before it will try to dispatch
the message to a different consumer unless a *`DeleteMessage`* is
received. By default, Camel will always send the *`DeleteMessage`* at
the end of the route, unless the route ended in failure. To achieve
appropriate filtering and not send the *`DeleteMessage`* even on
successful completion of the route, use a Filter:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("aws-sqs://MyQueue?amazonSQSClient=#client&defaultVisibilityTimeout=5000&deleteIfFiltered=false")
  .filter("${header.login} == true")
  .to("mock:result");
----

In the above code, if an exchange doesn't have an appropriate header, it
will not make it through the filter AND also not be deleted from the SQS
queue. After `5000` miliseconds, the message will become visible to
other consumers.

[[BookComponentAppendix-SeeAlso.1]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:aws.html[AWS Component]

[[BookComponentAppendix-AtomComponent]]
Atom Component
~~~~~~~~~~~~~~

The *atom:* component is used for polling Atom feeds.

Camel will poll the feed every 60 seconds by default. +
*Note:* The component currently only supports polling (consuming) feeds.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-atom</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.2]]
URI format
^^^^^^^^^^

atom://atomUri[?options]

Where *atomUri* is the URI to the Atom feed to poll.

[[BookComponentAppendix-Options.1]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Property |Default |Description
|`splitEntries` |`true` |If `true` Camel will poll the feed and for the
subsequent polls return each entry poll by poll. If the feed contains 7
entries then Camel will return the first entry on the first poll, the
2nd entry on the next poll, until no more entries where as Camel will do
a new update on the feed. If `false` then Camel will poll a fresh feed
on every invocation.

|`filter` |`true` |Is only used by the split entries to filter the
entries to return. Camel will default use the `UpdateDateFilter` that
only return new entries from the feed. So the client consuming from the
feed never receives the same entry more than once. The filter will
return the entries ordered by the newest last.

|`lastUpdate` |`null` |Is only used by the filter, as the starting
timestamp for selection never entries (uses the `entry.updated`
timestamp). Syntax format is: `yyyy-MM-ddTHH:MM:ss`. Example:
`2007-12-24T17:45:59`.

|`throttleEntries` |`true` |*Camel 2.5:* Sets whether all entries
identified in a single feed poll should be delivered immediately. If
`true`, only one entry is processed per `consumer.delay`. Only
applicable when `splitEntries` is set to `true`.

|`feedHeader` |`true` |Sets whether to add the Abdera Feed object as a
header.

|`sortEntries` |`false` |If `splitEntries` is `true`, this sets whether
to sort those entries by updated date.

|`consumer.delay` |`500` |Delay in millis between each poll.

|`consumer.initialDelay` |`1000` |Millis before polling starts.

|`consumer.userFixedDelay` |`false` |If `true`, use fixed delay between
pools, otherwise fixed rate is used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.

|`username` |  |*Camel 2.16:* For basic authentication when polling from
a HTTP feed

|`password` |  |**Camel 2.16:** For basic authentication when polling
from a HTTP feed
|=======================================================================

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Exchangedataformat]]
Exchange data format
^^^^^^^^^^^^^^^^^^^^

Camel will set the In body on the returned `Exchange` with the entries.
Depending on the `splitEntries` flag Camel will either return one
`Entry` or a `List<Entry>`.

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Value |Behavior
|`splitEntries` |`true` |Only a single entry from the currently being
processed feed is set: `exchange.in.body(Entry)`

|`splitEntries` |`false` |The entire list of entries from the feed is
set: `exchange.in.body(List<Entry>)`
|=======================================================================

Camel can set the `Feed` object on the In header (see `feedHeader`
option to disable this):

[[BookComponentAppendix-MessageHeaders]]
Message Headers
^^^^^^^^^^^^^^^

Camel atom uses these headers.

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelAtomFeed` |When consuming the `org.apache.abdera.model.Feed`
object is set to this header.
|=======================================================================

[[BookComponentAppendix-Samples]]
Samples
^^^^^^^

In this sample we poll James Strachan's blog.

from("atom://http://macstrac.blogspot.com/feeds/posts/default").to("seda:feeds");

In this sample we want to filter only good blogs we like to a SEDA
queue. The sample also shows how to setup Camel standalone, not running
in any Container or using
Spring.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-atom/src/test/java/org/apache/camel/component/atom/AtomGoodBlogsTest.java}link:endpoint-see-also.html[Endpoint
See Also]

* link:rss.html[RSS]

[[BookComponentAppendix-BeanComponent]]
Bean Component
~~~~~~~~~~~~~~

The *bean:* component binds beans to Camel message exchanges.

[[BookComponentAppendix-URIformat.3]]
URI format
^^^^^^^^^^

bean:beanID[?options]

Where *beanID* can be any string which is used to look up the bean in
the link:registry.html[Registry]

[[BookComponentAppendix-Options.2]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Type |Default |Description
|`method` |`String` |`null` |The method name from the bean that will be
invoked. If not provided, Camel will try to determine the method itself.
In case of ambiguity an exception will be thrown. See
link:bean-binding.html[Bean Binding] for more details. From *Camel 2.8*
onwards you can specify type qualifiers to pin-point the exact method to
use for overloaded methods. From *Camel 2.9* onwards you can specify
parameter values directly in the method syntax. See more details at
link:bean-binding.html[Bean Binding].

|`cache` |`boolean` |`false` |If enabled, Camel will cache the result of
the first link:registry.html[Registry] look-up. Cache can be enabled if
the bean in the link:registry.html[Registry] is defined as a singleton
scope.

|`multiParameterArray` |`boolean` |`false` |How to treat the parameters
which are passed from the message body; if it is `true`, the In message
body should be an array of parameters.

|bean.xxx |  |null |*Camel 2.17:* To configure additional options on the
create bean instance from the class name. For example to configure a foo
option on the bean, use bean.foo=123.
|=======================================================================

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Using]]
Using
^^^^^

The object instance that is used to consume messages must be explicitly
registered with the link:registry.html[Registry]. For example, if you
are using Spring you must define the bean in the Spring configuration,
`spring.xml`; or if you don't use Spring, by registering the bean in
JNDI.\{snippet:id=register|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/pojo/PojoRouteTest.java}Once
an endpoint has been registered, you can build Camel routes that use it
to process
exchanges.\{snippet:id=route|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/pojo/PojoRouteTest.java}A
*bean:* endpoint cannot be defined as the input to the route; i.e. you
cannot consume from it, you can only route from some inbound message
link:endpoint.html[Endpoint] to the bean endpoint as output. So consider
using a *direct:* or *queue:* endpoint as the input.

You can use the `createProxy()` methods on
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/bean/ProxyHelper.html[ProxyHelper]
to create a proxy that will generate BeanExchanges and send them to any
endpoint:\{snippet:id=invoke|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/pojo/PojoRouteTest.java}And
the same route using Spring DSL:

xml<route> <from uri="direct:hello"> <to uri="bean:bye"/> </route>

[[BookComponentAppendix-Beanasendpoint]]
Bean as endpoint
^^^^^^^^^^^^^^^^

Camel also supports invoking link:bean.html[Bean] as an Endpoint. In the
route
below:\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/spring/bind/beanAsEndpoint.xml}What
happens is that when the exchange is routed to the `myBean` Camel will
use the link:bean-binding.html[Bean Binding] to invoke the bean. +
The source for the bean is just a plain
POJO:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-spring/src/test/java/org/apache/camel/spring/bind/ExampleBean.java}Camel
will use link:bean-binding.html[Bean Binding] to invoke the `sayHello`
method, by converting the Exchange's In body to the `String` type and
storing the output of the method on the Exchange Out body.

[[BookComponentAppendix-JavaDSLbeansyntax]]
Java DSL bean syntax
^^^^^^^^^^^^^^^^^^^^

Java DSL comes with syntactic sugar for the link:bean.html[Bean]
component. Instead of specifying the bean explicitly as the endpoint
(i.e. `to("bean:beanName")`) you can use the following syntax:

java// Send message to the bean endpoint // and invoke method resolved
using Bean Binding. from("direct:start").beanRef("beanName"); // Send
message to the bean endpoint // and invoke given method.
from("direct:start").beanRef("beanName", "methodName");

Instead of passing name of the reference to the bean (so that Camel will
lookup for it in the registry), you can specify the bean itself:

java// Send message to the given bean instance.
from("direct:start").bean(new ExampleBean()); // Explicit selection of
bean method to be invoked. from("direct:start").bean(new ExampleBean(),
"methodName"); // Camel will create the instance of bean and cache it
for you. from("direct:start").bean(ExampleBean.class);

[[BookComponentAppendix-BeanBinding]]
Bean Binding
^^^^^^^^^^^^

How bean methods to be invoked are chosen (if they are not specified
explicitly through the *method* parameter) and how parameter values are
constructed from the link:message.html[Message] are all defined by the
link:bean-binding.html[Bean Binding] mechanism which is used throughout
all of the various link:bean-integration.html[Bean Integration]
mechanisms in Camel.

link:endpoint-see-also.html[Endpoint See Also]

* link:class.html[Class] component
* link:bean-binding.html[Bean Binding]
* link:bean-integration.html[Bean Integration]

Unable to render \{include} The included page could not be found.

[[BookComponentAppendix-BrowseComponent]]
Browse Component
~~~~~~~~~~~~~~~~

The Browse component provides a simple
link:browsableendpoint.html[BrowsableEndpoint] which can be useful for
testing, visualisation tools or debugging. The exchanges sent to the
endpoint are all available to be browsed.

[[BookComponentAppendix-URIformat.4]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
browse:someName[?options]
----

Where *someName* can be any string to uniquely identify the endpoint.

[[BookComponentAppendix-Sample]]
Sample
^^^^^^

In the route below, we insert a `browse:` component to be able to browse
the Exchanges that are passing through:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  from("activemq:order.in").to("browse:orderReceived").to("bean:processOrder");
----

We can now inspect the received exchanges from within the Java code:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    private CamelContext context;

    public void inspectRecievedOrders() {
        BrowsableEndpoint browse = context.getEndpoint("browse:orderReceived", BrowsableEndpoint.class);
        List<Exchange> exchanges = browse.getExchanges();
        ...
        // then we can inspect the list of received exchanges from Java
        for (Exchange exchange : exchanges) {
            String payload = exchange.getIn().getBody();
            ...
        }
   }
----

[[BookComponentAppendix-SeeAlso.2]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-CacheComponent]]
Cache Component
~~~~~~~~~~~~~~~

[Warning]
====


This component is deprecated. As of Camel 2.18.0 You should use
link:ehcache.html[Ehcache].

====

*Available as of Camel 2.1*

The *cache* component enables you to perform caching operations using
EHCache as the Cache Implementation. The cache itself is created on
demand or if a cache of that name already exists then it is simply
utilized with its original settings.

This component supports producer and event based consumer endpoints.

The Cache consumer is an event based consumer and can be used to listen
and respond to specific cache activities. If you need to perform
selections from a pre-existing cache, use the processors defined for the
cache component.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-cache</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.5]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
cache://cacheName[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=#beanRef&...`

[[BookComponentAppendix-Options.3]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`maxElementsInMemory` |`1000` |The number of elements that may be
stored in the defined cache

|`memoryStoreEvictionPolicy` |`MemoryStoreEvictionPolicy.LFU` a|
The number of elements that may be stored in the defined cache. Options
include

* MemoryStoreEvictionPolicy.LFU - Least frequently used
* MemoryStoreEvictionPolicy.LRU - Least recently used
* MemoryStoreEvictionPolicy.FIFO - first in first out, the oldest
element by creation time

|`overflowToDisk` |`true` |Specifies whether cache may overflow to disk

|`eternal` |`false` |Sets whether elements are eternal. If eternal,
timeouts are ignored and the +
element never expires.

|`timeToLiveSeconds` |`300` |The maximum time between creation time and
when an element expires. +
Is used only if the element is not eternal

|`timeToIdleSeconds` |`300` |The maximum amount of time between accesses
before an element expires

|`diskPersistent` |`false` |Whether the disk store persists between
restarts of the Virtual Machine.

|`diskExpiryThreadIntervalSeconds` |`120` |The number of seconds between
runs of the disk expiry thread.

|`cacheManagerFactory` |`null` |*Camel 2.8:* If you want to use a custom
factory which instantiates and creates the EHCache
`net.sf.ehcache.CacheManager`. +
 +
_Type:_ abstract org.apache.camel.component.cache.CacheManagerFactory

|`eventListenerRegistry` |`null` |*Camel 2.8:* Sets a list of EHCache
`net.sf.ehcache.event.CacheEventListener` for all new caches- no need to
define it per cache in EHCache xml config anymore. +
 +
_Type:_ org.apache.camel.component.cache.CacheEventListenerRegistry

|`cacheLoaderRegistry` |`null` |*Camel 2.8:* Sets a list of
`org.apache.camel.component.cache.CacheLoaderWrapper` that extends
EHCache `net.sf.ehcache.loader.CacheLoader` for all new caches- no need
to define it per cache in EHCache xml config anymore. +
 +
_Type:_ org.apache.camel.component.cache.CacheLoaderRegistry

|`key` |`null` |*Camel 2.10:* To configure using a cache key by default.
If a key is provided in the message header, then the key from the header
takes precedence.

|`operation` |`null` |*Camel 2.10:* To configure using an cache
operation by default. If an operation in the message header, then the
operation from the header takes precedence.

|objectCache |false |*Camel 2.15:* Whether to turn on allowing to store
non serializable objects in the cache. If this option is enabled then
overflow to disk cannot be enabled as well.
|=======================================================================

[[BookComponentAppendix-CacheComponentoptions]]
Cache Component options
^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`configuration` |  |To use a custom
`org.apache.camel.component.cache.CacheConfiguration` configuration.

|`cacheManagerFactory` |  |To use a custom
`org.apache.camel.component.cache.CacheManagerFactory`.

|`configurationFile` |  |*Camel 2.13/2.12.3:* To configure the location
of the `ehcache.xml` file to use, such as
`classpath:com/foo/mycache.xml` to load from classpath. If no
configuration is given, then the default settings from EHCache is used.
|=======================================================================

[[BookComponentAppendix-Sending/ReceivingMessagesto/fromthecache]]
Sending/Receiving Messages to/from the cache
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-MessageHeadersuptoCamel2.7]]
Message Headers up to Camel 2.7
+++++++++++++++++++++++++++++++

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CACHE_OPERATION` a|
The operation to be performed on the cache. Valid options are

* GET
* CHECK
* ADD
* UPDATE
* DELETE
* DELETEALL +
`GET` and `CHECK` requires *Camel 2.3* onwards.

|`CACHE_KEY` |The cache key used to store the Message in the cache. The
cache key is optional if the CACHE_OPERATION is DELETEALL
|=======================================================================

[[BookComponentAppendix-MessageHeadersCamel2.8+]]
Message Headers Camel 2.8+
++++++++++++++++++++++++++

[Info]
====
 **Header changes in Camel 2.8**

The header names and supported values have changed to be prefixed with
'CamelCache' and use mixed case. This makes them easier to identify and
keep separate from other headers. The CacheConstants variable names
remain unchanged, just their values have been changed. Also, these
headers are now removed from the exchange after the cache operation is
performed.

====

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelCacheOperation` a|
The operation to be performed on the cache. The valid options are

* CamelCacheGet
* CamelCacheCheck
* CamelCacheAdd
* CamelCacheUpdate
* CamelCacheDelete
* CamelCacheDeleteAll

|`CamelCacheKey` |The cache key used to store the Message in the cache.
The cache key is optional if the CamelCacheOperation is
CamelCacheDeleteAll
|=======================================================================

The `CamelCacheAdd` and `CamelCacheUpdate` operations support additional
headers:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelCacheTimeToLive` |`Integer` |*Camel 2.11:* Time to live in
seconds.

|`CamelCacheTimeToIdle` |`Integer` |*Camel 2.11:* Time to idle in
seconds.

|`CamelCacheEternal` |`Boolean` |*Camel 2.11:* Whether the content is
eternal.
|=======================================================================

[[BookComponentAppendix-CacheProducer]]
Cache Producer
++++++++++++++

Sending data to the cache involves the ability to direct payloads in
exchanges to be stored in a pre-existing or created-on-demand cache. The
mechanics of doing this involve

* setting the Message Exchange Headers shown above.
* ensuring that the Message Exchange Body contains the message directed
to the cache

[[BookComponentAppendix-CacheConsumer]]
Cache Consumer
++++++++++++++

Receiving data from the cache involves the ability of the CacheConsumer
to listen on a pre-existing or created-on-demand Cache using an event
Listener and receive automatic notifications when any cache activity
take place (i.e
CamelCacheGet/CamelCacheUpdate/CamelCacheDelete/CamelCacheDeleteAll).
Upon such an activity taking place

* an exchange containing Message Exchange Headers and a Message Exchange
Body containing the just added/updated payload is placed and sent.
* in case of a CamelCacheDeleteAll operation, the Message Exchange
Header CamelCacheKey and the Message Exchange Body are not populated.

[[BookComponentAppendix-CacheProcessors]]
Cache Processors
++++++++++++++++

There are a set of nice processors with the ability to perform cache
lookups and selectively replace payload content at the

* body
* token
* xpath level

[[BookComponentAppendix-CacheUsageSamples]]
Cache Usage Samples
^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-Example1:Configuringthecache]]
Example 1: Configuring the cache
++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("cache://MyApplicationCache" +
          "?maxElementsInMemory=1000" +
          "&memoryStoreEvictionPolicy=" +
              "MemoryStoreEvictionPolicy.LFU" +
          "&overflowToDisk=true" +
          "&eternal=true" +
          "&timeToLiveSeconds=300" +
          "&timeToIdleSeconds=true" +
          "&diskPersistent=true" +
          "&diskExpiryThreadIntervalSeconds=300")
----

[[BookComponentAppendix-Example2:Addingkeystothecache]]
Example 2: Adding keys to the cache
+++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
     from("direct:start")
     .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD))
     .setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson"))
     .to("cache://TestCache1")
   }
};
----

[[BookComponentAppendix-Example2:Updatingexistingkeysinacache]]
Example 2: Updating existing keys in a cache
++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
     from("direct:start")
     .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_UPDATE))
     .setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson"))
     .to("cache://TestCache1")
   }
};
----

[[BookComponentAppendix-Example3:Deletingexistingkeysinacache]]
Example 3: Deleting existing keys in a cache
++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
     from("direct:start")
     .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_DELETE))
     .setHeader(CacheConstants.CACHE_KEY", constant("Ralph_Waldo_Emerson"))
     .to("cache://TestCache1")
   }
};
----

[[BookComponentAppendix-Example4:Deletingallexistingkeysinacache]]
Example 4: Deleting all existing keys in a cache
++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
     from("direct:start")
     .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_DELETEALL))
     .to("cache://TestCache1");
    }
};
----

[[BookComponentAppendix-Example5:NotifyinganychangesregisteringinaCachetoProcessorsandotherProducers]]
Example 5: Notifying any changes registering in a Cache to Processors
and other Producers
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
     from("cache://TestCache1")
     .process(new Processor() {
        public void process(Exchange exchange)
               throws Exception {
           String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);
           String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);
           Object body = exchange.getIn().getBody();
           // Do something
        }
     })
   }
};
----

[[BookComponentAppendix-Example6:UsingProcessorstoselectivelyreplacepayloadwithcachevalues]]
Example 6: Using Processors to selectively replace payload with cache
values
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
   public void configure() {
     //Message Body Replacer
     from("cache://TestCache1")
     .filter(header(CacheConstants.CACHE_KEY).isEqualTo("greeting"))
     .process(new CacheBasedMessageBodyReplacer("cache://TestCache1","farewell"))
     .to("direct:next");

    //Message Token replacer
    from("cache://TestCache1")
    .filter(header(CacheConstants.CACHE_KEY).isEqualTo("quote"))
    .process(new CacheBasedTokenReplacer("cache://TestCache1","novel","#novel#"))
    .process(new CacheBasedTokenReplacer("cache://TestCache1","author","#author#"))
    .process(new CacheBasedTokenReplacer("cache://TestCache1","number","#number#"))
    .to("direct:next");

    //Message XPath replacer
    from("cache://TestCache1").
    .filter(header(CacheConstants.CACHE_KEY).isEqualTo("XML_FRAGMENT"))
    .process(new CacheBasedXPathReplacer("cache://TestCache1","book1","/books/book1"))
    .process (new CacheBasedXPathReplacer("cache://TestCache1","book2","/books/book2"))
    .to("direct:next");
   }
};
----

[[BookComponentAppendix-Example7:GettinganentryfromtheCache]]
Example 7: Getting an entry from the Cache
++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start")
    // Prepare headers
    .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_GET))
    .setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")).
    .to("cache://TestCache1").
    // Check if entry was not found
    .choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNull()).
        // If not found, get the payload and put it to cache
        .to("cxf:bean:someHeavyweightOperation").
        .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD))
        .setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson"))
        .to("cache://TestCache1")
    .end()
    .to("direct:nextPhase");
----

[[BookComponentAppendix-Example8:CheckingforanentryintheCache]]
Example 8: Checking for an entry in the Cache
+++++++++++++++++++++++++++++++++++++++++++++

Note: The CHECK command tests existence of an entry in the cache but
doesn't place a message in the body.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start")
    // Prepare headers
    .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_CHECK))
    .setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson")).
    .to("cache://TestCache1").
    // Check if entry was not found
    .choice().when(header(CacheConstants.CACHE_ELEMENT_WAS_FOUND).isNull()).
        // If not found, get the payload and put it to cache
        .to("cxf:bean:someHeavyweightOperation").
        .setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD))
        .setHeader(CacheConstants.CACHE_KEY, constant("Ralph_Waldo_Emerson"))
        .to("cache://TestCache1")
    .end();
----

[[BookComponentAppendix-ManagementofEHCache]]
Management of EHCache
^^^^^^^^^^^^^^^^^^^^^

http://ehcache.org/[EHCache] has its own statistics and management from
link:camel-jmx.html[JMX].

Here's a snippet on how to expose them via JMX in a Spring application
context:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="ehCacheManagementService" class="net.sf.ehcache.management.ManagementService" init-method="init" lazy-init="false">
  <constructor-arg>
    <bean class="net.sf.ehcache.CacheManager" factory-method="getInstance"/>
  </constructor-arg>
  <constructor-arg>
    <bean class="org.springframework.jmx.support.JmxUtils" factory-method="locateMBeanServer"/>
  </constructor-arg>
  <constructor-arg value="true"/>
  <constructor-arg value="true"/>
  <constructor-arg value="true"/>
  <constructor-arg value="true"/>
</bean>
----

Of course you can do the same thing in straight Java:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ManagementService.registerMBeans(CacheManager.getInstance(), mbeanServer, true, true, true, true);
----

You can get cache hits, misses, in-memory hits, disk hits, size stats
this way. You can also change CacheConfiguration parameters on the fly.

[[BookComponentAppendix-CachereplicationCamel2.8+]]
Cache replication Camel 2.8+
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The Camel Cache component is able to distribute a cache across server
nodes using several different replication mechanisms including: RMI,
JGroups, JMS and Cache Server.

There are two different ways to make it work:

*1.* You can configure `ehcache.xml` manually

OR

*2.* You can configure these three options:

* cacheManagerFactory
* eventListenerRegistry
* cacheLoaderRegistry

Configuring Camel Cache replication using the first option is a bit of
hard work as you have to configure all caches separately. So in a
situation when the all names of caches are not known, using
`ehcache.xml` is not a good idea.

The second option is much better when you want to use many different
caches as you do not need to define options per cache. This is because
replication options are set per `CacheManager` and per `CacheEndpoint`.
Also it is the only way when cache names are not know at the development
phase.

[Note]
====


It might be useful to read the http://ehcache.org/documentation[EHCache
manual] to get a better understanding of the Camel Cache replication
mechanism.

====

[[BookComponentAppendix-Example:JMScachereplication]]
Example: JMS cache replication
++++++++++++++++++++++++++++++

JMS replication is the most powerful and secured replication method.
Used together with Camel Cache replication makes it also rather
simple. +
An example is available on link:cachereplicationjmsexample.html[a
separate page].

[[BookComponentAppendix-ClassComponent]]
Class Component
~~~~~~~~~~~~~~~

*Available as of Camel 2.4*

The *class:* component binds beans to Camel message exchanges. It works
in the same way as the link:bean.html[Bean] component but instead of
looking up beans from a link:registry.html[Registry] it creates the bean
based on the class name.

[[BookComponentAppendix-URIformat.6]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
class:className[?options]
----

Where *className* is the fully qualified class name to create and use as
bean.

[[BookComponentAppendix-Options.4]]
Options
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Type |Default |Description
|`method` |`String` |`null` |The method name that bean will be invoked.
If not provided, Camel will try to pick the method itself. In case of
ambiguity an exception is thrown. See link:bean-binding.html[Bean
Binding] for more details.

|`multiParameterArray` |`boolean` |`false` |How to treat the parameters
which are passed from the message body; if it is `true`, the In message
body should be an array of parameters.

|`bean.xxx` |  |`null` |*Camel 2.17:* To configure additional options on
the create bean instance from the class name. For example to configure a
foo option on the bean, use bean.foo=123.
|=======================================================================

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Using.1]]
Using
^^^^^

You simply use the *class* component just as the link:bean.html[Bean]
component but by specifying the fully qualified classname instead. +
For example to use the `MyFooBean` you have to do as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    from("direct:start").to("class:org.apache.camel.component.bean.MyFooBean").to("mock:result");
----

You can also specify which method to invoke on the `MyFooBean`, for
example `hello`:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    from("direct:start").to("class:org.apache.camel.component.bean.MyFooBean?method=hello").to("mock:result");
----

[[BookComponentAppendix-Settingpropertiesonthecreatedinstance]]
Setting properties on the created instance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the endpoint uri you can specify properties to set on the created
instance, for example if it has a `setPrefix` method:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
   // Camel 2.17 onwards
   from("direct:start")
        .to("class:org.apache.camel.component.bean.MyPrefixBean?bean.prefix=Bye")
        .to("mock:result");
 
   // Camel 2.16 and older 
   from("direct:start")
        .to("class:org.apache.camel.component.bean.MyPrefixBean?prefix=Bye")
        .to("mock:result");
----

And you can also use the `#` syntax to refer to properties to be looked
up in the link:registry.html[Registry].

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    // Camel 2.17 onwards
    from("direct:start")
        .to("class:org.apache.camel.component.bean.MyPrefixBean?bean.cool=#foo")
        .to("mock:result");

    // Camel 2.16 and older
    from("direct:start")
        .to("class:org.apache.camel.component.bean.MyPrefixBean?cool=#foo")
        .to("mock:result");
----

Which will lookup a bean from the link:registry.html[Registry] with the
id `foo` and invoke the `setCool` method on the created instance of the
`MyPrefixBean` class.

[Tip]
====
 **See more**

See more details at the link:bean.html[Bean] component as the *class*
component works in much the same way.

====

[[BookComponentAppendix-SeeAlso.3]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:bean.html[Bean]
* link:bean-binding.html[Bean Binding]
* link:bean-integration.html[Bean Integration]

[[BookComponentAppendix-CometdComponent]]
Cometd Component
~~~~~~~~~~~~~~~~

The *cometd:* component is a transport for working with the
http://www.mortbay.org/jetty[jetty] implementation of the
http://docs.codehaus.org/display/JETTY/Cometd+%28aka+Bayeux%29[cometd/bayeux
protocol]. +
Using this component in combination with the dojo toolkit library it's
possible to push Camel messages directly into the browser using an AJAX
based mechanism.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-cometd</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.7]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
cometd://host:port/channelName[?options]
----

The *channelName* represents a topic that can be subscribed to by the
Camel endpoints.

[[BookComponentAppendix-Examples]]
Examples
^^^^^^^^

....
cometd://localhost:8080/service/mychannel
cometds://localhost:8443/service/mychannel
....

where `cometds:` represents an SSL configured endpoint.

[[BookComponentAppendix-Options.5]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`resourceBase` |  |The root directory for the web resources or
classpath. Use the protocol file: or classpath: depending if you want
that the component loads the resource from file system or classpath.
Classpath is required for OSGI deployment where the resources are
packaged in the jar. Notice this option has been renamed to
`baseResource` from *Camel 2.7* onwards.

|`baseResource` |  |*Camel 2.7:* The root directory for the web
resources or classpath. Use the protocol file: or classpath: depending
if you want that the component loads the resource from file system or
classpath. Classpath is required for OSGI deployment where the resources
are packaged in the jar

|`timeout` |`240000` |The server side poll timeout in milliseconds. This
is how long the server will hold a reconnect request before responding.

|`interval` |`0` |The client side poll timeout in milliseconds. How long
a client will wait between reconnects

|`maxInterval` |`30000` |The max client side poll timeout in
milliseconds. A client will be removed if a connection is not received
in this time.

|`multiFrameInterval` |`1500` |The client side poll timeout, if multiple
connections are detected from the same browser.

|`jsonCommented` |`true` |If `true`, the server will accept JSON wrapped
in a comment and will generate JSON wrapped in a comment. This is a
defence against Ajax Hijacking.

|`logLevel` |`1` |`0`=none, `1`=info, `2`=debug.

|`crossOriginFilterOn` |`false` |*Camel 2.10:* If `true`, the server
will support for cross-domain filtering

|`allowedOrigins` |`*` |*Camel 2.10:* The origins domain that support to
cross, if the `crosssOriginFilterOn` is `true`

|`filterPath` |  |*Camel 2.10:* The filterPath will be used by the
CrossOriginFilter, if the `crosssOriginFilterOn` is `true`

|`disconnectLocalSession` |  |*Camel 2.10.5/2.11.1: (Producer only)*:
Whether to disconnect local sessions after publishing a message to its
channel. Disconnecting local session is needed as they are not swept by
default by CometD, and therefore you can run out of memory. In Camel
2.16.1/2.15.5 or older the default value is true. From newer versions
the default value is false.
|=======================================================================

You can append query options to the URI in the following format,
`?option=value&option=value&...`

Here is some examples on How to pass the parameters

For file (for webapp resources located in the Web Application directory
--> cometd://localhost:8080?resourceBase=file./webapp +
For classpath (when by example the web resources are packaged inside the
webapp folder --> cometd://localhost:8080?resourceBase=classpath:webapp

[[BookComponentAppendix-Authentication]]
Authentication
^^^^^^^^^^^^^^

*Available as of Camel 2.8*

You can configure custom `SecurityPolicy` and `Extension`'s to the
`CometdComponent` which allows you to use authentication as
http://cometd.org/documentation/howtos/authentication[documented here]

[[BookComponentAppendix-SettingupSSLforCometdComponent]]
Setting up SSL for Cometd Component
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-UsingtheJSSEConfigurationUtility]]
Using the JSSE Configuration Utility
++++++++++++++++++++++++++++++++++++

As of Camel 2.9, the Cometd component supports SSL/TLS configuration
through the link:camel-configuration-utilities.html[Camel JSSE
Configuration Utility].  This utility greatly decreases the amount of
component specific code you need to write and is configurable at the
endpoint and component levels.  The following examples demonstrate how
to use the utility with the Cometd component. You need to configure SSL
on the CometdComponent.

[[BookComponentAppendix-Programmaticconfigurationofthecomponent]]
Programmatic configuration of the component

[source,brush:,java;,gutter:,false;,theme:,Default]
----
KeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("/users/home/server/keystore.jks");
ksp.setPassword("keystorePassword");

KeyManagersParameters kmp = new KeyManagersParameters();
kmp.setKeyStore(ksp);
kmp.setKeyPassword("keyPassword");

TrustManagersParameters tmp = new TrustManagersParameters();
tmp.setKeyStore(ksp);

SSLContextParameters scp = new SSLContextParameters();
scp.setKeyManagers(kmp);
scp.setTrustManagers(tmp);

CometdComponent commetdComponent = getContext().getComponent("cometds", CometdComponent.class);
commetdComponent.setSslContextParameters(scp);
----

[[BookComponentAppendix-SpringDSLbasedconfigurationofendpoint]]
Spring DSL based configuration of endpoint

[source,brush:,java;,gutter:,false;,theme:,Default]
----
...
  <camel:sslContextParameters
      id="sslContextParameters">
    <camel:keyManagers
        keyPassword="keyPassword">
      <camel:keyStore
          resource="/users/home/server/keystore.jks"
          password="keystorePassword"/>
    </camel:keyManagers>
    <camel:trustManagers>
      <camel:keyStore
          resource="/users/home/server/keystore.jks"
          password="keystorePassword"/>
    </camel:keyManagers>
  </camel:sslContextParameters>...
 
  <bean id="cometd" class="org.apache.camel.component.cometd.CometdComponent">
    <property name="sslContextParameters" ref="sslContextParameters"/>
  </bean>
...
  <to uri="cometds://127.0.0.1:443/service/test?baseResource=file:./target/test-classes/webapp&timeout=240000&interval=0&maxInterval=30000&multiFrameInterval=1500&jsonCommented=true&logLevel=2"/>...
----

[[BookComponentAppendix-SeeAlso.4]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-ContextComponent]]
Context Component
~~~~~~~~~~~~~~~~~

*Available as of Camel 2.7*

[Warning]
====


Deprecated do NOT use

====

 

The *context* component allows you to create new Camel Components from a
CamelContext with a number of routes which is then treated as a black
box, allowing you to refer to the local endpoints within the component
from other CamelContexts.

It is similar to the link:routebox.html[Routebox] component in idea,
though the Context component tries to be really simple for end users;
just a simple convention over configuration approach to refer to local
endpoints inside the CamelContext Component.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-context</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.8]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
context:camelContextId:localEndpointName[?options]
----

Or you can omit the "context:" prefix.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
camelContextId:localEndpointName[?options]
----

* *camelContextId* is the ID you used to register the CamelContext into
the link:registry.html[Registry].
* *localEndpointName* can be a valid Camel URI evaluated within the
black box CamelContext. Or it can be a logical name which is mapped to
any local endpoints. For example if you locally have endpoints like
*direct:invoices* and *seda:purchaseOrders* inside a CamelContext of id
*supplyChain*, then you can just use the URIs *supplyChain:invoices* or
*supplyChain:purchaseOrders* to omit the physical endpoint kind and use
pure logical URIs.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Example]]
Example
^^^^^^^

In this example we'll create a black box context, then we'll use it from
another CamelContext.

[[BookComponentAppendix-Definingthecontextcomponent]]
Defining the context component
++++++++++++++++++++++++++++++

First you need to create a CamelContext, add some routes in it, start it
and then register the CamelContext into the link:registry.html[Registry]
(JNDI, Spring, Guice or OSGi etc).

This can be done in the usual Camel way from this
http://svn.apache.org/viewvc/camel/trunk/components/camel-context/src/test/java/org/apache/camel/component/context/JavaDslBlackBoxTest.java?revision=1069442&view=markup[test
case] (see the createRegistry() method); this example shows Java and
JNDI being used...

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// lets create our black box as a camel context and a set of routes
DefaultCamelContext blackBox = new DefaultCamelContext(registry);
blackBox.setName("blackBox");
blackBox.addRoutes(new RouteBuilder() {
    @Override
    public void configure() throws Exception {
        // receive purchase orders, lets process it in some way then send an invoice
        // to our invoice endpoint
        from("direct:purchaseOrder").
          setHeader("received").constant("true").
          to("direct:invoice");
    }
});
blackBox.start();

registry.bind("accounts", blackBox);
----

Notice in the above route we are using pure local endpoints (*direct*
and *seda*). Also note we expose this CamelContext using the *accounts*
ID. We can do the same thing in Spring via

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext id="accounts" xmlns="http://camel.apache.org/schema/spring">
  <route> 
    <from uri="direct:purchaseOrder"/>
    ...
    <to uri="direct:invoice"/>
  </route>
</camelContext>
----

[[BookComponentAppendix-Usingthecontextcomponent]]
Using the context component
+++++++++++++++++++++++++++

Then in another CamelContext we can then refer to this "accounts black
box" by just sending to *accounts:purchaseOrder* and consuming from
*accounts:invoice*.

If you prefer to be more verbose and explicit you could use
*context:accounts:purchaseOrder* or even
*context:accounts:direct://purchaseOrder* if you prefer. But using
logical endpoint URIs is preferred as it hides the implementation detail
and provides a simple logical naming scheme.

For example if we wish to then expose this accounts black box on some
middleware (outside of the black box) we can do things like...

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
  <route> 
    <!-- consume from an ActiveMQ into the black box -->
    <from uri="activemq:Accounts.PurchaseOrders"/>
    <to uri="accounts:purchaseOrders"/>
  </route>
  <route> 
    <!-- lets send invoices from the black box to a different ActiveMQ Queue -->
    <from uri="accounts:invoice"/>
    <to uri="activemq:UK.Accounts.Invoices"/>
  </route>
</camelContext>
----

[[BookComponentAppendix-Namingendpoints]]
Naming endpoints
++++++++++++++++

A context component instance can have many public input and output
endpoints that can be accessed from outside it's CamelContext. When
there are many it is recommended that you use logical names for them to
hide the middleware as shown above.

However when there is only one input, output or error/dead letter
endpoint in a component we recommend using the common posix shell names
*in*, *out* and *err*

[[BookComponentAppendix-CryptocomponentforDigitalSignatures]]
Crypto component for Digital Signatures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.3*

With Camel cryptographic endpoints and Java's Cryptographic extension it
is easy to create Digital Signatures for link:exchange.html[Exchange]s.
Camel provides a pair of flexible endpoints which get used in concert to
create a signature for an exchange in one part of the exchange's
workflow and then verify the signature in a later part of the workflow.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-crypto</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-Introduction]]
Introduction
^^^^^^^^^^^^

Digital signatures make use of Asymmetric Cryptographic techniques to
sign messages. From a (very) high level, the algorithms use pairs of
complimentary keys with the special property that data encrypted with
one key can only be decrypted with the other. One, the private key, is
closely guarded and used to 'sign' the message while the other, public
key, is shared around to anyone interested in verifying the signed
messages. Messages are signed by using the private key to encrypting a
digest of the message. This encrypted digest is transmitted along with
the message. On the other side the verifier recalculates the message
digest and uses the public key to decrypt the the digest in the
signature. If both digests match the verifier knows only the holder of
the private key could have created the signature.

Camel uses the Signature service from the Java Cryptographic Extension
to do all the heavy cryptographic lifting required to create exchange
signatures. The following are some excellent resources for explaining
the mechanics of Cryptography, Message digests and Digital Signatures
and how to leverage them with the JCE.

* Bruce Schneier's Applied Cryptography
* Beginning Cryptography with Java by David Hook
* The ever insightful Wikipedia
http://en.wikipedia.org/wiki/Digital_signature[Digital_signatures]

[[BookComponentAppendix-URIformat.9]]
URI format
^^^^^^^^^^

As mentioned Camel provides a pair of crypto endpoints to create and
verify signatures

crypto:sign:name[?options] crypto:verify:name[?options]

* `crypto:sign` creates the signature and stores it in the Header keyed
by the constant
`org.apache.camel.component.crypto.DigitalSignatureConstants.SIGNATURE`,
i.e. `"CamelDigitalSignature"`.
* `crypto:verify` will read in the contents of this header and do the
verification calculation.

In order to correctly function, the sign and verify process needs a pair
of keys to be shared, signing requiring a `PrivateKey` and verifying a
`PublicKey` (or a `Certificate` containing one). Using the JCE it is
very simple to generate these key pairs but it is usually most secure to
use a KeyStore to house and share your keys. The DSL is very flexible
about how keys are supplied and provides a number of mechanisms.

Note a `crypto:sign` endpoint is typically defined in one route and the
complimentary `crypto:verify` in another, though for simplicity in the
examples they appear one after the other. It goes without saying that
both signing and verifying should be configured identically.

[[BookComponentAppendix-Options.6]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Type |Default |Description
|`algorithm` |`String` |`SHA1WithDSA` |The name of the JCE Signature
algorithm that will be used.

|`alias` |`String` |`null` |An alias name that will be used to select a
key from the keystore.

|`bufferSize` |`Integer` |`2048` |the size of the buffer used in the
signature process.

|`certificate` |`Certificate` |`null` |A Certificate used to verify the
signature of the exchange's payload. Either this or a Public Key is
required.

|`keystore` |`KeyStore` |`null` |A reference to a JCE Keystore that
stores keys and certificates used to sign and verify.

|keyStoreParameters *Camel 2.14.1* |KeyStoreParameters |null |A
reference to a Camel KeyStoreParameters Object which wraps a Java
KeyStore Object

|`provider` |`String` |`null` |The name of the JCE Security Provider
that should be used.

|`privateKey` |`PrivateKey` |`null` |The private key used to sign the
exchange's payload.

|`publicKey` |`PublicKey` |`null` |The public key used to verify the
signature of the exchange's payload.

|`secureRandom` |`secureRandom` |`null` |A reference to a `SecureRandom`
object that will be used to initialize the Signature service.

|`password` |`char[]` |`null` |The password to access the private key
from the keystore

|`clearHeaders` |`String` |`true` |Remove camel crypto headers from
Message after a verify operation (value can be `"true"`/`"false"`).
|=======================================================================

[[BookComponentAppendix-Using.2]]
Using
^^^^^

[[BookComponentAppendix-1)Rawkeys]]
1) Raw keys
+++++++++++

The most basic way to way to sign and verify an exchange is with a
KeyPair as
follows.\{snippet:id=basic|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}The
same can be achieved with the link:spring-xml-extensions.html[Spring XML
Extensions] using references to
keys\{snippet:id=basic|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}

[[BookComponentAppendix-2)KeyStoresandAliases.]]
2) KeyStores and Aliases.
+++++++++++++++++++++++++

The JCE provides a very versatile keystore concept for housing pairs of
private keys and certificates, keeping them encrypted and password
protected. They can be retrieved by applying an alias to the retrieval
APIs. There are a number of ways to get keys and Certificates into a
keystore, most often this is done with the external 'keytool'
application.
http://www.exampledepot.com/egs/java.security.cert/CreateCert.html[This]
is a good example of using keytool to create a KeyStore with a self
signed Cert and Private key.

The examples use a Keystore with a key and cert aliased by 'bob'. The
password for the keystore and the key is 'letmein'

The following shows how to use a Keystore via the Fluent builders, it
also shows how to load and initialize the
keystore.\{snippet:id=keystore|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}Again
in Spring a ref is used to lookup an actual keystore
instance.\{snippet:id=keystore|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}

[[BookComponentAppendix-3)ChangingJCEProviderandAlgorithm]]
3) Changing JCE Provider and Algorithm
++++++++++++++++++++++++++++++++++++++

Changing the Signature algorithm or the Security provider is a simple
matter of specifying their names. You will need to also use Keys that
are compatible with the algorithm you
choose.\{snippet:id=algorithm|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}\{snippet:id=provider|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}or\{snippet:id=algorithm|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}\{snippet:id=provider|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}

[[BookComponentAppendix-4)ChangingtheSignatureMessageHeader]]
4) Changing the Signature Message Header
++++++++++++++++++++++++++++++++++++++++

It may be desirable to change the message header used to store the
signature. A different header name can be specified in the route
definition as
follows\{snippet:id=signature-header|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}or\{snippet:id=signature-header|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}

[[BookComponentAppendix-5)Changingthebuffersize]]
5) Changing the buffersize
++++++++++++++++++++++++++

In case you need to update the size of the
buffer...\{snippet:id=buffersize|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}or\{snippet:id=buffersize|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}

[[BookComponentAppendix-6)SupplyingKeysdynamically.]]
6) Supplying Keys dynamically.
++++++++++++++++++++++++++++++

When using a Recipient list or similar EIP the recipient of an exchange
can vary dynamically. Using the same key across all recipients may be
neither feasible nor desirable. It would be useful to be able to specify
signature keys dynamically on a per-exchange basis. The exchange could
then be dynamically enriched with the key of its target recipient prior
to signing. To facilitate this the signature mechanisms allow for keys
to be supplied dynamically via the message headers below

* `Exchange.SIGNATURE_PRIVATE_KEY`, `"CamelSignaturePrivateKey"`
* `Exchange.SIGNATURE_PUBLIC_KEY_OR_CERT`,
`"CamelSignaturePublicKeyOrCert"`

\{snippet:id=headerkey|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}or\{snippet:id=headerkey|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}Even
better would be to dynamically supply a keystore alias. Again the alias
can be supplied in a message header

* `Exchange.KEYSTORE_ALIAS`, `"CamelSignatureKeyStoreAlias"`

\{snippet:id=alias|lang=java|url=camel/trunk/components/camel-crypto/src/test/java/org/apache/camel/component/crypto/SignatureTests.java}or\{snippet:id=alias|lang=xml|url=camel/trunk/components/camel-crypto/src/test/resources/org/apache/camel/component/crypto/SpringSignatureTests.xml}The
header would be set as follows

Exchange unsigned =
getMandatoryEndpoint("direct:alias-sign").createExchange();
unsigned.getIn().setBody(payload);
unsigned.getIn().setHeader(DigitalSignatureConstants.KEYSTORE_ALIAS,
"bob");
unsigned.getIn().setHeader(DigitalSignatureConstants.KEYSTORE_PASSWORD,
"letmein".toCharArray()); template.send("direct:alias-sign", unsigned);
Exchange signed =
getMandatoryEndpoint("direct:alias-sign").createExchange();
signed.getIn().copyFrom(unsigned.getOut());
signed.getIn().setHeader(KEYSTORE_ALIAS, "bob");
template.send("direct:alias-verify", signed);

link:endpoint-see-also.html[Endpoint See Also]

* link:crypto.html[Crypto] Crypto is also available as a
link:data-format.html[Data Format]

[[BookComponentAppendix-CXFComponent]]
CXF Component
~~~~~~~~~~~~~

When using CXF as a consumer, the link:cxf-bean-component.html[CXF Bean
Component] allows you to factor out how message payloads are received
from their processing as a RESTful or SOAP web service. This has the
potential of using a multitude of transports to consume web services.
The bean component's configuration is also simpler and provides the
fastest method to implement web services using Camel and CXF.

When using CXF in streaming modes (see DataFormat option), then also
read about link:stream-caching.html[Stream caching].

The *cxf:* component provides integration with
http://cxf.apache.org[Apache CXF] for connecting to JAX-WS services
hosted in CXF.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-cxf</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency> CXF
dependencies

If you want to learn about CXF dependencies you can checkout the
`WHICH-JARS` text file.

[[BookComponentAppendix-URIformat.10]]
URI format
^^^^^^^^^^

javacxf:bean:cxfEndpoint[?options]

Where *cxfEndpoint* represents a bean ID that references a bean in the
Spring bean registry. With this URI format, most of the endpoint details
are specified in the bean definition.

javacxf://someAddress[?options]

Where *someAddress* specifies the CXF endpoint's address. With this URI
format, most of the endpoint details are specified using options.

For either style above, you can append options to the URI as follows:

javacxf:bean:cxfEndpoint?wsdlURL=wsdl/hello_world.wsdl&dataFormat=PAYLOAD

[[BookComponentAppendix-Options.7]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Required |Description
|`wsdlURL` |No |The location of the WSDL. It is obtained from endpoint
address by default. +
 +
_Example_: file://local/wsdl/hello.wsdl or `wsdl/hello.wsdl`

|`serviceClass` |Yes |The name of the SEI (Service Endpoint Interface)
class. This class can have, but does not require, JSR181 annotations. +
This option is only required by POJO mode. If the wsdlURL option is
provided, serviceClass is not required for PAYLOAD and MESSAGE mode.
When wsdlURL option is used without serviceClass, the serviceName and
portName (endpointName for Spring configuration) options *MUST* be
provided. It is possible to use `#` notation to reference a
`serviceClass` object instance from the registry. E.g.
`serviceClass=#beanName`. The `serviceClass` for a CXF producer (that
is, the `to` endpoint) should be a Java interface. +
*Since 2.8,* it is possible to omit both wsdlURL and serviceClass
options for PAYLOAD and MESSAGE mode. When they are omitted, arbitrary
XML elements can be put in CxfPayload's body in PAYLOAD mode to
facilitate CXF Dispatch Mode. +
 +
Please be advised that the *referenced object cannot be a Proxy* (Spring
AOP Proxy is OK) as it relies on `Object.getClass().getName()` method
for non Spring AOP Proxy. +
 +
_Example_: `org.apache.camel.Hello`

|`serviceName` |No |The service name this service is implementing, it
maps to the `wsdl:service@name`. +
 +
*Required* for camel-cxf consumer since camel-2.2.0 or if more than one
`serviceName` is present in WSDL. +
 +
_Example_: \{http:­//org.apache.camel}ServiceName

|`endpointName` |No |The port name this service is implementing, it maps
to the `wsdl:port@name`. +
 +
*Required* for camel-cxf consumer since camel-2.2.0 or if more than one
`portName` is present under `serviceName`. +
 +
_Example_: \{http:­//org.apache.camel}PortName

|`dataFormat` |No |The data type messages supported by the CXF
endpoint. +
 +
_Default_: `POJO` +
_Example_: `POJO`, `PAYLOAD`, `MESSAGE`

|`relayHeaders` |No |Please see the *Description of* `relayHeaders`
*option* section for this option. Should a CXF endpoint relay headers
along the route. Currently only available when `dataFormat=POJO` +
 +
_Default_: `true` +
_Example_: `true`, `false`

|`wrapped` |No |Which kind of operation that CXF endpoint producer will
invoke +
 +
_Default_: `false` +
_Example_: `true`, `false`

|`wrappedStyle` |No |*New in 2.5.0* The WSDL style that describes how
parameters are represented in the SOAP body. If the value is false, CXF
will chose the document-literal unwrapped style, If the value is true,
CXF will chose the document-literal wrapped style +
 +
_Default_: `Null` +
_Example_: `true`, `false`

|`setDefaultBus` |No |*Deprecated* Will set the default bus when CXF
endpoint create a bus by itself. This option is deprecated use
defaultBus from Camel 2.16 onwards. +
 +
_Default_: `false` +
_Example_: `true`, `false`

|`defaultBus` + |No a|
*Camel 2.16:* Will set the default bus when CXF endpoint create a bus by
itself

 __Default__: `false`  +
 __Example__: `true`, `false`

|`bus` |No |A default bus created by CXF Bus Factory. Use `#` notation
to reference a bus object from the registry. The referenced object must
be an instance of `org.apache.cxf.Bus`. +
 +
_Example_: `bus=#busName`

|`cxfBinding` |No |Use `#` notation to reference a CXF binding object
from the registry. The referenced object must be an instance of
`org.apache.camel.component.cxf.CxfBinding` (use an instance of
`org.apache.camel.component.cxf.DefaultCxfBinding`). +
 +
_Example_: `cxfBinding=#bindingName`

|`headerFilterStrategy` |No |Use `#` notation to reference a header
filter strategy object from the registry. The referenced object must be
an instance of `org.apache.camel.spi.HeaderFilterStrategy` (use an
instance of `org.apache.camel.component.cxf.CxfHeaderFilterStrategy`). +
 +
_Example_: `headerFilterStrategy=#strategyName`

|`loggingFeatureEnabled` |No |New in 2.3. This option enables CXF
Logging Feature which writes inbound and outbound SOAP messages to
log. +
 +
_Default_: `false` +
_Example_: `loggingFeatureEnabled``=true`

|`defaultOperationName` |No |New in 2.4, this option will set the
default operationName that will be used by the CxfProducer which invokes
the remote service. +
 +
_Default_: `null` +
_Example_: `defaultOperationName``=greetMe`

|`defaultOperationNamespace` |No |New in 2.4. This option will set the
default operationNamespace that will be used by the CxfProducer which
invokes the remote service. +
 +
_Default_: `null` +
_Example_:
`defaultOperationNamespace``=``http://apache.org/hello_world_soap_http`

|`synchronous` |No |New in 2.5. This option will let cxf endpoint decide
to use sync or async API to do the underlying work. The default value is
false which means camel-cxf endpoint will try to use async API by
default. +
 +
_Default_: `false` +
_Example_: synchronous=true

|`publishedEndpointUrl` |No |New in 2.5. This option can override the
endpointUrl that published from the WSDL which can be accessed with
service address url plus ?wsdl. +
 +
_Default_: `null` +
_Example_: publshedEndpointUrl=http://example.com/service

|`properties.XXX` |No |*Camel 2.8:* Allows to set custom properties to
CXF in the endpoint uri. For example setting
`properties.mtom-enabled=true` to enable MTOM.
`properties.org.apache.cxf.interceptor.OneWayProcessorInterceptor.USE_ORIGINAL_THREAD=true `just
make sure the CXF doesn't switch the thread when start the invocation.

|`allowStreaming` |No |New in *Camel 2.8.2*. This option controls
whether the CXF component, when running in PAYLOAD mode (see below),
will DOM parse the incoming messages into DOM Elements or keep the
payload as a javax.xml.transform.Source object that would allow
streaming in some cases.

|`skipFaultLogging` |No |New in *Camel 2.11*. This option controls
whether the PhaseInterceptorChain skips logging the Fault that it
catches.

|`cxfEndpointConfigurer` + |No |New in *Camel 2.11*. This option could
apply the implementation of
`org.apache.camel.component.cxf.CxfEndpointConfigurer which `supports to
configure the CXF endpoint in  programmatic way. Since *Camel 2.15.0,*
user can configure the CXF server and client by implementing
configure\{Server|Client} method of `CxfEndpointConfigurer`.

|`username` |No |New in *Camel 2.12.3* This option is used to set the
basic authentication information of username for the CXF client.

|`password` |No |New in *Camel 2.12.3* This option is used to set the
basic authentication information of password for the CXF client.

|`continuationTimeout` |No a|
New in *Camel 2.14.0* This option is used to set the CXF continuation
timeout which could be used in CxfConsumer by default when the CXF
server is using Jetty or Servlet transport. (Before *Camel 2.14.0*,
CxfConsumer just set the continuation timeout to be 0, which means the
continuation suspend operation never timeout.)

_Default_: 30000 +
 _Example_: continuation=80000

|`cookieHandler` |No |New in *Camel 2.19.0:* Configure a cookie handler
to maintain a HTTP session
|=======================================================================

The `serviceName` and `portName` are
http://en.wikipedia.org/wiki/QName[QNames], so if you provide them be
sure to prefix them with their \{namespace} as shown in the examples
above.

[[BookComponentAppendix-Thedescriptionsofthedataformats]]
The descriptions of the dataformats
+++++++++++++++++++++++++++++++++++

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|DataFormat |Description
|`POJO` |POJOs (Plain old Java objects) are the Java parameters to the
method being invoked on the target server. Both Protocol and Logical
JAX-WS handlers are supported.

|`PAYLOAD` |`PAYLOAD` is the message payload (the contents of the
`soap:body`) after message configuration in the CXF endpoint is applied.
Only Protocol JAX-WS handler is supported. Logical JAX-WS handler is not
supported.

|`MESSAGE` |`MESSAGE` is the raw message that is received from the
transport layer. It is not suppose to touch or change Stream, some of
the CXF interceptors will be removed if you are using this kind of
DataFormat so you can't see any soap headers after the camel-cxf
consumer and JAX-WS handler is not supported.

|`CXF_MESSAGE` |New in *Camel 2.8.2*, `CXF_MESSAGE` allows for invoking
the full capabilities of CXF interceptors by converting the message from
the transport layer into a raw SOAP message
|=======================================================================

You can determine the data format mode of an exchange by retrieving the
exchange property, `CamelCXFDataFormat`. The exchange key constant is
defined in
`org.apache.camel.component.cxf.CxfConstants.DATA_FORMAT_PROPERTY`.

[[BookComponentAppendix-HowtoenableCXF'sLoggingOutInterceptorinMESSAGEmode]]
How to enable CXF's LoggingOutInterceptor in MESSAGE mode

CXF's `LoggingOutInterceptor` outputs outbound message that goes on the
wire to logging system (Java Util Logging). Since the
`LoggingOutInterceptor` is in `PRE_STREAM` phase (but `PRE_STREAM` phase
is removed in `MESSAGE` mode), you have to configure
`LoggingOutInterceptor` to be run during the `WRITE` phase. The
following is an
example.\{snippet:id=enableLoggingOutInterceptor|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/LoggingInterceptorInMessageModeTest-context.xml}

[[BookComponentAppendix-DescriptionofrelayHeadersoption]]
Description of relayHeaders option
++++++++++++++++++++++++++++++++++

There are _in-band_ and _out-of-band_ on-the-wire headers from the
perspective of a JAXWS WSDL-first developer.

The _in-band_ headers are headers that are explicitly defined as part of
the WSDL binding contract for an endpoint such as SOAP headers.

The _out-of-band_ headers are headers that are serialized over the wire,
but are not explicitly part of the WSDL binding contract.

Headers relaying/filtering is bi-directional.

When a route has a CXF endpoint and the developer needs to have
on-the-wire headers, such as SOAP headers, be relayed along the route to
be consumed say by another JAXWS endpoint, then `relayHeaders` should be
set to `true`, which is the default value.

[[BookComponentAppendix-AvailableonlyinPOJOmode]]
Available only in POJO mode

The `relayHeaders=true` express an intent to relay the headers. The
actual decision on whether a given header is relayed is delegated to a
pluggable instance that implements the `MessageHeadersRelay` interface.
A concrete implementation of `MessageHeadersRelay` will be consulted to
decide if a header needs to be relayed or not. There is already an
implementation of `SoapMessageHeadersRelay` which binds itself to
well-known SOAP name spaces. Currently only out-of-band headers are
filtered, and in-band headers will always be relayed when
`relayHeaders=true`. If there is a header on the wire, whose name space
is unknown to the runtime, then a fall back `DefaultMessageHeadersRelay`
will be used, which simply allows all headers to be relayed.

The `relayHeaders=false` setting asserts that all headers in-band and
out-of-band will be dropped.

You can plugin your own `MessageHeadersRelay` implementations overriding
or adding additional ones to the list of relays. In order to override a
preloaded relay instance just make sure that your `MessageHeadersRelay`
implementation services the same name spaces as the one you looking to
override. Also note, that the overriding relay has to service all of the
name spaces as the one you looking to override, or else a runtime
exception on route start up will be thrown as this would introduce an
ambiguity in name spaces to relay instance mappings.

xml<cxf:cxfEndpoint ...> <cxf:properties> <entry
key="org.apache.camel.cxf.message.headers.relays"> <list> <ref
bean="customHeadersRelay"/> </list> </entry> </cxf:properties>
</cxf:cxfEndpoint> <bean id="customHeadersRelay"
class="org.apache.camel.component.cxf.soap.headers.CustomHeadersRelay"/>

Take a look at the tests that show how you'd be able to relay/drop
headers here:

https://svn.apache.org/repos/asf/camel/branches/camel-1.x/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java

[[BookComponentAppendix-ChangessinceRelease2.0]]
Changes since Release 2.0

* `POJO` and `PAYLOAD` modes are supported. In `POJO` mode, only
out-of-band message headers are available for filtering as the in-band
headers have been processed and removed from header list by CXF. The
in-band headers are incorporated into the `MessageContentList` in POJO
mode. The `camel-cxf` component does make any attempt to remove the
in-band headers from the `MessageContentList`. If filtering of in-band
headers is required, please use `PAYLOAD` mode or plug in a (pretty
straightforward) CXF interceptor/JAXWS Handler to the CXF endpoint.
* The Message Header Relay mechanism has been merged into
`CxfHeaderFilterStrategy`. The `relayHeaders` option, its semantics, and
default value remain the same, but it is a property of
`CxfHeaderFilterStrategy`. +
Here is an example of configuring
it.\{snippet:id=dropAllMessageHeadersStrategy|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest-context.xml}Then,
your endpoint can reference the
`CxfHeaderFilterStrategy`.\{snippet:id=noRelayRoute|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest-context.xml}
* The `MessageHeadersRelay` interface has changed slightly and has been
renamed to `MessageHeaderFilter`. It is a property of
`CxfHeaderFilterStrategy`. Here is an example of configuring user
defined Message Header
Filters:\{snippet:id=customMessageFilterStrategy|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest-context.xml}
* Other than `relayHeaders`, there are new properties that can be
configured in `CxfHeaderFilterStrategy`.
+
[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Required |Description
|`relayHeaders` |No |All message headers will be processed by Message
Header Filters +
 +
_Type_: `boolean` +
_Default_: `true`

|`relayAllMessageHeaders` |No |All message headers will be propagated
(without processing by Message Header Filters) +
 +
_Type_: `boolean` +
_Default_: `false`

|`allowFilterNamespaceClash` |No |If two filters overlap in activation
namespace, the property control how it should be handled. If the value
is `true`, last one wins. If the value is `false`, it will throw an
exception +
 +
_Type_: `boolean` +
_Default_: `false`
|=======================================================================
+
[[BookComponentAppendix-ConfiguretheCXFendpointswithSpring]]
Configure the CXF endpoints with Spring
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
You can configure the CXF endpoint with the Spring configuration file
shown below, and you can also embed the endpoint into the `camelContext`
tags. When you are invoking the service endpoint, you can set the
`operationName` and `operationNamespace` headers to explicitly state
which operation you are calling.
+
xml<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:cxf="http://camel.apache.org/schema/cxf" xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://camel.apache.org/schema/cxf
http://camel.apache.org/schema/cxf/camel-cxf.xsd
http://camel.apache.org/schema/spring
http://camel.apache.org/schema/spring/camel-spring.xsd">
<cxf:cxfEndpoint id="routerEndpoint"
address="http://localhost:9003/CamelContext/RouterPort"
serviceClass="org.apache.hello_world_soap_http.GreeterImpl"/>
<cxf:cxfEndpoint id="serviceEndpoint"
address="http://localhost:9000/SoapContext/SoapPort"
wsdlURL="testutils/hello_world.wsdl"
serviceClass="org.apache.hello_world_soap_http.Greeter"
endpointName="s:SoapPort" serviceName="s:SOAPService"
xmlns:s="http://apache.org/hello_world_soap_http" /> <camelContext
id="camel" xmlns="http://camel.apache.org/schema/spring"> <route> <from
uri="cxf:bean:routerEndpoint" /> <to uri="cxf:bean:serviceEndpoint" />
</route> </camelContext> </beans>
+
Be sure to include the JAX-WS `schemaLocation` attribute specified on
the root beans element. This allows CXF to validate the file and is
required. Also note the namespace declarations at the end of the
`<cxf:cxfEndpoint/>` tag--these are required because the combined
\{`namespace}localName` syntax is presently not supported for this tag's
attribute values.
+
The `cxf:cxfEndpoint` element supports many additional attributes:
+
[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Name |Value
|`PortName` |The endpoint name this service is implementing, it maps to
the `wsdl:port@name`. In the format of `ns:PORT_NAME` where `ns` is a
namespace prefix valid at this scope.

|`serviceName` |The service name this service is implementing, it maps
to the `wsdl:service@name`. In the format of `ns:SERVICE_NAME` where
`ns` is a namespace prefix valid at this scope.

|`wsdlURL` |The location of the WSDL. Can be on the classpath, file
system, or be hosted remotely.

|`bindingId` |The `bindingId` for the service model to use.

|`address` |The service publish address.

|`bus` |The bus name that will be used in the JAX-WS endpoint.

|`serviceClass` |The class name of the SEI (Service Endpoint Interface)
class which could have JSR181 annotation or not.
|=======================================================================
+
It also supports many child elements:
+
[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Name |Value
|`cxf:inInterceptors` |The incoming interceptors for this endpoint. A
list of `<bean>` or `<ref>`.

|`cxf:inFaultInterceptors` |The incoming fault interceptors for this
endpoint. A list of `<bean>` or `<ref>`.

|`cxf:outInterceptors` |The outgoing interceptors for this endpoint. A
list of `<bean>` or `<ref>`.

|`cxf:outFaultInterceptors` |The outgoing fault interceptors for this
endpoint. A list of `<bean>` or `<ref>`.

|`cxf:properties` |A properties map which should be supplied to the
JAX-WS endpoint. See below.

|`cxf:handlers` |A JAX-WS handler list which should be supplied to the
JAX-WS endpoint. See below.

|`cxf:dataBinding` |You can specify the which `DataBinding` will be use
in the endpoint. This can be supplied using the Spring
`<bean class="MyDataBinding"/>` syntax.

|`cxf:binding` |You can specify the `BindingFactory` for this endpoint
to use. This can be supplied using the Spring
`<bean class="MyBindingFactory"/>` syntax.

|`cxf:features` |The features that hold the interceptors for this
endpoint. A list of \{\{<bean>}}s or \{\{<ref>}}s

|`cxf:schemaLocations` |The schema locations for endpoint to use. A list
of \{\{<schemaLocation>}}s

|`cxf:serviceFactory` |The service factory for this endpoint to use.
This can be supplied using the Spring `<bean class="MyServiceFactory"/>`
syntax
|=======================================================================
+
 

You can find more advanced examples that show how to provide
interceptors, properties and handlers on the CXF
https://cwiki.apache.org/CXF20DOC/JAX-WS+Configuration[JAX-WS
Configuration page].

*NOTE* +
You can use cxf:properties to set the camel-cxf endpoint's dataFormat
and setDefaultBus properties from spring configuration file.

xml<cxf:cxfEndpoint id="testEndpoint"
address="http://localhost:9000/router"
serviceClass="org.apache.camel.component.cxf.HelloService"
endpointName="s:PortName" serviceName="s:ServiceName"
xmlns:s="http://www.example.com/test"> <cxf:properties> <entry
key="dataFormat" value="MESSAGE"/> <entry key="setDefaultBus"
value="true"/> </cxf:properties> </cxf:cxfEndpoint>

[[BookComponentAppendix-ConfiguringtheCXFEndpointswithApacheAriesBlueprint.]]
Configuring the CXF Endpoints with Apache Aries Blueprint.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since camel 2.8 there is support for utilizing aries blueprint
dependency injection for your CXF endpoints. +
The schema utilized is very similar to the spring schema so the
transition is fairly transparent.

Example

xml<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
xmlns:camel-cxf="http://camel.apache.org/schema/blueprint/cxf"
xmlns:cxfcore="http://cxf.apache.org/blueprint/core"
xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0
https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd">
<camel-cxf:cxfEndpoint id="routerEndpoint"
address="http://localhost:9001/router"
serviceClass="org.apache.servicemix.examples.cxf.HelloWorld">
<camel-cxf:properties> <entry key="dataFormat" value="MESSAGE"/>
</camel-cxf:properties> </camel-cxf:cxfEndpoint> <camel-cxf:cxfEndpoint
id="serviceEndpoint"
address="http://localhost:9000/SoapContext/SoapPort"
serviceClass="org.apache.servicemix.examples.cxf.HelloWorld">
</camel-cxf:cxfEndpoint> <camelContext
xmlns="http://camel.apache.org/schema/blueprint"> <route> <from
uri="routerEndpoint"/> <to uri="log:request"/> </route> </camelContext>
</blueprint>

Currently the endpoint element is the first supported CXF
namespacehandler.

You can also use the bean references just as in spring

xml<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
xmlns:jaxws="http://cxf.apache.org/blueprint/jaxws"
xmlns:cxf="http://cxf.apache.org/blueprint/core"
xmlns:camel="http://camel.apache.org/schema/blueprint"
xmlns:camelcxf="http://camel.apache.org/schema/blueprint/cxf"
xsi:schemaLocation=" http://www.osgi.org/xmlns/blueprint/v1.0.0
https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
http://cxf.apache.org/blueprint/jaxws
http://cxf.apache.org/schemas/blueprint/jaxws.xsd
http://cxf.apache.org/blueprint/core
http://cxf.apache.org/schemas/blueprint/core.xsd ">
<camelcxf:cxfEndpoint id="reportIncident"
address="/camel-example-cxf-blueprint/webservices/incident"
wsdlURL="META-INF/wsdl/report_incident.wsdl"
serviceClass="org.apache.camel.example.reportincident.ReportIncidentEndpoint">
</camelcxf:cxfEndpoint> <bean id="reportIncidentRoutes"
class="org.apache.camel.example.reportincident.ReportIncidentRoutes" />
<camelContext xmlns="http://camel.apache.org/schema/blueprint">
<routeBuilder ref="reportIncidentRoutes"/> </camelContext> </blueprint>

[[BookComponentAppendix-Howtomakethecamel-cxfcomponentuselog4jinsteadofjava.util.logging]]
How to make the camel-cxf component use log4j instead of
java.util.logging
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CXF's default logger is `java.util.logging`. If you want to change it to
log4j, proceed as follows. Create a file, in the classpath, named
`META-INF/cxf/org.apache.cxf.logger`. This file should contain the
fully-qualified name of the class,
`org.apache.cxf.common.logging.Log4jLogger`, with no comments, on a
single line.

[[BookComponentAppendix-Howtoletcamel-cxfresponsemessagewithxmlstartdocument]]
How to let camel-cxf response message with xml start document
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are using some SOAP client such as PHP, you will get this kind of
error, because CXF doesn't add the XML start document "<?xml
version="1.0" encoding="utf-8"?>"

Error:sendSms: SoapFault exception: [Client] looks like we got no XML
document in [...]

To resolved this issue, you just need to tell StaxOutInterceptor to
write the XML start document for
you.\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/WriteXmlDeclarationInterceptor.java}You
can add a customer interceptor like this and configure it into you
camel-cxf
endpont\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/GreeterEndpointsRouterContext.xml}Or
adding a message header for it like this if you are using *Camel 2.4*.

// set up the response context which force start document Map<String,
Object> map = new HashMap<String, Object>();
map.put("org.apache.cxf.stax.force-start-document", Boolean.TRUE);
exchange.getOut().setHeader(Client.RESPONSE_CONTEXT, map);

[[BookComponentAppendix-HowtooverridetheCXFproduceraddressfrommessageheader]]
How to override the CXF producer address from message header
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `camel-cxf` producer supports to override the services address by
setting the message with the key of "CamelDestinationOverrideUrl".

// set up the service address from the message header to override the
setting of CXF endpoint
exchange.getIn().setHeader(Exchange.DESTINATION_OVERRIDE_URL,
constant(getServiceAddress()));

[[BookComponentAppendix-Howtoconsumeamessagefromacamel-cxfendpointinPOJOdataformat]]
How to consume a message from a camel-cxf endpoint in POJO data format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `camel-cxf` endpoint consumer POJO data format is based on the
http://cwiki.apache.org/CXF20DOC/invokers.html[cxf invoker], so the
message header has a property with the name of
`CxfConstants.OPERATION_NAME` and the message body is a list of the SEI
method
parameters.\{snippet:id=personProcessor|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/wsdl_first/PersonProcessor.java}

[[BookComponentAppendix-Howtopreparethemessageforthecamel-cxfendpointinPOJOdataformat]]
How to prepare the message for the camel-cxf endpoint in POJO data
format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `camel-cxf` endpoint producer is based on the
https://svn.apache.org/repos/asf/cxf/trunk/api/src/main/java/org/apache/cxf/endpoint/Client.java[cxf
client API]. First you need to specify the operation name in the message
header, then add the method parameters to a list, and initialize the
message with this parameter list. The response message's body is a
messageContentsList, you can get the result from that list.

If you don't specify the operation name in the message header,
`CxfProducer` will try to use the `defaultOperationName `from
`CxfEndpoint`, if there is no `defaultOperationName` set on
`CxfEndpoint`, it will pickup the first operationName from the Operation
list.

If you want to get the object array from the message body, you can get
the body using `message.getbody(Object[].class)`, as
follows:\{snippet:id=sending|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfProducerRouterTest.java}

[[BookComponentAppendix-Howtodealwiththemessageforacamel-cxfendpointinPAYLOADdataformat]]
How to deal with the message for a camel-cxf endpoint in PAYLOAD data
format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`PAYLOAD` means that you process the payload message from the SOAP
envelope. You can use the `Header.HEADER_LIST` as the key to set or get
the SOAP headers and use the `List<Element>` to set or get SOAP body
elements. +
`Message.getBody()` will return an
`org.apache.camel.component.cxf.CxfPayload` object, which has getters
for SOAP message headers and Body elements. This change enables
decoupling the native CXF message from the Camel
message.\{snippet:id=payload|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfConsumerPayloadTest.java}

[[BookComponentAppendix-HowtogetandsetSOAPheadersinPOJOmode]]
How to get and set SOAP headers in POJO mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`POJO` means that the data format is a "list of Java objects" when the
Camel-cxf endpoint produces or consumes Camel exchanges. Even though
Camel expose message body as POJOs in this mode, Camel-cxf still
provides access to read and write SOAP headers. However, since CXF
interceptors remove in-band SOAP headers from Header list after they
have been processed, only out-of-band SOAP headers are available to
Camel-cxf in POJO mode.

The following example illustrate how to get/set SOAP headers. Suppose we
have a route that forwards from one Camel-cxf endpoint to another. That
is, SOAP Client -> Camel -> CXF service. We can attach two processors to
obtain/insert SOAP headers at (1) before request goes out to the CXF
service and (2) before response comes back to the SOAP Client. Processor
(1) and (2) in this example are InsertRequestOutHeaderProcessor and
InsertResponseOutHeaderProcessor. Our route looks like
this:\{snippet:id=processSoapHeaderRoute|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest-context.xml}SOAP
headers are propagated to and from Camel Message headers. The Camel
message header name is "org.apache.cxf.headers.Header.list" which is a
constant defined in CXF (org.apache.cxf.headers.Header.HEADER_LIST). The
header value is a List of CXF SoapHeader objects
(org.apache.cxf.binding.soap.SoapHeader). The following snippet is the
InsertResponseOutHeaderProcessor (that insert a new SOAP header in the
response message). The way to access SOAP headers in both
InsertResponseOutHeaderProcessor and InsertRequestOutHeaderProcessor are
actually the same. The only difference between the two processors is
setting the direction of the inserted SOAP
header.\{snippet:id=InsertResponseOutHeaderProcessor|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java}

[[BookComponentAppendix-HowtogetandsetSOAPheadersinPAYLOADmode]]
How to get and set SOAP headers in PAYLOAD mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We've already shown how to access SOAP message (CxfPayload object) in
PAYLOAD mode (See "How to deal with the message for a camel-cxf endpoint
in PAYLOAD data format").

Once you obtain a CxfPayload object, you can invoke the
CxfPayload.getHeaders() method that returns a List of DOM Elements (SOAP
headers).\{snippet:id=payload|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfPayLoadSoapHeaderTest.java}Since
Camel 2.16.0, you can also use the same way as described in sub-chapter
"How to get and set SOAP headers in POJO mode" to set or get the SOAP
headers. So, you can use now the
header "org.apache.cxf.headers.Header.list" to get and set a list of
SOAP headers.This does also mean that if you have a route that forwards
from one Camel-cxf endpoint to another (SOAP Client -> Camel -> CXF
service), now also the SOAP headers sent by the SOAP client are
forwarded to the CXF service. If you do not want that these headers are
forwarded you have to remove them in the Camel header
"org.apache.cxf.headers.Header.list".

[[BookComponentAppendix-SOAPheadersarenotavailableinMESSAGEmode]]
SOAP headers are not available in MESSAGE mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SOAP headers are not available in MESSAGE mode as SOAP processing is
skipped.

[[BookComponentAppendix-HowtothrowaSOAPFaultfromCamel]]
How to throw a SOAP Fault from Camel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are using a `camel-cxf` endpoint to consume the SOAP request, you
may need to throw the SOAP Fault from the camel context. +
Basically, you can use the `throwFault` DSL to do that; it works for
`POJO`, `PAYLOAD` and `MESSAGE` data format. +
You can define the soap fault like
this\{snippet:id=FaultDefine|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfCustomizedExceptionTest.java}Then
throw it as you
like\{snippet:id=ThrowFault|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfCustomizedExceptionTest.java}If
your CXF endpoint is working in the `MESSAGE` data format, you could set
the the SOAP Fault message in the message body and set the response code
in the message
header.\{snippet:id=MessageStreamFault|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfMessageStreamExceptionTest.java}Same
for using POJO data format. You can set the SOAPFault on the out body
and also indicate it's a fault by calling
Message.setFault(true):\{snippet:id=onException|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfMessageStreamExceptionTest.java}

[[BookComponentAppendix-Howtopropagateacamel-cxfendpoint'srequestandresponsecontext]]
How to propagate a camel-cxf endpoint's request and response context
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

https://svn.apache.org/repos/asf/cxf/trunk/api/src/main/java/org/apache/cxf/endpoint/Client.java[cxf
client API] provides a way to invoke the operation with request and
response context. If you are using a `camel-cxf` endpoint producer to
invoke the outside web service, you can set the request context and get
response context with the following code:

java CxfExchange exchange =
(CxfExchange)template.send(getJaxwsEndpointUri(), new Processor() \{
public void process(final Exchange exchange) \{ final List<String>
params = new ArrayList<String>(); params.add(TEST_MESSAGE); // Set the
request context to the inMessage Map<String, Object> requestContext =
new HashMap<String, Object>();
requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
JAXWS_SERVER_ADDRESS); exchange.getIn().setBody(params);
exchange.getIn().setHeader(Client.REQUEST_CONTEXT , requestContext);
exchange.getIn().setHeader(CxfConstants.OPERATION_NAME,
GREET_ME_OPERATION); } }); org.apache.camel.Message out =
exchange.getOut(); // The output is an object array, the first element
of the array is the return value Object\[\] output =
out.getBody(Object\[\].class); LOG.info("Received output text: " +
output\[0\]); // Get the response context form outMessage Map<String,
Object> responseContext =
CastUtils.cast((Map)out.getHeader(Client.RESPONSE_CONTEXT));
assertNotNull(responseContext); assertEquals("Get the wrong wsdl
opertion name", "\{http://apache.org/hello_world_soap_http}greetMe",
responseContext.get("javax.xml.ws.wsdl.operation").toString());

[[BookComponentAppendix-AttachmentSupport]]
Attachment Support
^^^^^^^^^^^^^^^^^^

*POJO Mode:* Both SOAP with Attachment and MTOM are supported (see
example in Payload Mode for enabling MTOM).  However, SOAP with
Attachment is not tested.  Since attachments are marshalled and
unmarshalled into POJOs, users typically do not need to deal with the
attachment themself.  Attachments are propagated to Camel message's
attachments if the MTOM is not enabled, since 2.12.3.  So, it is
possible to retreive attachments by Camel Message API

DataHandler Message.getAttachment(String id)

.

*Payload Mode:* MTOM is supported since 2.1. Attachments can be
retrieved by Camel Message APIs mentioned above. SOAP with Attachment
(SwA) is supported and attachments can be retrieved since 2.5. SwA is
the default (same as setting the CXF endpoint property "mtom-enabled" to
false). 

To enable MTOM, set the CXF endpoint property "mtom-enabled" to _true_.
(I believe you can only do it with
Spring.)\{snippet:id=enableMtom|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/mtom/CxfMtomRouterPayloadModeTest-context.xml}You
can produce a Camel message with attachment to send to a CXF endpoint in
Payload
mode.\{snippet:id=producer|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/mtom/CxfMtomProducerPayloadModeTest.java}You
can also consume a Camel message received from a CXF endpoint in Payload
mode.\{snippet:id=consumer|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/mtom/CxfMtomConsumerPayloadModeTest.java}*Message
Mode:* Attachments are not supported as it does not process the message
at all.

*CXF_MESSAGE Mode*: MTOM is supported, and Attachments can be retrieved
by Camel Message APIs mentioned above. Note that when receiving a
multipart (i.e. MTOM) message the default SOAPMessage to String
converter will provide the complete multipart payload on the body. If
you require just the SOAP XML as a String, you can set the message body
with message.getSOAPPart(), and Camel convert can do the rest of work
for you.

[[BookComponentAppendix-StreamingSupportinPAYLOADmode]]
Streaming Support in PAYLOAD mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In 2.8.2, the camel-cxf component now supports streaming of incoming
messages when using PAYLOAD mode. Previously, the incoming messages
would have been completely DOM parsed. For large messages, this is time
consuming and uses a significant amount of memory. Starting in 2.8.2,
the incoming messages can remain as a javax.xml.transform.Source while
being routed and, if nothing modifies the payload, can then be directly
streamed out to the target destination. For common "simple proxy" use
cases (example: from("cxf:...").to("cxf:...")), this can provide very
significant performance increases as well as significantly lowered
memory requirements.

However, there are cases where streaming may not be appropriate or
desired. Due to the streaming nature, invalid incoming XML may not be
caught until later in the processing chain. Also, certain actions may
require the message to be DOM parsed anyway (like WS-Security or message
tracing and such) in which case the advantages of the streaming is
limited. At this point, there are two ways to control the streaming:

* Endpoint property: you can add "allowStreaming=false" as an endpoint
property to turn the streaming on/off.

* Component property: the CxfComponent object also has an allowStreaming
property that can set the default for endpoints created from that
component.

Global system property: you can add a system property of
"org.apache.camel.component.cxf.streaming" to "false" to turn if off.
That sets the global default, but setting the endpoint property above
will override this value for that endpoint.

[[BookComponentAppendix-UsingthegenericCXFDispatchmode]]
Using the generic CXF Dispatch mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

From 2.8.0, the camel-cxf component supports the generic
https://cxf.apache.org/docs/jax-ws-dispatch-api.html[CXF dispatch
mode] that can transport messages of arbitrary structures (i.e., not
bound to a specific XML schema). To use this mode, you simply omit
specifying the wsdlURL and serviceClass attributes of the CXF endpoint.

xml<cxf:cxfEndpoint id="testEndpoint"
address="http://localhost:9000/SoapContext/SoapAnyPort">
<cxf:properties> <entry key="dataFormat" value="PAYLOAD"/>
</cxf:properties> </cxf:cxfEndpoint>

It is noted that the default CXF dispatch client does not send a
specific SOAPAction header. Therefore, when the target service requires
a specific SOAPAction value, it is supplied in the Camel header using
the key SOAPAction (case-insensitive).

 

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-CXFBeanComponent]]
CXF Bean Component
~~~~~~~~~~~~~~~~~~

The *cxfbean:* component allows other Camel endpoints to send exchange
and invoke Web service bean objects. *Currently, it only supports JAX-RS
and JAX-WS (new to Camel 2.1) annotated service beans.*

`CxfBeanEndpoint` is a `ProcessorEndpoint` so it has no consumers. It
works similarly to a Bean component.

Maven users need to add the following dependency to their pom.xml to use
the CXF Bean Component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-cxf</artifactId> <!-- use the same version as your
Camel core version: --> <version>x.x.x</version> </dependency>

[[BookComponentAppendix-URIformat.11]]
URI format
^^^^^^^^^^

cxfbean:serviceBeanRef

Where *serviceBeanRef* is a registry key to look up the service bean
object. If `serviceBeanRef` references a `List` object, elements of the
`List` are the service bean objects accepted by the endpoint.

[[BookComponentAppendix-Options.8]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|=======================================================================
|Name |Description |Example |Required? |Default Value
|`bus` |CXF bus reference specified by the `#` notation. The referenced
object must be an instance of `org.apache.cxf.Bus`. |`bus=#busName` |No
|Default bus created by CXF Bus Factory

|`cxfBeanBinding` |CXF bean binding specified by the `#` notation. The
referenced object must be an instance of
`org.apache.camel.component.cxf.cxfbean.CxfBeanBinding`.
|`cxfBinding=#bindingName` |No |`DefaultCxfBeanBinding`

|`headerFilterStrategy` |Header filter strategy specified by the `#`
notation. The referenced object must be an instance of
`org.apache.camel.spi.HeaderFilterStrategy`.
|`headerFilterStrategy=#strategyName` |No |`CxfHeaderFilterStrategy`

|`populateFromClass` + |Since 2.3, the wsdlLocation annotated in the
POJO is ignored (by default) unless this option is set to  `false.`
Prior to 2.3, the wsdlLocation annotated in the POJO is always honored
and it is not possible to ignore. + |`true`, `false` |No |`true`

|`providers` |Since 2.5, setting the providers for the CXFRS endpoint.
|`providers=#providerRef1,#providerRef2` |No |`null`

|`setDefaultBus` |Will set the default bus when CXF endpoint create a
bus by itself. |`true`, `false` |No |`false`
|=======================================================================

[[BookComponentAppendix-Headers]]
Headers
^^^^^^^

confluenceTableSmall

[width="99%",cols="16%,14%,14%,14%,14%,14%,14%",options="header",]
|=======================================================================
|Name |Description |Type |Required? |Default Value |In/Out |Examples
|`CamelHttpCharacterEncoding` (before 2.0-m2:
`CamelCxfBeanCharacterEncoding`) |Character encoding |`String` |No |None
|In |ISO-8859-1

|`CamelContentType` (before 2.0-m2: `CamelCxfBeanContentType`) |Content
type |`String` |No |**/** |In |`text/xml`

|CamelHttpBaseUri +
(2.0-m3 and before: `CamelCxfBeanRequestBasePath`) |The value of this
header will be set in the CXF message as the `Message.BASE_PATH`
property. It is needed by CXF JAX-RS processing. Basically, it is the
scheme, host and port portion of the request URI. |`String` |Yes |The
Endpoint URI of the source endpoint in the Camel exchange |In
|http://localhost:9000

|`CamelHttpPath` (before 2.0-m2: `CamelCxfBeanRequestPat`h) |Request
URI's path |`String` |Yes |None |In |`consumer/123`

|`CamelHttpMethod` (before 2.0-m2: `CamelCxfBeanVerb`) |RESTful request
verb |`String` |Yes |None |In |`GET`, `PUT`, `POST`, `DELETE`

|`CamelHttpResponseCode` |HTTP response code |`Integer` |No + |None
|Out + |200 +
|=======================================================================

Currently, the CXF Bean component has (only) been tested with the
link:jetty.html[Jetty component]. It understands headers from
link:jetty.html[Jetty component] without requiring conversion.

[[BookComponentAppendix-AWorkingSample]]
A Working Sample
^^^^^^^^^^^^^^^^

This sample shows how to create a route that starts an embedded Jetty
HTTP server. The route sends requests to a CXF Bean and invokes a JAX-RS
annotated service.

First, create a route as follows: The `from` endpoint is a Jetty HTTP
endpoint that is listening on port 9000. Notice that the
`matchOnUriPrefix` option must be set to `true` because the RESTful
request URI will not exactly match the endpoint's URI
http:­//localhost:9000.

\{snippet:id=routeDefinition|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/cxfbean/CxfBeanTest-context.xml}

The `to` endpoint is a CXF Bean with bean name `customerServiceBean`.
The name will be looked up from the registry. Next, we make sure our
service bean is available in Spring registry. We create a bean
definition in the Spring configuration. In this example, we create a
List of service beans (of one element). We could have created just a
single bean without a List.

\{snippet:id=beanDefinition|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/cxfbean/CxfBeanTest-context.xml}

That's it. Once the route is started, the web service is ready for
business. A HTTP client can make a request and receive response.

[[BookComponentAppendix-CXFRSComponent]]
CXFRS Component
~~~~~~~~~~~~~~~

When using CXF as a consumer, the link:cxf-bean-component.html[CXF Bean
Component] allows you to factor out how message payloads are received
from their processing as a RESTful or SOAP web service. This has the
potential of using a multitude of transports to consume web services.
The bean component's configuration is also simpler and provides the
fastest method to implement web services using Camel and CXF.

The *cxfrs:* component provides integration with
http://cxf.apache.org[Apache CXF] for connecting to JAX-RS 1.1 and 2.0
services hosted in CXF.

Maven users will need to add the following dependency to their pom.xml
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-cxf</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.12]]
URI format
^^^^^^^^^^

javacxfrs://address?options

Where *address* represents the CXF endpoint's address

javacxfrs:bean:rsEndpoint

Where *rsEndpoint* represents the spring bean's name which presents the
CXFRS client or server

For either style above, you can append options to the URI as follows:

javacxfrs:bean:cxfEndpoint?resourceClasses=org.apache.camel.rs.Example

[[BookComponentAppendix-Options.9]]
Options
^^^^^^^

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|=======================================================================
|Name |Description |Example |Required? |default value
|`resourceClasses` |The resource classes which you want to export as
REST service. Multiple classes can be separated by comma.
|`resourceClasses=org.apache.camel.rs.Example1,` +
`org.apache.camel.rs.Exchange2` |No |_None_

|`resourceClass` |*Deprecated*: Use `resourceClasses` The resource class
which you want to export as REST service.
|`resourceClass =org.apache.camel.rs.Example1` |No |_None_

|`httpClientAPI` |*new to Camel 2.1* If it is true, the CxfRsProducer
will use the HttpClientAPI to invoke the service +
If it is false, the CxfRsProducer will use the ProxyClientAPI to invoke
the service |httpClientAPI=true |No |_true_

|`synchronous` a|
This option will let you decide to use sync or async API to do the
underlying work. The default value is false which means it will try to
use async API by default.

This option is available as of *2.5* for CxfRsConsumer and as of *2.19*
for CxfRsProducer.

 |synchronous=true |No |false

|`throwExceptionOnFailure` |New in 2.6, this option tells the
CxfRsProducer to inspect return codes and will generate an Exception if
the return code is larger than 207. |throwExceptionOnFailure=true |No
|true

|`maxClientCacheSize` |New in 2.6, you can set a IN message header
CamelDestinationOverrideUrl to dynamically override the target
destination Web Service or REST Service defined in your routes.  The
implementation caches CXF clients or ClientFactoryBean in CxfProvider
and CxfRsProvider.  This option allows you to configure the maximum size
of the cache. |maxClientCacheSize=5 |No |10

|`setDefaultBus` |New in 2.9.0. *deprecated* use defaultBus option from
Camel 2.16 onwards. Will set the default bus when CXF endpoint create a
bus by itself |`setDefaultBus=true` |No |_false_

|`defaultBus` |*Camel 2.16:* Will set the default bus when CXF endpoint
create a bus by itself |`defaultBus=true` |No |_false_

|`bus` |New in 2.9.0. A default bus created by CXF Bus Factory. Use `#`
notation to reference a bus object from the registry. The referenced
object must be an instance of `org.apache.cxf.Bus`. |`bus=#busName` |No
|_None_

|`bindingStyle` a|
*As of 2.11*. Sets how requests and responses will be mapped to/from
Camel. Two values are possible:

* `SimpleConsumer` => see the link:cxfrs.html[Consuming a REST Request
with the Simple Binding Style] below.
* `Default` => the default style. For consumers this passes on a
`MessageContentsList` to the route, requiring low-level processing in
the route.
* Custom => allows you to specify a custom binding through the `binding`
option.

 |`bindingStyle=SimpleConsumer` |No |_Default_

|`binding` |Allows you to specify a custom `CxfRsBinding` implementation
to perform low-level processing of the raw CXF request and response
objects. The implementation must be bound in the Camel registry, and you
must use the hash (#) notation to refer to it. |`binding=#myBinding` |No
|`DefaultCxfRsBinding`

|`providers` |**Since Camel 2.12.2** set custom JAX-RS providers list to
the CxfRs endpoint. |`providers=#MyProviders` |No |_None_

|`schemaLocations` |**Since Camel 2.12.2** Sets the locations of the
schemas which can be used to validate the incoming XML or JAXB-driven
JSON. |`schemaLocations=#MySchemaLocations` |No |_None_

|`features` |**Since Camel 2.12.3** Set the feature list to the CxfRs
endpoint. |`features=#MyFeatures` |No |_None_

|`properties` |**Since Camel 2.12.4** Set the properties to the CxfRs
endpoint. |`properties=#MyProperties` |No |_None_

|`inInterceptors` |**Since Camel 2.12.4** Set the inInterceptors to the
CxfRs endpoint. |`inInterceptors=#MyInterceptors` |No |_None_

|`outInterceptors` |**Since Camel 2.12.4** Set the outInterceptor to the
CxfRs endpoint. |`outInterceptors=#MyInterceptors` |No |_None_

|`inFaultInterceptors` |**Since Camel 2.12.4** Set the
inFaultInterceptors to the CxfRs endpoint.
|`inFaultInterceptors=#MyInterceptors` |No |_None_

|`outFaultIntercetpros` |**Since Camel 2.12.4** Set the
outFaultInterceptors to the CxfRs endpoint.
|`outFaultInterceptors=#MyInterceptors` |No |_None_

|`continuationTimeout` |*Since* **Camel 2.14.0 **This option is used to
set the CXF continuation timeout which could be used in CxfConsumer by
default when the CXF server is using Jetty or Servlet transport.
(Before **Camel 2.14.0**, CxfConsumer just set the continuation timeout
to be 0, which means the continuation suspend operation never timeout.)
|`continuationTimeout=800000` |No |_30000_

|`ignoreDeleteMethodMessageBody` |*Since Camel 2.14.1* This option is
used to tell CxfRsProducer to ignore the message body of the DELETE
method when using HTTP API. |`ignoreDeleteMethodMessageBody=true` |No
|_false_

|`modelRef` a|
*Since Camel 2.14.2* This option is used to specify the
http://cxf.apache.org/docs/jax-rs-advanced-features.html#JAX-RSAdvancedFeatures-RESTfulserviceswithoutannotations[model
file] which is useful for the resource class without annotation.

*Since Camel 2.15* This option can point to a model file without
specifying a service class for emulating document-only endpoints


|`modelRef=`http://classpath/org/apache/camel/component/cxf/jaxrs/CustomerServiceModel.xml[classpath:/CustomerServiceModel.xml]
|No |_None_

|`performInvocation` |*Since Camel 2.15* When the option is true, camel
will perform the invocation of the resource class instance and put the
response object into the exchange for further processing.
|`performInvocation= true` |No |_false_

|`propagateContexts` |*Since Camel 2.15* When the option is true, JAXRS
https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/UriInfo.html[UriInfo],
https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/HttpHeaders.html[HttpHeaders],
https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/Request.html[Request]
and
https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/SecurityContext.html[SecurityContext]
contexts will be available to custom CXFRS processors as typed Camel
exchange properties. These contexts can be used to analyze the current
requests using JAX-RS API. |  |  | 

|`loggingFeatureEnabled` |This option enables CXF Logging Feature which
writes inbound and outbound REST messages to log. |  |No |_false_

|`skipFaultLogging` |This option controls whether the
`PhaseInterceptorChain` skips logging the Fault that it catches. |  |No
|_false_

|`loggingSizeLimit` |To limit the total size of number of bytes the
logger will output when logging feature has been enabled. |  |No |`0`

|`cookieHandler` |Since *Camel 2.19.0* Configure a cookie handler to
maintain a HTTP session |`cookieHandler=#exchangeCookieHandler` |No
|_None_
|=======================================================================

You can also configure the CXF REST endpoint through the spring
configuration. Since there are lots of difference between the CXF REST
client and CXF REST Server, we provide different configuration for
them. +
Please check out the
http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd[schema
file] and https://cwiki.apache.org/CXF20DOC/JAX-RS[CXF JAX-RS
documentation] for more information.

[[BookComponentAppendix-HowtoconfiguretheRESTendpointinCamel]]
How to configure the REST endpoint in Camel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In
http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd[camel-cxf
schema file], there are two elements for the REST endpoint definition.
*cxf:rsServer* for REST consumer, *cxf:rsClient* for REST producer. +
You can find a Camel REST service route configuration example
here.\{snippet:id=cxfRsExample|lang=xml|url=camel/trunk/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/jaxrs/CxfRsSpringRouter.xml}

[[BookComponentAppendix-HowtooverridetheCXFproduceraddressfrommessageheader.1]]
How to override the CXF producer address from message header
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `camel-cxfrs` producer supports to override the services address by
setting the message with the key of "CamelDestinationOverrideUrl".

// set up the service address from the message header to override the
setting of CXF endpoint
exchange.getIn().setHeader(Exchange.DESTINATION_OVERRIDE_URL,
constant(getServiceAddress()));

[[BookComponentAppendix-ConsumingaRESTRequest-SimpleBindingStyle]]
Consuming a REST Request - Simple Binding Style
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.11*

The `Default` binding style is rather low-level, requiring the user to
manually process the `MessageContentsList` object coming into the route.
Thus, it tightly couples the route logic with the method signature and
parameter indices of the JAX-RS operation. Somewhat inelegant, difficult
and error-prone.

In contrast, the `SimpleConsumer` binding style performs the following
mappings, in order to *make the request data more accessible* to you
within the Camel Message:

* JAX-RS Parameters (@HeaderParam, @QueryParam, etc.) are injected as IN
message headers. The header name matches the value of the annotation.
* The request entity (POJO or other type) becomes the IN message body.
If a single entity cannot be identified in the JAX-RS method signature,
it falls back to the original `MessageContentsList`.
* Binary `@Multipart` body parts become IN message attachments,
supporting `DataHandler`, `InputStream`, `DataSource` and CXF's
`Attachment` class.
* Non-binary `@Multipart` body parts are mapped as IN message headers.
The header name matches the Body Part name.

Additionally, the following rules apply to the *Response mapping*:

* If the message body type is different to `javax.ws.rs.core.Response`
(user-built response), a new `Response` is created and the message body
is set as the entity (so long it's not null). The response status code
is taken from the `Exchange.HTTP_RESPONSE_CODE` header, or defaults to
200 OK if not present.
* If the message body type is equal to `javax.ws.rs.core.Response`, it
means that the user has built a custom response, and therefore it is
respected and it becomes the final response.
* In all cases, Camel headers permitted by custom or default
`HeaderFilterStrategy` are added to the HTTP response.

[[BookComponentAppendix-EnablingtheSimpleBindingStyle]]
Enabling the Simple Binding Style
+++++++++++++++++++++++++++++++++

This binding style can be activated by setting the `bindingStyle`
parameter in the consumer endpoint to value `SimpleConsumer`:

java from("cxfrs:bean:rsServer?bindingStyle=SimpleConsumer")
.to("log:TEST?showAll=true");

[[BookComponentAppendix-Examplesofrequestbindingwithdifferentmethodsignatures]]
Examples of request binding with different method signatures
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Below is a list of method signatures along with the expected result from
the Simple binding.

*`public Response doAction(BusinessObject request);`* +
Request payload is placed in IN message body, replacing the original
MessageContentsList.

*`public Response doAction(BusinessObject request, @HeaderParam("abcd") String abcd, @QueryParam("defg") String defg);`* +
Request payload placed in IN message body, replacing the original
MessageContentsList. Both request params mapped as IN message headers
with names abcd and defg.

*`public Response doAction(@HeaderParam("abcd") String abcd, @QueryParam("defg") String defg);`* +
Both request params mapped as IN message headers with names abcd and
defg. The original MessageContentsList is preserved, even though it only
contains the 2 parameters.

*`public Response doAction(@Multipart(value="body1") BusinessObject request, @Multipart(value="body2") BusinessObject request2);`* +
The first parameter is transferred as a header with name body1, and the
second one is mapped as header body2. The original MessageContentsList
is preserved as the IN message body.

*`public Response doAction(InputStream abcd);`* +
The InputStream is unwrapped from the MessageContentsList and preserved
as the IN message body.

*`public Response doAction(DataHandler abcd);`* +
The DataHandler is unwrapped from the MessageContentsList and preserved
as the IN message body.

[[BookComponentAppendix-MoreexamplesoftheSimpleBindingStyle]]
More examples of the Simple Binding Style
+++++++++++++++++++++++++++++++++++++++++

Given a JAX-RS resource class with this method:

java @POST @Path("/customers/\{type}") public Response
newCustomer(Customer customer, @PathParam("type") String type,
@QueryParam("active") @DefaultValue("true") boolean active) \{ return
null; }

Serviced by the following route:

java from("cxfrs:bean:rsServer?bindingStyle=SimpleConsumer")
.recipientList(simple("direct:$\{header.operationName}"));
from("direct:newCustomer") .log("Request: type=$\{header.type},
active=$\{header.active}, customerData=$\{body}");

The following HTTP request with XML payload (given that the Customer DTO
is JAXB-annotated):

xmlPOST /customers/gold?active=true Payload: <Customer> <fullName>Raul
Kripalani</fullName> <country>Spain</country> <project>Apache
Camel</project> </Customer>

Will print the message:

xmlRequest: type=gold, active=true, customerData=<Customer.toString()
representation>

For more examples on how to process requests and write responses can be
found
https://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/simplebinding/[here].

[[BookComponentAppendix-ConsumingaRESTRequest-DefaultBindingStyle]]
Consuming a REST Request - Default Binding Style
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The https://cwiki.apache.org/CXF20DOC/JAX-RS[CXF JAXRS front end]
implements the https://jsr311.java.net/[JAX-RS (JSR-311) API], so we can
export the resources classes as a REST service. And we leverage the
http://cwiki.apache.org/confluence/display/CXF20DOC/Invokers[CXF Invoker
API] to turn a REST request into a normal Java object method
invocation. +
Unlike the link:restlet.html[Camel Restlet] component, you don't need to
specify the URI template within your endpoint, CXF takes care of the
REST request URI to resource class method mapping according to the
JSR-311 specification. All you need to do in Camel is delegate this
method request to a right processor or endpoint.

Here is an example of a CXFRS
route...\{snippet:id=example|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/CxfRsConsumerTest.java}And
the corresponding resource class used to configure the endpoint...

Note about resource classes

By default, JAX-RS resource classes are *only* used to configure JAX-RS
properties. Methods will *not* be executed during routing of messages to
the endpoint. Instead, it is the responsibility of the route to do all
processing.

Note that starting from Camel 2.15 it is also sufficient to provide an
interface only as opposed to a no-op service implementation class for
the default mode.

Starting from Camel 2.15, if a *performInvocation* option is enabled,
the service implementation will be invoked first, the response will be
set on the Camel exchange and the route execution will continue as
usual. This can be useful for

integrating the existing JAX-RS implementations into Camel routes and
for post-processing JAX-RS Responses in custom processors.

 

\{snippet:id=example|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/testbean/CustomerServiceResource.java}

[[BookComponentAppendix-HowtoinvoketheRESTservicethroughcamel-cxfrsproducer]]
How to invoke the REST service through camel-cxfrs producer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The https://cwiki.apache.org/CXF20DOC/JAX-RS[CXF JAXRS front end]
implements
https://cwiki.apache.org/CXF20DOC/JAX-RS+Client+API#JAX-RSClientAPI-Proxy-basedAPI[a
proxy-based client API], with this API you can invoke the remote REST
service through a proxy. The `camel-cxfrs` producer is based on this
https://cwiki.apache.org/CXF20DOC/JAX-RS+Client+API#JAX-RSClientAPI-Proxy-basedAPI[proxy
API]. +
You just need to specify the operation name in the message header and
prepare the parameter in the message body, the camel-cxfrs producer will
generate right REST request for you.

Here is an
example:\{snippet:id=ProxyExample|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/CxfRsProducerTest.java}The https://cwiki.apache.org/CXF20DOC/JAX-RS[CXF
JAXRS front end] also provides
https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS+Client+API#JAX-RSClientAPI-CXFWebClientAPI[a
http centric client API]. You can also invoke this API from
`camel-cxfrs` producer. You need to specify the
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/Exchange.html#HTTP_PATH[HTTP_PATH]
and
the http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/Exchange.html#HTTP_METHOD[HTTP_METHOD] and
let the producer use the http centric client API by using the URI option
*httpClientAPI* or by setting the message header
http://camel.apache.org/maven/current/camel-cxf/apidocs/org/apache/camel/component/cxf/CxfConstants.html#CAMEL_CXF_RS_USING_HTTP_API[CxfConstants.CAMEL_CXF_RS_USING_HTTP_API].
You can turn the response object to the type class specified with the
message
header http://camel.apache.org/maven/current/camel-cxf/apidocs/org/apache/camel/component/cxf/CxfConstants.html#CAMEL_CXF_RS_RESPONSE_CLASS[CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS].\{snippet:id=HttpExample|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/CxfRsProducerTest.java}From
Camel 2.1, we also support to specify the query parameters from cxfrs
URI for the CXFRS http centric
client.\{snippet:id=QueryExample|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/CxfRsProducerTest.java}To
support the Dynamical routing, you can override the URI's query
parameters by using the CxfConstants.CAMEL_CXF_RS_QUERY_MAP header to
set the parameter map for
it.\{snippet:id=QueryMapExample|lang=java|url=camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/CxfRsProducerTest.java}

[[BookComponentAppendix-DataSetComponent]]
DataSet Component
~~~~~~~~~~~~~~~~~

link:testing.html[Testing] of distributed and asynchronous processing is
notoriously difficult. The link:mock.html[Mock], link:test.html[Test]
and link:dataset.html[DataSet] endpoints work great with the
link:testing.html[Camel Testing Framework] to simplify your unit and
integration testing using
link:enterprise-integration-patterns.html[Enterprise Integration
Patterns] and Camel's large range of link:components.html[Components]
together with the powerful link:bean-integration.html[Bean Integration].

The DataSet component provides a mechanism to easily perform load & soak
testing of your system. It works by allowing you to create
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/dataset/DataSet.html[DataSet
instances] both as a source of messages and as a way to assert that the
data set is received.

Camel will use the link:log.html[throughput logger] when sending
dataset's.

[[BookComponentAppendix-URIformat.13]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
dataset:name[?options]
----

Where *`name`* is used to find the
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/dataset/DataSet.html[DataSet
instance] in the link:registry.html[Registry]

Camel ships with a support implementation of
*`org.apache.camel.component.dataset.DataSet`*, the
*`org.apache.camel.component.dataset.DataSetSupport`* class, that can be
used as a base for implementing your own *`DataSet`*.

Camel also ships with some implementations that can be used for testing:
 

* *`org.apache.camel.component.dataset.SimpleDataSet`*
* **`org.apache.camel.component.dataset.ListDataSet`** +
* **`org.apache.camel.component.dataset.FileDataSet`** +

all of which extend *`DataSetSupport`*.

[[BookComponentAppendix-Options.10]]
Options
^^^^^^^

Option

Default

Description

`produceDelay`

`3`

Allows a delay in ms to be specified, which causes producers to pause in
order to simulate slow producers.

Uses a minimum of *`3ms`* delay. Set to *`-1`* to force no delay at all.

`consumeDelay`

`0`

Allows a delay in ms to be specified, which causes consumers to pause in
order to simulate slow consumers.

`preloadSize`

`0`

Sets how many messages should be pre-loaded (sent) before the route
completes its initialization.

`initialDelay`

`1000`

*Camel 2.1:* Time period in milliseconds to wait before starting sending
messages.

`minRate`

`0`

Wait until the *`DataSet`* contains at least this number of messages.

`dataSetIndex`

`lenient`

*Camel 2.17:* Controls the behavior of the *`CamelDataSetIndex`* header.

The supported values are:

* *`strict`*
* *`lenient`*
* *`off`*

The default behavior prior to *Camel 2.17* can be restored using
*`dataSetIndex=strict`*.

Client Type

`dataSetIndex` Value

*`CamelDataSetIndex`* Header Behavior

Consumer +
 +

`strict`

The header will always be set.

`lenient`

`off`

The header will NOT be set.

Producer +
 +

`strict`

The header must be present and the value of the header will be verified.

`lenient`

If the header is present, the value of the header will be verified. If
the header is not present, it will be set.

`off`

If the header is present, the value of the header will not be verified.
If the header is not present, it will not be set.

You can append query options to the URI in the following format:
*`?option=value&option=value&...`*

[[BookComponentAppendix-ConfiguringDataSet]]
Configuring DataSet
^^^^^^^^^^^^^^^^^^^

Camel will lookup in the link:registry.html[Registry] for a bean
implementing the *`DataSet`* interface. So you can register your
own *`DataSet`* as:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="myDataSet" class="com.mycompany.MyDataSet">
  <property name="size" value="100"/>
</bean>
----

[[BookComponentAppendix-Example.1]]
Example
^^^^^^^

For example, to test that a set of messages are sent to a queue and then
consumed from the queue without losing any messages:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// Send the dataset to a queue
from("dataset:foo")
  .to("activemq:SomeQueue");

// Now lets test that the messages are consumed correctly
from("activemq:SomeQueue")
  .to("dataset:foo");
----

The above would look in the link:registry.html[Registry] to find
the *`foo`* *`DataSet`* instance which is used to create the messages.
Then you create a *DataSet* implementation, such as using the
*`SimpleDataSet`* as described below, configuring things like how big
the data set is and what the messages look like etc.  

 

[[BookComponentAppendix-DataSetSupport(abstractclass)]]
*`DataSetSupport`* (abstract class)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *`DataSetSupport`* abstract class is a nice starting point for new
DataSets, and provides some useful features to derived classes.

[[BookComponentAppendix-PropertiesonDataSetSupport]]
Properties on `DataSetSupport`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Property |Type |Default |Description
|`defaultHeaders` |`Map<String,Object>` |`null` a|
Specifies the default message body.

For *`SimpleDataSet`* it is a constant payload; though if you want to
create custom payloads per message, create your own derivation of
*`DataSetSupport`*.

|`outputTransformer` |`org.apache.camel.Processor` |null | 

|`size` |`long` |`10` |Specifies how many messages to send/consume.

|`reportCount` |`long` |`-1` a|
Specifies the number of messages to be received before reporting
progress. Useful for showing progress of a large load test.

If < 0, then **`size`** */ 5*

If == 0 then **`size`** 

Else set to **`reportCount`** value.

|=======================================================================

[[BookComponentAppendix-SimpleDataSet]]
`SimpleDataSet`
^^^^^^^^^^^^^^^

The *`SimpleDataSet`* extends *`DataSetSupport`*, and adds a default
body.

[[BookComponentAppendix-AdditionalPropertiesonSimpleDataSet]]
Additional Properties on SimpleDataSet
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Property |Type |Default |Description
|`defaultBody` |`Object` |`<hello>world!</hello>` |Specifies the default
message body. By default, the *`SimpleDataSet`* produces the same
constant payload for each exchange. If you want to customize the payload
for each exchange, create a Camel *`Processor`* and configure the
*`SimpleDataSet`* to use it by setting the *`outputTransformer`*
property.
|=======================================================================

[[BookComponentAppendix-ListDataSet(Camel2.17)]]
`ListDataSet (Camel 2.17)`
^^^^^^^^^^^^^^^^^^^^^^^^^^

The *`ListDataSet`* extends *`DataSetSupport`*, and adds a list of
default bodies.

[[BookComponentAppendix-AdditionalPropertiesonListDataSet]]
Additional Properties on ListDataSet
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Property |Type |Default |Description
|`defaultBodies` |`List<Object>` |`empty LinkedList<Object>` |Specifies
the default message body. By default, the **`ListDataSet`** selects a
constant payload from the list of *`defaultBodies`* using the
*`CamelDataSetIndex`*. If you want to customize the payload, create a
Camel *`Processor`* and configure the **`ListDataSet`** to use it by
setting the **`outputTransformer`** property.

|`size` |`long` |the size of the *`defaultBodies`* list |Specifies how
many messages to send/consume. This value can be different from the size
of the *`defaultBodies`* list. If the value is less than the size of the
*`defaultBodies`* list, some of the list elements will not be used. If
the value is greater than the size of the *`defaultBodies`* list, the
payload for the exchange will be selected using the modulus of the
*`CamelDataSetIndex`* and the size of the *`defaultBodies`* list (i.e.
`CamelDataSetIndex % defaultBodies.size()` )
|=======================================================================

[[BookComponentAppendix-FileDataSet(Camel2.17)]]
`FileDataSet (Camel 2.17)`
^^^^^^^^^^^^^^^^^^^^^^^^^^

The *`SimpleDataSet`* extends *`ListDataSet`*, and adds support for
loading the bodies from a file.

[[BookComponentAppendix-AdditionalPropertiesonFileDataSet]]
Additional Properties on `FileDataSet`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Property |Type |Default |Description
|`sourceFile` |`File` |null |Specifies the source file for payloads

|`delimiter` |`String` |\z |Specifies the delimiter pattern used by a
*`java.util.Scanner`* to split the file into multiple payloads.
|=======================================================================

[[BookComponentAppendix-SeeAlso.5]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:spring-testing.html[Spring Testing]

[[BookComponentAppendix-Db4oComponent]]
Db4o Component
~~~~~~~~~~~~~~

*Available as of Camel 2.5*

The *db4o:* component allows you to work with http://www.db4o.com[db4o]
NoSQL database. The camel-db4o library is provided by the
http://code.google.com/p/camel-extra/[Camel Extra] project which hosts
all *GPL related components for Camel.

[[BookComponentAppendix-Sendingtotheendpoint]]
Sending to the endpoint
^^^^^^^^^^^^^^^^^^^^^^^

Sending POJO object to the db4o endpoint adds and saves object into the
database. The body of the message is assumed to be a POJO that has to be
saved into the db40 database store.

[[BookComponentAppendix-Consumingfromtheendpoint]]
Consuming from the endpoint
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Consuming messages removes (or updates) POJO objects in the database.
This allows you to use a Db4o datastore as a logical queue; consumers
take messages from the queue and then delete them to logically remove
them from the queue.

If you do not wish to delete the object when it has been processed, you
can specify `consumeDelete=false` on the URI. This will result in the
POJO being processed each poll.

[[BookComponentAppendix-URIformat.14]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
db4o:className[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.11]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`consumeDelete` |`true` |Option for `Db4oConsumer` only. Specifies
whether or not the entity is deleted after it is consumed.

|`consumer.delay` |`500` |Option for consumer only. Delay in millis
between each poll.

|`consumer.initialDelay` |`1000` |Option for consumer only. Millis
before polling starts.

|`consumer.userFixedDelay` |`false` |Option for consumer only. Set to
`true` to use fixed delay between polls, otherwise fixed rate is used.
See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.
|=======================================================================

[[BookComponentAppendix-SeeAlso.6]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-DirectComponent]]
Direct Component
~~~~~~~~~~~~~~~~

The *`direct:`* component provides direct, synchronous invocation of any
consumers when a producer sends a message exchange. This endpoint can be
used to connect existing routes in the *same* camel context.

[Tip]
====
 **Asynchronous**

The link:seda.html[SEDA] component provides asynchronous invocation of
any consumers when a producer sends a message exchange.

====

[Tip]
====
 **Connection to other camel contexts**

The link:vm.html[VM] component provides connections between Camel
contexts as long they run in the same *JVM*.

====

[[BookComponentAppendix-URIformat.15]]
URI format
^^^^^^^^^^

[source,brush:,text;,gutter:,false;,theme:,Default]
----
direct:someName[?options]
----

Where *`someName`* can be any string that uniquely identifies the
endpoint.

[[BookComponentAppendix-Options.12]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`allowMultipleConsumers` |`true` a|
*@deprecated *

If set to *`false`*, then when a second consumer is started on the
endpoint, an *`IllegalStateException`* is thrown.

*Will be removed in Camel 2.1:* Direct endpoint does not support
multiple consumers.

|`block` |`false` |*Camel 2.11.1:* If sending a message to a direct
endpoint which has no active consumer, the producer will block
for *`timeout`* milliseconds waiting for a consumer to become active.

|`timeout` |`30000` |*Camel 2.11.1:* The timeout value, in milliseconds,
to block, when enabled, for an active consumer.

|`failIfNoConsumers` |`true` |*Camel 2.16.0*: Indicates whether the
producer should fail by throwing an exception when sending to
a *`direct`* endpoint with no active consumers.
|=======================================================================

You can append query options to the URI in the following
format: *`?option=value&option=value&...`*

 

[[BookComponentAppendix-Samples.1]]
Samples
^^^^^^^

In the route below we use the direct component to link the two routes
together:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:queue:order.in")
    .to("bean:orderServer?method=validate")
    .to("direct:processOrder?block=true&timeout=5000");

from("direct:processOrder")
    .to("bean:orderService?method=process")
    .to("activemq:queue:order.out");
----

And the sample using spring DSL:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
   <route>
     <from uri="activemq:queue:order.in"/>
     <to uri="bean:orderService?method=validate"/>
     <to uri="direct:processOrder?failIfNoConsumers=false"/>
  </route>

  <route>
     <from uri="direct:processOrder"/>
     <to uri="bean:orderService?method=process"/>
     <to uri="activemq:queue:order.out"/>
  </route>    
----

See also samples from the link:seda.html[SEDA] component, how they can
be used together.

[[BookComponentAppendix-SeeAlso.7]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:seda.html[SEDA]
* link:vm.html[VM]

[[BookComponentAppendix-DNS]]
DNS
~~~

*Available as of Camel 2.7*

This is an additional component for Camel to run DNS queries, using
DNSJava. The component is a thin layer on top of
http://www.xbill.org/dnsjava/[DNSJava]. +
The component offers the following operations:

* ip, to resolve a domain by its ip
* lookup, to lookup information about the domain
* dig, to run DNS queries

[Info]
====
 **Requires SUN JVM**

The DNSJava library requires running on the SUN JVM. +
If you use Apache ServiceMix or Apache Karaf, you'll need to adjust the
`etc/jre.properties` file, to add `sun.net.spi.nameservice` to the list
of Java platform packages exported. The server will need restarting
before this change takes effect.

====

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-dns</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.16]]
URI format
^^^^^^^^^^

The URI scheme for a DNS component is as follows

[source,brush:,java;,gutter:,false;,theme:,Default]
----
dns://operation[?options]
----

This component only supports producers.

[[BookComponentAppendix-Options.13]]
Options
^^^^^^^

None.

[[BookComponentAppendix-Headers.1]]
Headers
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Header |Type |Operations |Description
|dns.domain |String |ip |The domain name. Mandatory.

|dns.name |String |lookup |The name to lookup. Mandatory.

|dns.type |  |lookup, dig |The type of the lookup. Should match the
values of `org.xbill.dns.Type`. Optional.

|dns.class |  |lookup, dig |The DNS class of the lookup. Should match
the values of `org.xbill.dns.DClass`. Optional.

|dns.query |String |dig |The query itself. Mandatory.

|dns.server |String |dig |The server in particular for the query. If
none is given, the default one specified by the OS will be used.
Optional.
|=======================================================================

[[BookComponentAppendix-Examples.1]]
Examples
^^^^^^^^

[[BookComponentAppendix-IPlookup]]
IP lookup
+++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        <route id="IPCheck">
            <from uri="direct:start"/>
            <to uri="dns:ip"/>
        </route>
----

This looks up a domain's IP. For example, www.example.com resolves to
192.0.32.10. +
The IP address to lookup must be provided in the header with key
`"dns.domain"`.

[[BookComponentAppendix-DNSlookup]]
DNS lookup
++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        <route id="IPCheck">
            <from uri="direct:start"/>
            <to uri="dns:lookup"/>
        </route>
----

This returns a set of DNS records associated with a domain. +
The name to lookup must be provided in the header with key `"dns.name"`.

[[BookComponentAppendix-DNSDig]]
DNS Dig
+++++++

Dig is a Unix command-line utility to run DNS queries.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        <route id="IPCheck">
            <from uri="direct:start"/>
            <to uri="dns:dig"/>
        </route>
----

The query must be provided in the header with key `"dns.query"`.

[[BookComponentAppendix-SeeAlso.8]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-EJBComponent]]
EJB Component
~~~~~~~~~~~~~

*Available as of Camel 2.4*

The *ejb:* component binds EJBs to Camel message exchanges.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-ejb</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.17]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ejb:ejbName[?options]
----

Where *ejbName* can be any string which is used to look up the EJB in
the Application Server JNDI link:registry.html[Registry]

[[BookComponentAppendix-Options.14]]
Options
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Type |Default |Description
|`method` |`String` |`null` |The method name that bean will be invoked.
If not provided, Camel will try to pick the method itself. In case of
ambiguity an exception is thrown. See link:bean-binding.html[Bean
Binding] for more details.

|`multiParameterArray` |`boolean` |`false` |How to treat the parameters
which are passed from the message body; if it is `true`, the In message
body should be an array of parameters.
|=======================================================================

You can append query options to the URI in the following format,
`?option=value&option=value&...`

The link:ejb.html[EJB] component extends the link:bean.html[Bean]
component in which most of the details from the link:bean.html[Bean]
component applies to this component as well.

[[BookComponentAppendix-BeanBinding.1]]
Bean Binding
^^^^^^^^^^^^

How bean methods to be invoked are chosen (if they are not specified
explicitly through the *method* parameter) and how parameter values are
constructed from the link:message.html[Message] are all defined by the
link:bean-binding.html[Bean Binding] mechanism which is used throughout
all of the various link:bean-integration.html[Bean Integration]
mechanisms in Camel.

[[BookComponentAppendix-Examples.2]]
Examples
^^^^^^^^

In the following examples we use the Greater EJB which is defined as
follows:

*GreaterLocal.java*

And the implementation

*GreaterImpl.java*

[[BookComponentAppendix-UsingJavaDSL]]
Using Java DSL
++++++++++++++

In this example we want to invoke the `hello` method on the EJB. Since
this example is based on an unit test using Apache OpenEJB we have to
set a `JndiContext` on the link:ejb.html[EJB] component with the OpenEJB
settings.

Then we are ready to use the EJB in the Camel route:

**In a real application server**

In a real application server you most likely do not have to setup a
`JndiContext` on the link:ejb.html[EJB] component as it will create a
default `JndiContext` on the same JVM as the application server, which
usually allows it to access the JNDI registry and lookup the
link:ejb.html[EJB]s. +
However if you need to access a application server on a remote JVM or
the likes, you have to prepare the properties beforehand.

[[BookComponentAppendix-UsingSpringXML]]
Using Spring XML
++++++++++++++++

And this is the same example using Spring XML instead:

Again since this is based on an unit test we need to setup the
link:ejb.html[EJB] component:

Before we are ready to use link:ejb.html[EJB] in the Camel routes:

[[BookComponentAppendix-SeeAlso.9]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:bean.html[Bean]
* link:bean-binding.html[Bean Binding]
* link:bean-integration.html[Bean Integration]

[[BookComponentAppendix-Esper]]
Esper
~~~~~

The Esper component supports the http://esper.codehaus.org[Esper
Library] for Event Stream Processing. The *camel-esper* library is
provided by the http://code.google.com/p/camel-extra/[Camel Extra]
project which hosts all *GPL related components for Camel.

[[BookComponentAppendix-URIformat.18]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
esper:name[?options]
----

When consuming from an Esper endpoint you must specify a *pattern* or
*eql* statement to query the event stream.

Pattern example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("esper://cheese?pattern=every event=MyEvent(bar=5)")
  .to("activemq:Foo");
----

EQL example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("esper://esper-dom?eql=insert into DomStream select * from org.w3c.dom.Document")
  .to("log://esper-dom?level=INFO");
from("esper://esper-dom?eql=select childNodes from DomStream")
  .to("mock:results");
----

[[BookComponentAppendix-Options.15]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`configured` |false |Available as of camel-extra 2.11.3: +
If flag is set to 'true' the default Esper configuration file
(esper.cfg.xml) will be used.  +
To configure Esper via a configuration file, please refer to the
http://esper.codehaus.org/esper-4.2.0/doc/reference/en/html/configuration.html[Esper
documentation]

|`pattern` |  |The
http://esper.codehaus.org/esper-4.10.0/doc/reference/en-US/html/event_patterns.html[Esper
Pattern expression] as a String to filter events

|`eql` |  |The
http://esper.codehaus.org/esper-4.10.0/doc/reference/en-US/html/epl_clauses.html[Esper
EQL expression] as a String to filter events
|=======================================================================

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-EsperMessage]]
EsperMessage
^^^^^^^^^^^^

From *Camel 2.12* onwards the esper consumer stores new and old events
in the `org.apacheextras.camel.component.esper.EsperMessage` message as
the input link:message.html[Message] on the
link:exchange.html[Exchange]. You can get access to the esper event
beans from java code with:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  EventBean newEvent = exchange.getIn(EsperMessage.class).getNewEvent();
  EventBean oldEvent = exchange.getIn(EsperMessage.class).getOldEvent();
----

By default if you get the body of
`org.apacheextras.camel.component.esper.EsperMessage` it returns the new
`EventBean` as in previous versions.

[[BookComponentAppendix-Demo]]
Demo
^^^^

There is a http://code.google.com/p/camel-extra/wiki/EsperDemo[demo
which shows how to work with ActiveMQ, Camel and Esper] in the
http://code.google.com/p/camel-extra/[Camel Extra] project

[[BookComponentAppendix-SeeAlso.10]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* http://code.google.com/p/camel-extra/wiki/EsperDemo[Esper Camel Demo]

Unable to render \{include} The included page could not be found.

[[BookComponentAppendix-FileComponent]]
File Component
~~~~~~~~~~~~~~

The File component provides access to file systems, allowing files to be
processed by any other Camel link:components.html[Components] or
messages from other components to be saved to disk.

[[BookComponentAppendix-URIformat.19]]
URI format
^^^^^^^^^^

file:directoryName[?options]

or

file://directoryName[?options]

Where *`directoryName`* represents the underlying file directory.

You can append query options to the URI in the following format,
*`?option=value&option=value&...`*

Only directories

Camel supports only endpoints configured with a starting directory. So
the *`directoryName`* must be a directory. If you want to consume a
single file only, you can use the *fileName* option e.g., by setting
*`fileName=thefilename`*. Also, the starting directory must not contain
dynamic expressions with *`${}`* placeholders. Again use the
*`fileName`* option to specify the dynamic part of the filename.

Avoid reading files currently being written by another application

Beware the JDK File IO API is a bit limited in detecting whether another
application is currently writing/copying a file. And the implementation
can be different depending on OS platform as well. This could lead to
that Camel thinks the file is not locked by another process and start
consuming it. Therefore you have to do you own investigation what suites
your environment. To help with this Camel provides different
*`readLock`* options and *`doneFileName`* option that you can use. See
also the section _Consuming files from folders where others drop files
directly_.

[[BookComponentAppendix-URIOptions.1]]
URI Options
^^^^^^^^^^^

[[BookComponentAppendix-Common]]
Common
++++++

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`autoCreate` |`true` |Automatically create missing directories in the
file's path name. For the file consumer, that means creating the
starting directory. For the file producer, it means the directory the
files should be written to.

|`bufferSize` |`128kb` |Write buffer sized in bytes.

|`fileName` |`null` a|
Use link:expression.html[Expression] such as
link:file-language.html[File Language] to dynamically set the filename.
For consumers, it's used as a filename filter. For producers, it's used
to evaluate the filename to write. If an expression is set, it take
precedence over the *`CamelFileName`* header. (*Note:* The header itself
can also be an link:expression.html[Expression]). The expression options
support both *`String`* and *`Expression`* types. If the expression is a
*`String`* type, it is *always* evaluated using the
link:file-language.html[File Language]. If the expression is an
*`Expression`* type, the specified *`Expression`* type is used - this
allows you, for instance, to use link:ognl.html[OGNL] expressions.

For the consumer, you can use it to filter filenames, so you can for
instance consume today's file using the link:file-language.html[File
Language] syntax: *`mydata-${date:now:yyyyMMdd}.txt`*. From *Camel 2.11*
onward the producers support the *`CamelOverruleFileName`* header which
takes precedence over any existing *`CamelFileName`* header; the
*`CamelOverruleFileName`* is a header that is used only once, and makes
it easier as this avoids to temporary store *`CamelFileName`* and have
to restore it afterwards.

|`flatten` |`false` |Flatten is used to flatten the file name path to
strip any leading paths, so it's just the file name. This allows you to
consume recursively into sub-directories, but when you eg write the
files to another directory they will be written in a single directory.
Setting this to `true` on the producer enforces that any file name
received in *`CamelFileName`* header will be stripped for any leading
paths.

|`charset` |`null` |*Camel 2.9.3:* this option is used to specify the
encoding of the file. You can use this on the consumer, to specify the
encodings of the files, which allow Camel to know the charset it should
load the file content in case the file content is being accessed.
Likewise when writing a file, you can use this option to specify which
charset to write the file as well. See further below for a examples and
more important details.

|`copyAndDeleteOnRenameFail` |`true` |*Camel 2.9*: whether to fallback
and do a copy and delete file, in case the file could not be renamed
directly. This option is not available for the link:ftp2.html[FTP]
component.

|`renameUsingCopy` |`false` |*Camel 2.13.1*: Perform rename operations
using a copy and delete strategy. This is primarily used in environments
where the regular rename operation is unreliable e.g., across different
file systems or networks. This option takes precedence over the
*`copyAndDeleteOnRenameFail`* parameter that will automatically fall
back to the copy and delete strategy, but only after additional delays.
|=======================================================================

[[BookComponentAppendix-Consumer]]
Consumer
++++++++

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`initialDelay` |`1000` |Milliseconds before polling the file/directory
starts.

|`delay` |`500` |Milliseconds before the next poll of the
file/directory.

|`useFixedDelay` |  a|
Controls if fixed delay or fixed rate is used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.

In *Camel 2.7.x* or older the default value is *`false`.*

From *Camel 2.8* onward the default value is *`true`.*

|`runLoggingLevel` |`TRACE` |*Camel 2.8:* The consumer logs a
start/complete log line when it polls. This option allows you to
configure the logging level for that.

|`recursive` |`false` |If a directory, will look for files in all the
sub-directories as well.

|`delete` |`false` |If *`true`*, the file will be deleted *after* it is
processed successfully.

|`noop` |`false` |If *`true`*, the file is not moved or deleted in any
way. This option is good for readonly data, or for link:etl.html[ETL]
type requirements. If *`noop=true`*, Camel will set *`idempotent=true`*
as well, to avoid consuming the same files over and over again.

|`preMove` |`null` |link:expression.html[Expression] (such as
link:file-language.html[File Language]) used to dynamically set the
filename when moving it *before* processing. For example to move
in-progress files into the *`order`* directory set this value to
*`order`*.

|`move` |`.camel` |link:expression.html[Expression] (such as
link:file-language.html[File Language]) used to dynamically set the
filename when moving it *after* processing. To move files into a
*`.done`* subdirectory just enter *`.done`*.

|`moveFailed` |`null` a|
link:expression.html[Expression] (such as link:file-language.html[File
Language]) used to dynamically set a different target directory when
moving files _in case of_ processing (configured via `move` defined
above) failed.

For example, to move files into a *`.error`* subdirectory use:
*`.error`*.

*Note*: When moving the files to the “fail” location Camel will *handle*
the error and will not pick up the file again.

|`include` |`null` |Is used to include files, if filename matches the
regex pattern (matching is case in-sensitive from Camel **2.17**
onward).

|`exclude` |`null` |Is used to exclude files, if filename matches the
regex pattern (matching is case in-sensitive from Camel *2.17* onward).

|`antInclude` |`null` |*Camel 2.10:* Ant style filter inclusion, for
example *`antInclude=*``/``.txt`*. Multiple inclusions may be specified
in comma-delimited format. See link:file2.html[below] for more details
about ant path filters.

|`antExclude` |`null` |*Camel 2.10:* Ant style filter exclusion. If both
*`antInclude`* and *`antExclude`* are used, *`antExclude`* takes
precedence over *`antInclude`*. Multiple exclusions may be specified in
comma-delimited format. See link:file2.html[below] for more details
about ant path filters.

|`antFilterCaseSensitive` |`true` |*Camel 2.11:* Ant style filter which
is case sensitive or not.

|`idempotent` |`false` |Option to use the
link:idempotent-consumer.html[Idempotent Consumer] EIP pattern to let
Camel skip already processed files. Will by default use a memory based
LRUCache that holds 1000 entries. If *`noop=true`* then idempotent will
be enabled as well to avoid consuming the same files over and over
again.

|`idempotentKey` |`Expression` a|
*Camel 2.11:* To use a custom idempotent key. By default the absolute
path of the file is used. You can use the link:file-language.html[File
Language], for example to use the file name and file size, you can do:

idempotentKey=$\{file:name}-$\{file:size}

|`idempotentRepository` |`null` |A pluggable repository
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/spi/IdempotentRepository.html[`org.apache.camel.spi.IdempotentRepository`]
which by default use *`MemoryMessageIdRepository`* if none is specified
and *`idempotent`* is *`true`.*

|`inProgressRepository` |`memory` |A pluggable in-progress repository
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/spi/IdempotentRepository.html[`org.apache.camel.spi.IdempotentRepository`]
. The in-progress repository is used to account the current in progress
files being consumed. By default a memory based repository is used.

|`filter` |`null` |Pluggable filter as a
*`org.apache.camel.component.file.GenericFileFilter`* class. Will skip
files if filter returns *`false`* in its *`accept()`* method. More
details in section below.

|`filterDirectory` |`null` |*Camel 2.18*: Filters the directory based on
link:simple.html[Simple] language. For example to filter on current
date, you can use a simple date pattern such as *`${date:now:yyyMMdd`}.*

|`filterFile` |`null` |*Camel 2.18:* Filters the file based on
link:simple.html[Simple] language. For example to filter on file size,
you can use *`${file}:size > 5000`*.

|`shuffle` |`false` |*Camel 2.16:* To shuffle the list of files (sort in
random order).

|`sorter` |`null` |Pluggable sorter as a
http://java.sun.com/j2se/1.5.0/docs/api/java/util/Comparator.html[`java.util.Comparator<org.apache.camel.component.file.GenericFile>`]
class.

|`sortBy` |`null` |Built-in sort using the link:file-language.html[File
Language]. Supports nested sorts, so you can have a sort by file name
and as a 2nd group sort by modified date. See sorting section below for
details.

|`readLock` |`none` a|
Used by consumer, to only poll the files if it has exclusive read-lock
on the file e.g., the file is not in-progress or being written. Camel
will wait until the file lock is granted.

This option provides the built-in strategies:

* **`none`** is for no read locks at all.
* **` markerFile`** Camel creates a marker file *`fileName.camelLock`*
and then holds a lock on it. This option is **not** available for the
link:ftp2.html[FTP] component.
* *`changed`* is using file length/modification timestamp to detect
whether the file is currently being copied or not. Will at least use 1
sec. to determine this, so this option cannot consume files as fast as
the others, but can be more reliable as the JDK IO API cannot always
determine whether a file is currently being used by another process. The
option *`readLockCheckInterval`* can be used to set the check frequency.
This option is *only* avail for the link:ftp2.html[FTP] component from
*Camel 2.8* onward. Note: from *Camel 2.10.1* onward the
link:ftp2.html[FTP] option *`fastExistsCheck`* can be enabled to speedup
this *`readLock`* strategy, if the FTP server support the LIST operation
with a full file name (some servers may not).
* *`fileLock`* is for using *`java.nio.channels.FileLock`*. This option
is *not* avail for the link:ftp2.html[FTP] component. This approach
should be avoided when accessing a remote file system via a mount/share
unless that file system supports distributed file locks.
* *`rename`* is for using a try to rename the file as a test if we can
get exclusive read-lock.
* **`idempotent`** *Camel 2.16* (only file component) is for using a
*`idempotentRepository`* as the read-lock. This allows to use read locks
that supports clustering if the idempotent repository implementation
supports that.
* **`idempotent-changed`** *Camel 2.19* (only file component) is for
using a *`idempotentRepository`* and changed as combined read-lock. This
allows to use read locks that supports clustering if the idempotent
repository implementation supports that.
* **`idempotent-rename`** *Camel 2.19* (only file component) is for
using a *`idempotentRepository`* and rename as combined read-lock. This
allows to use read locks that supports clustering if the idempotent
repository implementation supports that.  +

*Warning*: most of the read lock strategies are not suitable for use in
clustered mode. That is, you cannot have multiple consumers attempting
to read the same file in the same directory. In this case, the read
locks will not function reliably. The idempotent read lock supports
clustered reliably if you use a cluster aware idempotent repository
implementation such as from link:hazelcast-component.html[Hazelcast
Component] or link:infinispan.html[Infinispan].

|`readLockTimeout` |`10000` a|
Optional timeout in milliseconds for the *`readLock`*, if supported. If
the read-lock could not be granted and the timeout triggered, then Camel
will skip the file. At next poll Camel, will try the file again, and
this time maybe the read-lock could be granted. Use a value of *`0`* or
lower to indicate forever. In *Camel 2.0* the default value is *`0`*.
Starting with *Camel 2.1* the default value is *`10000`*. Currently
*`fileLock`,* `changed` and *`rename`* support the timeout.

*Note:* for link:ftp2.html[FTP] the default *`readLockTimeout`* value is
*`20000`* instead of *`10000`*. The *`readLockTimeout`* value must be
higher than *`readLockCheckInterval`*, but a rule of thumb is to have a
timeout that is at least 2 or more times higher than the
*`readLockCheckInterval`*. This is needed to ensure that ample time is
allowed for the read lock process to try to grab the lock before the
timeout was hit.

|`readLockCheckInterval` |`1000` |*Camel 2.6:* Interval in milliseconds
for the read-lock, if supported by the read lock. This interval is used
for sleeping between attempts to acquire the read lock. For example when
using the `changed` read lock, you can set a higher interval period to
cater for _slow writes_. The default of 1 sec. may be _too fast_ if the
producer is very slow writing the file. For link:ftp2.html[FTP] the
default *`readLockCheckInterval`* is *`5000`*. The *`readLockTimeout`*
value must be higher than *`readLockCheckInterval`*, but a rule of thumb
is to have a timeout that is at least 2 or more times higher than
the *`readLockCheckInterval`*. This is needed to ensure that ample time
is allowed for the read lock process to try to grab the lock before the
timeout was hit.

|`readLockMinLength` |`1` |*Camel 2.10.1:* This option applied only for
*`readLock=changed`*. This option allows you to configure a minimum file
length. By default Camel expects the file to contain data, and thus the
default value is *1*. You can set this option to zero, to allow
consuming zero-length files.

|`readLockMinAge` |`0` |*Camel 2.15*: This option applies only to
*`readLock=change`*. This option allows you to specify a minimum age a
file must be before attempting to acquire the read lock. For example,
use *`readLockMinAge=300s`* to require that the file is at least 5
minutes old. This can speedup the poll when the file is old enough as it
will acquire the read lock immediately. Notice for FTP: file timestamps
reported by FTP servers are often reported with resolution of minutes,
so *`readLockMinAge`* parameter should be defined in minutes, e.g.
*60000* for 1 minute. Notice that Camel supports specifying this as
*`60s`*, or *`1m`*, etc.

|`readLockLoggingLevel` |`WARN` a|
*Camel 2.12:* Logging level used when a read lock could not be acquired.
By default a *`WARN`* is logged. You can change this level, for example
to OFF to not have any logging.

This option is only applicable for the *`readLock`* types:

* *`changed`*
* *`fileLock`*
* *`rename`*

|`readLockMarkerFile` |`true` |*Camel 2.14:* Whether to use marker file
with the *`changed`, `rename`*, or *`exclusive`* read lock types. By
default a marker file is used as well to guard against other processes
picking up the same files. This behavior can be turned off by setting
this option to *`false`*. For example if you do not want to write marker
files to the file systems by the Camel application.

|`readLockRemoveOnRollback` |`true` |*Camel 2.16:* This option applied
only for *`readLock=idempotent`*. This option allows to specify whether
to remove the file name entry from the idempotent repository when
processing the file failed and a rollback happens. If this option is
false, then the file name entry is confirmed (as if the file did a
commit).

|readLockRemoveOnCommit |`false` |**Camel 2.16:** This option applied
only for *`readLock=idempotent`*. This option allows to specify whether
to remove the file name entry from the idempotent repository when
processing the file succeeded and a commit happens. By default the file
is not removed which ensures that any race-condition do not occur so
another active node may attempt to grab the file. Instead the idempotent
repository may support eviction strategies that you can configure to
evict the file name entry after X minutes - this ensures no problems
with race conditions.

|`readLockDeleteOrphanLockFiles` |`true` |*Camel 2.16:* Whether or not
read lock with marker files should upon startup delete any orphan read
lock files, which may have been left on the file system, if Camel was
not properly shutdown (such as a JVM crash). If turning this option to
false then any orphaned lock file will cause Camel to not attempt to
pickup that file, this could also be due another node is concurrently
reading files from the same shared directory.

|`directoryMustExist` |`false` |*Camel 2.5:* Similar to
*`startingDirectoryMustExist`* but this applies during polling recursive
sub directories.

|`doneFileName` |`null` |*Camel 2.6:* If provided, Camel will only
consume files if a _done_ file exists. This option configures what file
name to use. Either you can specify a fixed name. Or you can use dynamic
placeholders. The _done_ file is *always* expected in the same folder as
the original file. See _using done file_ and _writing done file_
sections for examples.

|`exclusiveReadLockStrategy` |`null` |Pluggable read-lock as a
*`org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy`*
implementation.

|`maxMessagesPerPoll` |`0` a|
An integer to define a maximum messages to gather per poll. By default
no maximum is set. Can be used to set a limit of e.g. *`1000`* to avoid
when starting up the server that there are thousands of files. Set a
value of *`0`* or negative to disable it. See more details at
link:batch-consumer.html[Batch Consumer].

*Notice:* If this option is in use then the link:file2.html[File] and
link:ftp2.html[FTP] components will limit *before* any sorting. For
example if you have 100000 files and use *`maxMessagesPerPoll=500`*,
then only the first 500 files will be picked up, and then sorted. You
can use the *`eagerMaxMessagesPerPoll`* option and set this to *`false`*
to allow to scan all files first and then sort afterwards.

|`eagerMaxMessagesPerPoll` |`true` |*Camel 2.9.3:* Allows for
controlling whether the limit from *`maxMessagesPerPoll`* is eager or
not. If eager then the limit is during the scanning of files. Where as
`false` would scan all files, and then perform sorting. Setting this
option to `false` allows for sorting all files first, and then limit the
poll. Mind that this requires a higher memory usage as all file details
are in memory to perform the sorting.

|`minDepth` |0 a|
*Camel 2.8*: The minimum depth to start processing when recursively
processing a directory. Using *`minDepth=1`* means the base directory.
Using *`minDepth=2`* means the first sub directory.

This option is supported by link:ftp2.html[FTP] consumer from *Camel
2.8.2, 2.9* onward.

|`maxDepth` |`Integer.MAX_VALUE` |*Camel 2.8:* The maximum depth to
traverse when recursively processing a directory. This option is
supported by link:ftp2.html[FTP] consumer from *Camel 2.8.2, 2.9*
onward.

|`processStrategy` |`null` |A pluggable
*`org.apache.camel.component.file.GenericFileProcessStrategy`* allowing
you to implement your own *`readLock`* option or similar. Can also be
used when special conditions must be met before a file can be consumed,
such as a special _ready_ file exists. If this option is set then the
*`readLock`* option does not apply.

|`startingDirectoryMustExist` |`false` |*Camel 2.5:* Whether the
starting directory must exist. Mind that the *`autoCreate`* option is
default enabled, which means the starting directory is normally auto
created if it doesn't exist. You can disable *`autoCreate`* and enable
this to ensure the starting directory must exist. Will thrown an
exception if the directory doesn't exist.

|`pollStrategy` |`null` a|
A pluggable *`org.apache.camel.spi.PollingConsumerPollStrategy`*
allowing you to provide your custom implementation to control error
handling that may occur during the *`poll`* operation but _before_ an
link:exchange.html[Exchange] has been created and routed by Camel. In
other words the error occurred while the polling was gathering
information e.g., access to a file network failed so Camel cannot access
it to scan for files.

The default implementation will log the caused exception at *`WARN`*
level and ignore it.

|`sendEmptyMessageWhenIdle` |`false` |*Camel 2.9:* If the polling
consumer did not poll any files, you can enable this option to send an
empty message (no body) instead.

|`consumer.bridgeErrorHandler` |`false` |*Camel 2.10:* Allows for
bridging the consumer to the Camel routing link:error-handler.html[Error
Handler], which mean any exceptions occurred while trying to pickup
files, or the likes, will now be processed as a message and handled by
the routing link:error-handler.html[Error Handler]. By default the
consumer will use the *`org.apache.camel.spi.ExceptionHandler`* to deal
with exceptions, that by default will be logged at *`WARN`*/*`ERROR`*
level and ignored. See the following section for more details: _How to
use the Camel error handler to deal with exceptions triggered outside
the routing engine_.

|`scheduledExecutorService` |`null` |*Camel 2.10:* Allows for
configuring a custom/shared thread pool to use for the consumer. By
default each consumer has its own single threaded thread pool. This
option allows you to share a thread pool among multiple file consumers.

|`scheduler` |`null` |*Camel 2.12:* To use a custom scheduler to trigger
the consumer to run. See more details at
link:polling-consumer.html[Polling Consumer], for example there is a
link:quartz2.html[Quartz2], and link:spring.html[Spring] based scheduler
that supports CRON expressions.

|`backoffMultiplier` |`0` a|
*Camel 2.12:* To let the scheduled polling consumer backoff if there has
been a number of subsequent idles/errors in a row. The multiplier is
then the number of polls that will be skipped before the next actual
attempt is happening again. When this option is in use then
*`backoffIdleThreshold`* and/or *`backoffErrorThreshold`* must also be
configured.

For more details see: link:polling-consumer.html[Polling Consumer].

|`backoffIdleThreshold` |`0` |*Camel 2.12:* The number of subsequent
idle polls that should happen before the *`backoffMultipler`* should
kick-in.

|`backoffErrorThreshold` |`0` |*Camel 2.12:* The number of subsequent
error polls (failed due some error) that should happen before the
*`backoffMultipler`* should kick-in.

|`onCompletionExceptionHandler` |  |*Camel 2.16:* To use a custom
*`org.apache.camel.spi.ExceptionHandler`* to handle any thrown
exceptions that happens during the file on completion process where the
consumer does either a commit or rollback. The default implementation
will log any exception at *`WARN`* level and ignore.

|`probeContentType` |`false` a|
*Camel 2.17:* Whether to enable probing of the content type. If enable
then the consumer uses `Files#probeContentType(java.nio.file.Path)` to
determine the content-type of the file, and store that as a header with
key *`Exchange#FILE_CONTENT_TYPE`* on the Message.

*Camel 2.15*-*2.16.x* the default is true.

|extendedAttributes |null |*Camel 2.17*: To enable gathering extended
file attributes through *`java.nio.file.attribute`* classes
using *`Files.getAttribute(ava.nio.file.Path, java.lang.String attribute)`*
or *`Files.readAttributes(ava.nio.file.Path, java.lang.String attributes)`*
depending on the option value. This option supports a comma delimited
list of attributes to collect e.g.,
*`basic:creationTime`*, *`posix:group`* or simple wildcard
e.g., *`posix:*`*. If the attribute name is not prefixed, the basic
attributes are queried. The result is stored as a header with
key *`CamelFileExtendedAttributes`* and it is of
type *`Map<String, Object>`* where the key is the name of the attribute
e.g., *`posix:group`* and the value is the attributed returned by the
call to *`Files.getAttribute()`* or *`Files.readAttributes`*.
|=======================================================================

[[BookComponentAppendix-Defaultbehaviorforfileconsumer]]
Default behavior for file consumer
++++++++++++++++++++++++++++++++++

* By default the file is *not* locked for the duration of the
processing.
* After the route has completed, files are moved into the**` .camel`**
subdirectory, so that they appear to be deleted.
* The File Consumer will always skip any file whose name starts with a
dot, such as *`.`*, *`.camel`*, *`.m2`* or *`.groovy`.*
* Only files (not directories) are matched for valid filename, if
options such as: *`include`* or *`exclude`* are used.

[[BookComponentAppendix-Producer]]
Producer
++++++++

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`fileExist` |`Override` a|
What to do if a file already exists with the same name. The following
values can be specified:

* *`Override`* replaces the existing file.
* *`Append`* adds content to the existing file. 
* *`Fail`* throws a *`GenericFileOperationException`* indicating that
there is already an existing file. 
* *`Ignore`* silently ignores the problem and *does not* override the
existing file, but assumes everything is okay.
* *`Move`* (*Camel 2.10.1* onward) requires that the option
*`moveExisting`* be configured as well. The *`eagerDeleteTargetFile`*
can be used to control what to do if moving the file, and there already
exists a file, otherwise causing the move operation to fail. The
*`Move`* option will move any existing files, before writing the target
file. 
* *`TryRename` (Camel 2.11.1* onward) is only applicable if
*`tempFileName`* option is in use. This allows to try renaming the file
from the temporary name to the actual name, without doing any exists
check. This check may be faster on some file systems and especially FTP
servers.

|`tempPrefix` |`null` |This option is used to write the file using a
temporary name and then, after the write is complete, rename it to the
real name. Can be used to identify files being written to and also avoid
consumers (not using exclusive read locks) reading in progress files. Is
often used by link:ftp2.html[FTP] when uploading big files.

|`tempFileName` |`null` |*Camel 2.1:* The *same* as *`tempPrefix`*
option but offering a more fine grained control on the naming of the
temporary filename as it uses the link:file-language.html[File
Language].

|`moveExisting` |`null` a|
*Camel 2.10.1:* link:expression.html[Expression] (such as
link:file-language.html[File Language]) used to compute file name to use
when *`fileExist=Move`* is configured. To move files into a *`backup`*
subdirectory just enter *`backup`*.

This option only supports the following link:file-language.html[File
Language] tokens:

* *`file:name`*
* *`file:name.ext`*
* *`file:name.noext`*
* *`file:onlyname`*
* *`file:onlyname.noext`*
* *`file:ext`*
* *`file:parent`*

*Note*: the *`file:parent`* token is not supported by the
link:ftp2.html[FTP] component which can only move files to a directory
relative to the _current_ directory.

|`keepLastModified` |`false` a|
*Camel 2.2:* Will keep the last modified timestamp from the source file
(if any). Will use the *`Exchange.FILE_LAST_MODIFIED`* header to located
the timestamp. This header can contain either a *`java.util.Date`* or
*`long`* with the timestamp. If the timestamp exists and the option is
enabled it will set this timestamp on the written file.

*Note:* This option only applies to the *file* producer. It _cannot_ be
used with any of the FTP producers.

|`eagerDeleteTargetFile` |`true` a|
*Camel 2.3:* Whether or not to eagerly delete any existing target file.
This option only applies when you use *`fileExists=Override`* and the
*`tempFileName`* option as well. You can use this to disable (set it
to *`false`*) deleting the target file before the temp file is written.
For example you may write big files and want the target file to exist
while the temp file is being written. This ensures that the target file
is only deleted at the very last moment, just before the temp file is
being renamed to the target filename.

From *Camel 2.10.1* onward this option is also used to control whether
to delete any existing files when *`fileExist=Move`* is enabled, and an
existing file exists. If this option *`copyAndDeleteOnRenameFail`* is
*`false`*, then an exception will be thrown if an existing file existed.
When *`true`* the existing file is deleted before the move operation.

|`doneFileName` |`null` |*Camel 2.6:* If provided, then Camel will write
a second file (called _done_ _file_) when the original file has been
written. The _done_ _file_ will be empty. This option configures what
file name to use. You can either specify a fixed name, or you can use
dynamic placeholders. The _done_ _file_ will *always* be written in the
same folder as the original file. See _writing done file_ section for
examples.

|`allowNullBody` |`false` a|
*Camel 2.10.1:* Used to specify if a null body is allowed during file
writing. If set to true then an empty file will be created, when set to
false, and attempting to send a null body to the file component,
a *`GenericFileWriteException`* the a message 'Cannot write null body to
file' will be thrown.

If *`fileExist=Override`* the file will be truncated.
If *`fileExist=append`* the file will remain unchanged.

|`forceWrites` |`true` |*Camel 2.10.5/2.11:* Whether to force syncing
writes to the file system. You can turn this off if you do not want this
level of guarantee, for example if writing to logs / audit logs etc;
this would yield better performance.

|`chmod` |`null` |*Camel 2.15.0*: Specify the file permissions which is
sent by the producer, the chmod value must be between *`000`* and
*`777`*; If there is a leading digit like in *`0755`* we will ignore it.

|`chmodDirectory` |`null` |*Camel 2.17.0:* Specify the directory
permissions used when the producer creates missing directories, the
chmod value must be between *`000`* and *`777`*; If there is a leading
digit like in *`0755`* we will ignore it.
|=======================================================================

[[BookComponentAppendix-Defaultbehaviorforfileproducer]]
Default behavior for file producer
++++++++++++++++++++++++++++++++++

* By default it will override any existing file, if one exist with the
same name.

[[BookComponentAppendix-MoveandDeleteoperations]]
Move and Delete operations
^^^^^^^^^^^^^^^^^^^^^^^^^^

Any move or delete operations is executed after (post command) the
routing has completed; so during processing of the *`Exchange`* the file
is still located in the inbox folder.

Lets illustrate this with an example:

javafrom("file://inbox?move=.done") .to("bean:handleOrder");

When a file is dropped in the *`inbox`* folder, the file consumer
notices this and creates a new *`FileExchange`* that is routed to the
*`handleOrder`* bean. The bean then processes the *`File`* object. At
this point in time the file is still located in the *`inbox`* folder.
After the bean completes, and thus the route is completed, the file
consumer will perform the move operation and move the file to the
*`.done`* sub-folder.

The *`move`* and the *`preMove`* options are considered as a directory
name though if you use an expression such as
link:file-language.html[File Language], or link:simple.html[Simple] then
the result of the expression evaluation is the file name to be used
e.g., if you set

move=../backup/copy-of-$\{file:name}

then that's using the link:file-language.html[File Language] which we
use return the file name to be used), which can be either relative or
absolute. If relative, the directory is created as a sub-folder from
within the folder where the file was consumed.

By default, Camel will move consumed files to the *`.camel`* sub-folder
relative to the directory where the file was consumed.

If you want to delete the file after processing, the route should be:

javafrom("file://inobox?delete=true") .to("bean:handleOrder");

We have introduced a *pre* move operation to move files *before* they
are processed. This allows you to mark which files have been scanned as
they are moved to this sub folder before being processed.

javafrom("file://inbox?preMove=inprogress") .to("bean:handleOrder");

You can combine the *pre* move and the regular move:

javafrom("file://inbox?preMove=inprogress&move=.done")
.to("bean:handleOrder");

So in this situation, the file is in the *`inprogress`* folder when
being processed and after it's processed, it's moved to the *`.done`*
folder.

[[BookComponentAppendix-FineGrainedControlUsingThemoveandpreMoveOptions]]
Fine Grained Control Using The `move` and `preMove` Options
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The *move* and *preMove* options
are link:expression.html[Expression]-based, so we have the full power of
the link:file-language.html[File Language] to do advanced configuration
of the directory and name pattern. +
Camel will, in fact, internally convert the directory name you enter
into a link:file-language.html[File Language] expression. So when we
enter *`move=.done`* Camel will convert this into:
*`${``file:parent``}/.done/${``file:onlyname`}*. This is only done if
Camel detects that you have not provided a *`$`\{}* in the option value
yourself. So when you enter a *`$`\{}* Camel will *not* convert it and
thus you have the full power.

So if we want to move the file into a backup folder with today's date as
the pattern, we can do:

move=backup/$\{date:now:yyyyMMdd}/$\{file:name}

[[BookComponentAppendix-AboutmoveFailed]]
About *`moveFailed`*
++++++++++++++++++++

The *`moveFailed`* option allows you to move files that *could not* be
processed successfully to another location such as a error folder of
your choice. For example to move the files in an error folder with a
timestamp you can use
*`moveFailed=/error/${``file:name.noext``}-${date:now:yyyyMMddHHmmssSSS}.${``file:ext`}*.

See more examples at link:file-language.html[File Language]

[[BookComponentAppendix-MessageHeaders.1]]
Message Headers
^^^^^^^^^^^^^^^

The following headers are supported by this component:

[[BookComponentAppendix-Fileproduceronly]]
File producer only
++++++++++++++++++

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelFileName` |Specifies the name of the file to write (relative to
the endpoint directory). This name can be a `String`; a `String` with a
link:file-language.html[File Language] or link:simple.html[Simple]
expression; or an link:expression.html[Expression] object. If it's
*`null`* then Camel will auto-generate a filename based on the message
unique ID.

|`CamelFileNameProduced` |The absolute file path (path + name) for the
output file that was written. This header is set by Camel and its
purpose is providing end-users with the name of the file that was
written.

|`CamelOverruleFileName` |*Camel 2.11:* Is used for overruling
`CamelFileName` header and use the value instead (but only once, as the
producer will remove this header after writing the file). The value can
be only be a String. Notice that if the option *`fileName`* has been
configured, then this is still being evaluated.
|=======================================================================

[[BookComponentAppendix-Fileconsumeronly]]
File consumer only
++++++++++++++++++

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelFileName` |Name of the consumed file as a relative file path with
offset from the starting directory configured on the endpoint.

|`CamelFileNameOnly` |Only the file name (the name with no leading
paths).

|`CamelFileAbsolute` |A `boolean` option specifying whether the consumed
file denotes an absolute path or not. Should normally be `false` for
relative paths. Absolute paths should normally not be used but we added
to the move option to allow moving files to absolute paths. But can be
used elsewhere as well.

|`CamelFileAbsolutePath` |The absolute path to the file. For relative
files this path holds the relative path instead.

|`CamelFilePath` |The file path. For relative files this is the starting
directory + the relative filename. For absolute files this is the
absolute path.

|`CamelFileRelativePath` |The relative path.

|`CamelFileParent` |The parent path.

|`CamelFileLength` |A `long` value containing the file size.

|`CamelFileLastModified` |A `Long` value containing the last modified
timestamp of the file. In *Camel 2.10.3 and older* the type is `Date`.
|=======================================================================

[[BookComponentAppendix-BatchConsumer.1]]
Batch Consumer
^^^^^^^^^^^^^^

This component implements the link:batch-consumer.html[Batch Consumer].

[[BookComponentAppendix-ExchangeProperties,fileconsumeronly]]
Exchange Properties, file consumer only
+++++++++++++++++++++++++++++++++++++++

As the file consumer implements the *`BatchConsumer`* it supports
batching the files it polls. By batching we mean that Camel will add the
following additional properties to the link:exchange.html[Exchange], so
you know the number of files polled, the current index, and whether the
batch is already completed.

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Property |Description
|`CamelBatchSize` |The total number of files that was polled in this
batch.

|`CamelBatchIndex` |The current index of the batch. Starts from 0.

|`CamelBatchComplete` |A `boolean` value indicating the last
link:exchange.html[Exchange] in the batch. Is only `true` for the last
entry.
|=======================================================================

This allows you for instance to know how many files exist in this batch
and for instance let the link:aggregator2.html[Aggregator2] aggregate
this number of files.

[[BookComponentAppendix-Usingcharset]]
Using `charset`
^^^^^^^^^^^^^^^

*Available as of Camel 2.9.3* +
The *`charset`* option allows for configuring an encoding of the files
on both the consumer and producer endpoints. For example if you read
utf-8 files, and want to convert the files to iso-8859-1, you can do:

from("file:inbox?charset=utf-8") .to("file:outbox?charset=iso-8859-1")

You can also use the *`convertBodyTo`* in the route. In the example
below we have still input files in utf-8 format, but we want to convert
the file content to a byte array in iso-8859-1 format. And then let a
bean process the data. Before writing the content to the outbox folder
using the current charset.

from("file:inbox?charset=utf-8") .convertBodyTo(byte[].class,
"iso-8859-1") .to("bean:myBean") .to("file:outbox");

If you omit the charset on the consumer endpoint, then Camel does not
know the charset of the file, and would by default use "UTF-8". However
you can configure a JVM system property to override and use a different
default encoding with the key *`org.apache.camel.default.charset`*.

In the example below this could be a problem if the files is not in
UTF-8 encoding, which would be the default encoding for read the
files. +
In this example when writing the files, the content has already been
converted to a byte array, and thus would write the content directly as
is (without any further encodings).

from("file:inbox") .convertBodyTo(byte[].class, "iso-8859-1")
.to("bean:myBean") .to("file:outbox");

You can also override and control the encoding dynamic when writing
files, by setting a property on the exchange with the key
*`Exchange.CHARSET_NAME`*. For example in the route below we set the
property with a value from a message header.

from("file:inbox") .convertBodyTo(byte[].class, "iso-8859-1")
.to("bean:myBean") .setProperty(Exchange.CHARSET_NAME,
header("someCharsetHeader")) .to("file:outbox");

We suggest to keep things simpler, so if you pickup files with the same
encoding, and want to write the files in a specific encoding, then favor
to use the *`charset`* option on the endpoints.

Notice that if you have explicit configured a *`charset`* option on the
endpoint, then that configuration is used, regardless of the
*`Exchange.CHARSET_NAME`* property.

If you have some issues then you can enable *`DEBUG`* logging on
*`org.apache.camel.component.file`*, and Camel logs when it reads/write
a file using a specific charset. +
For example the route below will log the following:

from("file:inbox?charset=utf-8") .to("file:outbox?charset=iso-8859-1")

And the logs:

DEBUG GenericFileConverter - Read file
/Users/davsclaus/workspace/camel/camel-core/target/charset/input/input.txt
with charset utf-8 DEBUG FileOperations - Using Reader to write file:
target/charset/output.txt with charset: iso-8859-1

[[BookComponentAppendix-Commongotchaswithfolderandfilenames]]
Common gotchas with folder and filenames
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When Camel is producing files (writing files) there are a few gotchas
affecting how to set a filename of your choice. By default, Camel will
use the message ID as the filename, and since the message ID is normally
a unique generated ID, you will end up with filenames such as:
*`ID-MACHINENAME-2443-1211718892437-1-0`*. If such a filename is not
desired, then you must provide a filename in the *`CamelFileName`*
message header. The constant, *`Exchange.FILE_NAME`*, can also be used.

The sample code below produces files using the message ID as the
filename:

from("direct:report") .to("file:target/reports");

To use *`report.txt`* as the filename you have to do:

from("direct:report") .setHeader(Exchange.FILE_NAME,
constant("report.txt")) .to( "file:target/reports");

... the same as above, but with *`CamelFileName`:*

from("direct:report") .setHeader("CamelFileName",
constant("report.txt")) .to( "file:target/reports");

And a syntax where we set the filename on the endpoint with the
*`fileName`* URI option.

from("direct:report") .to("file:target/reports/?fileName=report.txt");

[[BookComponentAppendix-FilenameExpression]]
Filename Expression
^^^^^^^^^^^^^^^^^^^

Filename can be set either using the *expression* option or as a
string-based link:file-language.html[File Language] expression in the
*`CamelFileName`* header. See the link:file-language.html[File Language]
for syntax and samples.

[[BookComponentAppendix-Consumingfilesfromfolderswhereothersdropfilesdirectly]]
Consuming files from folders where others drop files directly
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Beware if you consume files from a folder where other applications write
files to directly. Take a look at the different *`readLock`* options to
see what suits your use cases. The best approach is however to write to
another folder and after the write move the file in the drop folder.
However if you write files directly to the drop folder then the option
changed could better detect whether a file is currently being
written/copied as it uses a file changed algorithm to see whether the
file size / modification changes over a period of time. The
other *`readLock`* options rely on Java File API that sadly is not
always very good at detecting this. You may also want to look at
the *`doneFileName`* option, which uses a marker file (done file) to
signal when a file is done and ready to be consumed.

[[BookComponentAppendix-Using'done'Files]]
Using 'done' Files
^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.6*

See also section _writing done files_ below.

If you want only to consume files when a done file exists, then you can
use the *`doneFileName`* option on the endpoint.

javafrom("file:bar?doneFileName=done");

Will only consume files from the bar folder, if a done _file_ exists in
the same directory as the target files. Camel will automatically delete
the _done file_ when it's done consuming the files. From Camel *2.9.3*
onward Camel will not automatically delete the _done file_ if
*`noop=true`* is configured.

However it is more common to have one _done file_ per target file. This
means there is a 1:1 correlation. To do this you must use dynamic
placeholders in the *`doneFileName`* option. Currently Camel supports
the following two dynamic tokens: *`file:name`* and *`file:name.noext`*
which must be enclosed in *`$`\{}*. The consumer only supports the
static part of the _done file_ name as either prefix or suffix (not
both).

javafrom("file:bar?doneFileName=$\{file:name}.done");

In this example only files will be polled if there exists a done file
with the name _file name_.done. For example

* *`hello.txt`* - is the file to be consumed
* *`hello.txt.done`* - is the associated done file

You can also use a prefix for the done file, such as:

javafrom("file:bar?doneFileName=ready-$\{file:name}");

* *`hello.txt`* - is the file to be consumed
* *`ready-hello.txt`* - is the associated done file

[[BookComponentAppendix-Writing'done'Files]]
Writing 'done' Files
^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.6*

After you have written a file you may want to write an additional _done_
_file_ as a kind of marker, to indicate to others that the file is
finished and has been written. To do that you can use the
*`doneFileName`* option on the file producer endpoint.

java.to("file:bar?doneFileName=done");

Will simply create a file named `done` in the same directory as the
target file.

However it is more common to have one done file per target file. This
means there is a 1:1 correlation. To do this you must use dynamic
placeholders in the *`doneFileName`* option. Currently Camel supports
the following two dynamic tokens: *`file:name`* and *`file:name.noext`*
which must be enclosed in *`${}`*.

java.to("file:bar?doneFileName=done-$\{file:name}");

Will for example create a file named *`done-foo.txt`* if the target file
was *`foo.txt`* in the same directory as the target file.

java.to("file:bar?doneFileName=$\{file:name}.done");

Will for example create a file named *`foo.txt.done`* if the target file
was *`foo.txt`* in the same directory as the target file.

java.to("file:bar?doneFileName=$\{file:name.noext}.done");

Will for example create a file named *`foo.done`* if the target file was
*`foo.txt`* in the same directory as the target file.

[[BookComponentAppendix-Examples.3]]
Examples
^^^^^^^^

[[BookComponentAppendix-Readfromadirectoryandwritetoanotherdirectory]]
Read from a directory and write to another directory
++++++++++++++++++++++++++++++++++++++++++++++++++++

javafrom("file://inputdir/?delete=true") .to("file://outputdir")

[[BookComponentAppendix-Readfromadirectoryandwritetoanotherdirectoryusingaoverruledynamicname]]
Read from a directory and write to another directory using a overrule
dynamic name
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

javafrom("file://inputdir/?delete=true")
.to("file://outputdir?overruleFile=copy-of-$\{file:name}")

Listen on a directory and create a message for each file dropped there.
Copy the contents to the *`outputdir`* and delete the file in the
*`inputdir`.*

[[BookComponentAppendix-Readingrecursivelyfromadirectoryandwritingtoanother]]
Reading recursively from a directory and writing to another
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

javafrom("file://inputdir/?recursive=true&delete=true")
.to("file://outputdir")

Listen on a directory and create a message for each file dropped there.
Copy the contents to the *`outputdir`* and delete the file in the
*`inputdir`*. Will scan recursively into sub-directories. Will lay out
the files in the same directory structure in the *`outputdir`* as the
*`inputdir`*, including any sub-directories.

inputdir/foo.txt inputdir/sub/bar.txt

Will result in the following output layout:

outputdir/foo.txt outputdir/sub/bar.txt

[[BookComponentAppendix-Usingflatten]]
Using `flatten`

If you want to store the files in the *`outputdir`* directory in the
same directory, disregarding the source directory layout e.g., to
flatten out the path, you just add the *`flatten=true`* option on the
file producer side:

javafrom("file://inputdir/?recursive=true&delete=true")
.to("file://outputdir?flatten=true")

Will result in the following output layout:

outputdir/foo.txt outputdir/bar.txt

[[BookComponentAppendix-Readingfromadirectoryandthedefaultmoveoperation]]
Reading from a directory and the default move operation
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Camel will by default move any processed file into a *`.camel`*
subdirectory in the directory the file was consumed from.

javafrom("file://inputdir/?recursive=true&delete=true")
.to("file://outputdir")

Affects the layout as follows: +
*before*

inputdir/foo.txt inputdir/sub/bar.txt

*after*

inputdir/.camel/foo.txt inputdir/sub/.camel/bar.txt outputdir/foo.txt
outputdir/sub/bar.txt

[[BookComponentAppendix-Readfromadirectoryandprocessthemessageinjava]]
Read from a directory and process the message in java
+++++++++++++++++++++++++++++++++++++++++++++++++++++

from("file://inputdir/").process(new Processor() \{ public void
process(Exchange exchange) throws Exception \{ Object body =
exchange.getIn().getBody(); // do some business logic with the input
body } });

The body will be a *`File`* object that points to the file that was just
dropped into the *`inputdir`* directory.

[[BookComponentAppendix-Writingtofiles]]
Writing to files
++++++++++++++++

Camel is of course also able to write files, i.e. produce files. In the
sample below we receive some reports on the SEDA queue that we process
before they are being written to a
directory.\{snippet:id=e1|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/ToFileRouteTest.java}

[[BookComponentAppendix-WritetosubdirectoryusingExchange.FILE_NAME]]
Write to subdirectory using `Exchange.FILE_NAME`
++++++++++++++++++++++++++++++++++++++++++++++++

Using a single route, it is possible to write a file to any number of
subdirectories. If you have a route setup as such:

xml <route> <from uri="bean:myBean"/> <to uri="file:/rootDirectory"/>
</route>

You can have *`myBean`* set the header *`Exchange.FILE_NAME`* to values
such as:

Exchange.FILE_NAME = hello.txt => /rootDirectory/hello.txt
Exchange.FILE_NAME = foo/bye.txt => /rootDirectory/foo/bye.txt

This allows you to have a single route to write files to multiple
destinations.

[[BookComponentAppendix-Writingfilethroughthetemporarydirectoryrelativetothefinaldestination]]
Writing file through the temporary directory relative to the final
destination
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Sometime you need to temporarily write the files to some directory
relative to the destination directory. Such situation usually happens
when some external process with limited filtering capabilities is
reading from the directory you are writing to. In the example below
files will be written to the  *`/var/myapp/filesInProgress`* directory
and after data transfer is done, they will be atomically moved to
the` /var/myapp/finalDirectory `directory.

javafrom("direct:start")
.to("file:///var/myapp/finalDirectory?tempPrefix=/../filesInProgress/");

[[BookComponentAppendix-UsingExpressionsforFilenames]]
Using Expressions for Filenames
+++++++++++++++++++++++++++++++

In this sample we want to move consumed files to a backup folder using
today's date as a sub-folder name:

javafrom("file://inbox?move=backup/$\{date:now:yyyyMMdd}/$\{file:name}")
.to("...");

See link:file-language.html[File Language] for more samples.

[[BookComponentAppendix-Avoidingreadingthesamefilemorethanonce(idempotentconsumer)]]
Avoiding reading the same file more than once (idempotent consumer)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel supports link:idempotent-consumer.html[Idempotent Consumer]
directly within the component so it will skip already processed files.
This feature can be enabled by setting the *`idempotent=true`* option.

javafrom("file://inbox?idempotent=true") .to("...");

Camel uses the absolute file name as the idempotent key, to detect
duplicate files. From *Camel 2.11* onward you can customize this key by
using an expression in the *`idempotentKey`* option. For example to use
both the name and the file size as the key

xml <route> <from
uri="file://inbox?idempotent=true&amp;idempotentKey=$\{file:name}-$\{file:size}"/>
<to uri="bean:processInbox"/> </route>

By default Camel uses a in memory based store for keeping track of
consumed files, it uses a least recently used cache holding up to 1000
entries. You can plugin your own implementation of this store by using
the *`idempotentRepository`* option using the `#` sign in the value to
indicate it's a referring to a bean in the link:registry.html[Registry]
with the specified *`id`.*

xml <!-- define our store as a plain spring bean --> <bean id="myStore"
class="com.mycompany.MyIdempotentStore"/> <route> <from
uri="file://inbox?idempotent=true&amp;idempotentRepository=#myStore"/>
<to uri="bean:processInbox"/> </route>

Camel will log at *`DEBUG`* level if it skips a file because it has been
consumed before:

DEBUG FileConsumer is idempotent and the file has been consumed before.
Will skip this file: target\idempotent\report.txt

[[BookComponentAppendix-Usingafilebasedidempotentrepository]]
Using a file based idempotent repository
++++++++++++++++++++++++++++++++++++++++

In this section we will use the file based idempotent repository
*`org.apache.camel.processor.idempotent.FileIdempotentRepository`*
instead of the in-memory based that is used as default. +
This repository uses a 1st level cache to avoid reading the file
repository. It will only use the file repository to store the content of
the 1st level cache. Thereby the repository can survive server restarts.
It will load the content of the file into the 1st level cache upon
startup. The file structure is very simple as it stores the key in
separate lines in the file. By default, the file store has a size limit
of 1mb. When the file grows larger Camel will truncate the file store,
rebuilding the content by flushing the 1st level cache into a fresh
empty file.

We configure our repository using Spring XML creating our file
idempotent repository and define our file consumer to use our repository
with the *`idempotentRepository`* using `#` sign to indicate
link:registry.html[Registry]
lookup:\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/spring/processor/idempotent/fileConsumerIdempotentTest.xml}

[[BookComponentAppendix-UsingaJPAbasedidempotentrepository]]
Using a JPA based idempotent repository
+++++++++++++++++++++++++++++++++++++++

In this section we will use the JPA based idempotent repository instead
of the in-memory based that is used as default.

First we need a persistence-unit in *`META-INF/persistence.xml` where we
need to use the class
`org.apache.camel.processor.idempotent.jpa.MessageProcessed`* as
model.\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-jpa/src/test/resources/META-INF/persistence.xml}Next,
we can create our JPA idempotent repository in the spring XML file as
well:\{snippet:id=jpaStore|lang=xml|url=camel/trunk/components/camel-jpa/src/test/resources/org/apache/camel/processor/jpa/fileConsumerJpaIdempotentTest-config.xml}And
yes then we just need to refer to the *jpaStore* bean in the file
consumer endpoint using the *`idempotentRepository`* using the `#`
syntax option:

xml <route> <from
uri="file://inbox?idempotent=true&amp;idempotentRepository=#jpaStore"/>
<to uri="bean:processInbox"/> </route>

[[BookComponentAppendix-Filterusingorg.apache.camel.component.file.GenericFileFilter]]
Filter using `org.apache.camel.component.file.GenericFileFilter`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel supports pluggable filtering strategies. You can then configure
the endpoint with such a filter to skip certain files being processed.

In the sample we have built our own filter that skips files starting
with *`skip`* in the
filename:\{snippet:id=e1|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerFileFilterTest.java}And
then we can configure our route using the *filter* attribute to
reference our filter (using `#` notation) that we have defined in the
spring XML file:

xml <!-- define our filter as a plain spring bean --> <bean
id="myFilter" class="com.mycompany.MyFileFilter"/> <route> <from
uri="file://inbox?filter=#myFilter"/> <to uri="bean:processInbox"/>
</route>

[[BookComponentAppendix-FilteringusingANTpathmatcher]]
Filtering using ANT path matcher
++++++++++++++++++++++++++++++++

New options from Camel 2.10 onwards

There are now *`antInclude`* and *`antExclude`* options to make it easy
to specify ANT style include/exclude without having to define the
filter. See the URI options above for more information.

The ANT path matcher is shipped out-of-the-box in the *camel-spring*
jar. So you need to depend on *camel-spring* if you are using Maven. +
The reasons is that we leverage Spring's
http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/util/AntPathMatcher.html[AntPathMatcher]
to do the actual matching.

The file paths is matched with the following rules:

* `?` matches one character
* `*` matches zero or more characters
* `**` matches zero or more directories in a path

The sample below demonstrates how to use
it:\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/spring/file/SpringFileAntPathMatcherFileFilterTest-context.xml}

[[BookComponentAppendix-SortingusingComparator]]
Sorting using `Comparator`
^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel supports pluggable sorting strategies. This strategy it to use the
build in *`java.util.Comparator`* in Java. You can then configure the
endpoint with such a comparator and have Camel sort the files before
being processed.

In the sample we have built our own comparator that just sorts by file
name:\{snippet:id=e1|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/FileSorterRefTest.java}And
then we can configure our route using the *sorter* option to reference
to our sorter (`mySorter`) we have defined in the spring XML file:

xml <!-- define our sorter as a plain spring bean --> <bean
id="mySorter" class="com.mycompany.MyFileSorter"/> <route> <from
uri="file://inbox?sorter=#mySorter"/> <to uri="bean:processInbox"/>
</route> URI options can reference beans using the # syntax

In the Spring DSL route above notice that we can refer to beans in the
link:registry.html[Registry] by prefixing the id with *`#`*. So writing
*`sorter=#mySorter`*, will instruct Camel to go look in the
link:registry.html[Registry] for a bean with the ID, *`mySorter`*.

[[BookComponentAppendix-SortingusingsortBy]]
Sorting using `sortBy`
^^^^^^^^^^^^^^^^^^^^^^

Camel supports pluggable sorting strategies. This strategy it to use the
link:file-language.html[File Language] to configure the sorting. The
*`sortBy`* option is configured as follows:

sortBy=group 1;group 2;group 3;...

Where each group is separated with semi colon. In the simple situations
you just use one group, so a simple example could be:

sortBy=file:name

This will sort by file name, you can reverse the order by prefixing
*`reverse:`* to the group, so the sorting is now Z..A:

sortBy=reverse:file:name

As we have the full power of link:file-language.html[File Language] we
can use some of the other parameters, so if we want to sort by file size
we do:

sortBy=file:length

You can configure to ignore the case, using *`ignoreCase:`* for string
comparison, so if you want to use file name sorting but to ignore the
case then we do:

sortBy=ignoreCase:file:name

You can combine ignore case and reverse, however reverse must be
specified first:

sortBy=reverse:ignoreCase:file:name

In the sample below we want to sort by last modified file, so we do:

sortBy=file:modified

And then we want to group by name as a 2nd option so files with same
modifcation is sorted by name:

sortBy=file:modified;file:name

Now there is an issue here, can you spot it? Well the modified timestamp
of the file is too fine as it will be in milliseconds, but what if we
want to sort by date only and then subgroup by name? +
Well as we have the true power of link:file-language.html[File Language]
we can use its date command that supports patterns. So this can be
solved as:

sortBy=date:file:yyyyMMdd;file:name

Yeah, that is pretty powerful, oh by the way you can also use reverse
per group, so we could reverse the file names:

sortBy=date:file:yyyyMMdd;reverse:file:name

[[BookComponentAppendix-UsingGenericFileProcessStrategy]]
Using `GenericFileProcessStrategy`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The option *`processStrategy`* can be used to use a custom
*`GenericFileProcessStrategy`* that allows you to implement your own
_begin_, _commit_ and _rollback_ logic. +
For instance lets assume a system writes a file in a folder you should
consume. But you should not start consuming the file before another
_ready_ file has been written as well.

So by implementing our own *`GenericFileProcessStrategy`* we can
implement this as:

* In the *`begin()`* method we can test whether the special _ready_ file
exists. The begin method returns a `boolean` to indicate if we can
consume the file or not.
* In the *`abort()`* method (*Camel 2.10*) special logic can be executed
in case the *`begin`* operation returned *`false`*, for example to
cleanup resources etc.
* In the *`commit()`* method we can move the actual file and also delete
the _ready_ file.

[[BookComponentAppendix-Usingfilter]]
Using `filter`
^^^^^^^^^^^^^^

The *`filter`* option allows you to implement a custom filter in Java
code by implementing the
*`org.apache.camel.component.file.GenericFileFilter`* interface. This
interface has an *`accept`* method that returns a boolean. Return
*`true`* to include the file, and *`false`* to skip the file. From Camel
2.10 onward, there is a *`isDirectory`* method on *`GenericFile`*
whether the file is a directory. This allows you to filter unwanted
directories, to avoid traversing down unwanted directories.

For example to skip any directories which starts with `"skip"` in the
name, can be implemented as
follows:\{snippet:id=e1|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerDirectoryFilterTest.java}

[[BookComponentAppendix-HowtousetheCamelerrorhandlertodealwithexceptionstriggeredoutsidetheroutingengine]]
How to use the Camel error handler to deal with exceptions triggered
outside the routing engine
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The file and ftp consumers, will by default try to pickup files. Only if
that is successful then a Camel link:exchange.html[Exchange] can be
created and passed in the Camel routing engine. When the
link:exchange.html[Exchange] is processed by the routing engine, then
the Camel link:error-handling-in-camel.html[Error Handling] takes over
e.g., the *`onException`* / *`errorHandler`* in the routes. However
outside the scope of the routing engine, any exceptions handling is
component specific. Camel offers a
*`org.apache.camel.spi.ExceptionHandler`* that allows components to use
that as a pluggable hook for end users to use their own implementation.
Camel offers a default *`LoggingExceptionHandler`* that will log the
exception at *`ERROR`/`WARN`* level.

 +
For the file and ftp components this would be the case. However if you
want to bridge the *`ExceptionHandler`* so it uses the Camel
link:error-handling-in-camel.html[Error Handling], then you need to
implement a custom *`ExceptionHandler`* that will handle the exception
by creating a Camel link:exchange.html[Exchange] and send it to the
routing engine; then the error handling of the routing engine can get
triggered.

Easier with Camel 2.10

The new option *`consumer.bridgeErrorHandler`* can be set to true, to
make this even easier. See further below for more details.

Here is such an example based upon an unit test.

First we have a custom *`ExceptionHandler`* where you can see we deal
with the exception by sending it to a Camel link:endpoint.html[Endpoint]
named
*`direct:file-error`*:\{snippet:id=e1|title=MyExceptionHandler|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerCustomExceptionHandlerTest.java} 

Then we have a Camel route that uses the Camel routing error handler,
which is the *`onException`* where we handle any *`IOException`* being
thrown. We then send the message to the same *`direct:file-error`*
endpoint, where we handle it by transforming it to a message, and then
being sent to a link:mock.html[Mock] endpoint. This is just for testing
purpose. You can handle the exception in any custom way you want, such
as using a link:bean.html[Bean] or sending an email, etc.

Notice how we configure our custom *`MyExceptionHandler`* by using the
*`consumer.exceptionHandler`* option to refer to *`#myExceptionHandler`*
which is a id of the bean registered in the
link:registry.html[Registry]. If using Spring XML or OSGi Blueprint,
then that would be a
*`<bean id="myExceptionHandler" class="com.foo.MyExceptionHandler"/>`*:\{snippet:id=e2|title=Camel
route with routing engine error
handling|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerCustomExceptionHandlerTest.java} 

The source code for this example can be seen
https://svn.apache.org/repos/asf/camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerCustomExceptionHandlerTest.java[here]

[[BookComponentAppendix-Usingconsumer.bridgeErrorHandler]]
Using `consumer.bridgeErrorHandler`
+++++++++++++++++++++++++++++++++++

*Available as of Camel 2.10*

If you want to use the Camel link:error-handler.html[Error Handler] to
deal with any exception occurring in the file consumer, then you can
enable the *`consumer.bridgeErrorHandler`* option as shown
below:\{snippet:id=e2|title=Using
consumer.bridgeErrorHandler|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerBridgeRouteExceptionHandlerTest.java}So
all you have to do is to enable this option, and the error handler in
the route will take it from there.

Important when using consumer.bridgeErrorHandler

When using *`consumer.bridgeErrorHandler`*, then
link:intercept.html[interceptors], link:oncompletion.html[OnCompletion]s
does *not* apply. The link:exchange.html[Exchange] is processed directly
by the Camel link:error-handler.html[Error Handler], and does not allow
prior actions such as interceptors, *`onCompletion`* to take action.

[[BookComponentAppendix-Debuglogging]]
Debug logging
^^^^^^^^^^^^^

This component has log level *`TRACE`* that can be helpful if you have
problems.

link:endpoint-see-also.html[Endpoint See Also]

* link:file-language.html[File Language]
* link:ftp2.html[FTP]
* link:polling-consumer.html[Polling Consumer]

[[BookComponentAppendix-FlatpackComponent]]
Flatpack Component
~~~~~~~~~~~~~~~~~~

The Flatpack component supports fixed width and delimited file parsing
via the http://flatpack.sourceforge.net[FlatPack library]. +
*Notice:* This component only supports consuming from flatpack files to
Object model. You can not (yet) write from Object model to flatpack
format.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-flatpack</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.20]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
flatpack:[delim|fixed]:flatPackConfig.pzmap.xml[?options]
----

Or for a delimited file handler with no configuration file just use

[source,brush:,java;,gutter:,false;,theme:,Default]
----
flatpack:someName[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-URIOptions.2]]
URI Options
^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`delimiter` |`,` |The default character delimiter for delimited files.

|`textQualifier` |`"` |The text qualifier for delimited files.

|`ignoreFirstRecord` |`true` |Whether the first line is ignored for
delimited files (for the column headers).

|`splitRows` |`true` |The component can either process each row one by
one or the entire content at once.

|`allowShortLines` |`false` |*Camel 2.9.7 and 2.10.5 onwards:* Allows
for lines to be shorter than expected and ignores the extra characters.

|`ignoreExtraColumns` |`false` |*Camel 2.9.7 and 2.10.5 onwards:* Allows
for lines to be longer than expected and ignores the extra characters.
|=======================================================================

[[BookComponentAppendix-Examples.4]]
Examples
^^^^^^^^

* `flatpack:fixed:foo.pzmap.xml` creates a fixed-width endpoint using
the `foo.pzmap.xml` file configuration.
* `flatpack:delim:bar.pzmap.xml` creates a delimited endpoint using the
`bar.pzmap.xml` file configuration.
* `flatpack:foo` creates a delimited endpoint called `foo` with no file
configuration.

[[BookComponentAppendix-MessageHeaders.2]]
Message Headers
^^^^^^^^^^^^^^^

Camel will store the following headers on the IN message:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`camelFlatpackCounter` |The current row index. For `splitRows=false`
the counter is the total number of rows.
|=======================================================================

[[BookComponentAppendix-MessageBody]]
Message Body
^^^^^^^^^^^^

The component delivers the data in the IN message as a
`org.apache.camel.component.flatpack.DataSetList` object that has
converters for `java.util.Map` or `java.util.List`. +
Usually you want the `Map` if you process one row at a time
(`splitRows=true`). Use `List` for the entire content
(`splitRows=false`), where each element in the list is a `Map`. +
Each `Map` contains the key for the column name and its corresponding
value.

For example to get the firstname from the sample below:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  Map row = exchange.getIn().getBody(Map.class);
  String firstName = row.get("FIRSTNAME");
----

However, you can also always get it as a `List` (even for
`splitRows=true`). The same example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  List data = exchange.getIn().getBody(List.class);
  Map row = (Map)data.get(0);
  String firstName = row.get("FIRSTNAME");
----

[[BookComponentAppendix-HeaderandTrailerrecords]]
Header and Trailer records
^^^^^^^^^^^^^^^^^^^^^^^^^^

The header and trailer notions in Flatpack are supported. However, you
*must* use fixed record IDs:

* `header` for the header record (must be lowercase)
* `trailer` for the trailer record (must be lowercase)

The example below illustrates this fact that we have a header and a
trailer. You can omit one or both of them if not needed.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    <RECORD id="header" startPosition="1" endPosition="3" indicator="HBT">
        <COLUMN name="INDICATOR" length="3"/>
        <COLUMN name="DATE" length="8"/>
    </RECORD>

    <COLUMN name="FIRSTNAME" length="35" />
    <COLUMN name="LASTNAME" length="35" />
    <COLUMN name="ADDRESS" length="100" />
    <COLUMN name="CITY" length="100" />
    <COLUMN name="STATE" length="2" />
    <COLUMN name="ZIP" length="5" />

    <RECORD id="trailer" startPosition="1" endPosition="3" indicator="FBT">
        <COLUMN name="INDICATOR" length="3"/>
        <COLUMN name="STATUS" length="7"/>
    </RECORD>
----

[[BookComponentAppendix-Usingtheendpoint]]
Using the endpoint
^^^^^^^^^^^^^^^^^^

A common use case is sending a file to this endpoint for further
processing in a separate route. For example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <camelContext xmlns="http://activemq.apache.org/camel/schema/spring">
    <route>
      <from uri="file://someDirectory"/>
      <to uri="flatpack:foo"/>
    </route>

    <route>
      <from uri="flatpack:foo"/>
      ...
    </route>
  </camelContext>
----

You can also convert the payload of each message created to a `Map` for
easy link:bean-integration.html[Bean Integration]

[[BookComponentAppendix-FlatpackDataFormat]]
Flatpack DataFormat
~~~~~~~~~~~~~~~~~~~

The link:flatpack.html[Flatpack] component ships with the Flatpack data
format that can be used to format between fixed width or delimited text
messages to a `List` of rows as `Map`.

* marshal = from `List<Map<String, Object>>` to `OutputStream` (can be
converted to `String`)
* unmarshal = from `java.io.InputStream` (such as a `File` or `String`)
to a `java.util.List` as an
`org.apache.camel.component.flatpack.DataSetList` instance. +
The result of the operation will contain all the data. If you need to
process each row one by one you can split the exchange, using
link:splitter.html[Splitter].

*Notice:* The Flatpack library does currently not support header and
trailers for the marshal operation.

[[BookComponentAppendix-Options.16]]
Options
^^^^^^^

The data format has the following options:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`definition` |`null` |The flatpack pzmap configuration file. Can be
omitted in simpler situations, but its preferred to use the pzmap.

|`fixed` |`false` |Delimited or fixed.

|`ignoreFirstRecord` |`true` |Whether the first line is ignored for
delimited files (for the column headers).

|`textQualifier` |`"` |If the text is qualified with a char such as `"`.

|`delimiter` |`,` |The delimiter char (could be `;` `,` or similar)

|`parserFactory` |`null` |Uses the default Flatpack parser factory.

|`allowShortLines` |`false` |*Camel 2.9.7 and 2.10.5 onwards*: Allows
for lines to be shorter than expected and ignores the extra characters.

|`ignoreExtraColumns` |`false` |*Camel 2.9.7 and 2.10.5 onwards*: Allows
for lines to be longer than expected and ignores the extra characters.
|=======================================================================

[[BookComponentAppendix-Usage.2]]
Usage
^^^^^

To use the data format, simply instantiate an instance and invoke the
marshal or unmarshal operation in the route builder:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  FlatpackDataFormat fp = new FlatpackDataFormat();
  fp.setDefinition(new ClassPathResource("INVENTORY-Delimited.pzmap.xml"));
  ...
  from("file:order/in").unmarshal(df).to("seda:queue:neworder");
----

The sample above will read files from the `order/in` folder and
unmarshal the input using the Flatpack configuration file
`INVENTORY-Delimited.pzmap.xml` that configures the structure of the
files. The result is a `DataSetList` object we store on the SEDA queue.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
FlatpackDataFormat df = new FlatpackDataFormat();
df.setDefinition(new ClassPathResource("PEOPLE-FixedLength.pzmap.xml"));
df.setFixed(true);
df.setIgnoreFirstRecord(false);

from("seda:people").marshal(df).convertBodyTo(String.class).to("jms:queue:people");
----

In the code above we marshal the data from a Object representation as a
`List` of rows as `Maps`. The rows as `Map` contains the column name as
the key, and the the corresponding value. This structure can be created
in Java code from e.g. a processor. We marshal the data according to the
Flatpack format and convert the result as a `String` object and store it
on a JMS queue.

[[BookComponentAppendix-Dependencies.1]]
Dependencies
^^^^^^^^^^^^

To use Flatpack in your camel routes you need to add the a dependency on
*camel-flatpack* which implements this data format.

If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest & greatest release (see
link:download.html[the download page for the latest versions]).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
  <groupId>org.apache.camel</groupId>
  <artifactId>camel-flatpack</artifactId>
  <version>x.x.x</version>
</dependency>
----

[[BookComponentAppendix-SeeAlso.11]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-FreeMarker]]
FreeMarker
~~~~~~~~~~

The *freemarker:* component allows for processing a message using a
http://freemarker.org/[FreeMarker] template. This can be ideal when
using link:templating.html[Templating] to generate responses for
requests.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-freemarker</artifactId> <version>x.x.x</version> <!--
use the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.21]]
URI format
^^^^^^^^^^

freemarker:templateName[?options]

Where *templateName* is the classpath-local URI of the template to
invoke; or the complete URL of the remote template (eg:
file://folder/myfile.ftl).

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.17]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`contentCache` |`true` |Cache for the resource content when it's
loaded. +
Note: as of *Camel 2.9* cached resource content can be cleared via JMX
using the endpoint's `clearContentCache` operation.

|`encoding` |`null` |Character encoding of the resource content.

|`templateUpdateDelay` |`5` |*Camel 2.9:* Number of seconds the loaded
template resource will remain in the cache.
|=======================================================================

[[BookComponentAppendix-Headers.2]]
Headers
^^^^^^^

Headers set during the FreeMarker evaluation are returned to the message
and added as headers. This provides a mechanism for the FreeMarker
component to return values to the Message.

An example: Set the header value of `fruit` in the FreeMarker template:

$\{request.setHeader('fruit', 'Apple')}

The header, `fruit`, is now accessible from the `message.out.headers`.

[[BookComponentAppendix-FreeMarkerContext]]
FreeMarker Context
^^^^^^^^^^^^^^^^^^

Camel will provide exchange information in the FreeMarker context (just
a `Map`). The `Exchange` is transferred as:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|======================================================================
|key |value
|`exchange` |The `Exchange` itself.
|`exchange.properties` |The `Exchange` properties.
|`headers` |The headers of the In message.
|`camelContext` |The Camel Context.
|`request` |The In message.
|`body` |The In message body.
|`response` |The Out message (only for InOut message exchange pattern).
|======================================================================

From Camel 2.14, you can setup your custom FreeMarker context in the
message header with the key "*CamelFreemarkerDataModel*" just like this

Map<String, Object> variableMap = new HashMap<String, Object>();
variableMap.put("headers", headersMap); variableMap.put("body",
"Monday"); variableMap.put("exchange", exchange);
exchange.getIn().setHeader("CamelFreemarkerDataModel", variableMap);

[[BookComponentAppendix-Hotreloading]]
Hot reloading
^^^^^^^^^^^^^

The FreeMarker template resource is by default *not* hot reloadable for
both file and classpath resources (expanded jar). If you set
`contentCache=false`, then Camel will not cache the resource and hot
reloading is thus enabled. This scenario can be used in development.

[[BookComponentAppendix-Dynamictemplates]]
Dynamic templates
^^^^^^^^^^^^^^^^^

Camel provides two headers by which you can define a different resource
location for a template or the template content itself. If any of these
headers is set then Camel uses this over the endpoint configured
resource. This allows you to provide a dynamic template at runtime.

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Header |Type |Description |Support Version
|FreemarkerConstants.FREEMARKER_RESOURCE
|org.springframework.core.io.Resource |The template resource |<= 2.1

|FreemarkerConstants.FREEMARKER_RESOURCE_URI |String |A URI for the
template resource to use instead of the endpoint configured. |>= 2.1

|FreemarkerConstants.FREEMARKER_TEMPLATE |String |The template to use
instead of the endpoint configured. |>= 2.1
|=======================================================================

[[BookComponentAppendix-Samples.2]]
Samples
^^^^^^^

For example you could use something like:

from("activemq:My.Queue"). to("freemarker:com/acme/MyResponse.ftl");

To use a FreeMarker template to formulate a response for a message for
InOut message exchanges (where there is a `JMSReplyTo` header).

If you want to use InOnly and consume the message and send it to another
destination you could use:

from("activemq:My.Queue"). to("freemarker:com/acme/MyResponse.ftl").
to("activemq:Another.Queue");

And to disable the content cache, e.g. for development usage where the
`.ftl` template should be hot reloaded:

from("activemq:My.Queue").
to("freemarker:com/acme/MyResponse.ftl?contentCache=false").
to("activemq:Another.Queue");

And a file-based resource:

from("activemq:My.Queue").
to("freemarker:file://myfolder/MyResponse.ftl?contentCache=false").
to("activemq:Another.Queue");

In *Camel 2.1* it's possible to specify what template the component
should use dynamically via a header, so for example:

from("direct:in").
setHeader(FreemarkerConstants.FREEMARKER_RESOURCE_URI).constant("path/to/my/template.ftl").
to("freemarker:dummy");

[[BookComponentAppendix-TheEmailSample]]
The Email Sample
^^^^^^^^^^^^^^^^

In this sample we want to use FreeMarker templating for an order
confirmation email. The email template is laid out in FreeMarker as:

Dear $\{headers.lastName}, $\{headers.firstName} Thanks for the order of
$\{headers.item}. Regards Camel Riders Bookstore $\{body}

And the java code:

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-freemarker/src/test/java/org/apache/camel/component/freemarker/FreemarkerLetterTest.java}

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-FTP/SFTP/FTPSComponent]]
FTP/SFTP/FTPS Component
~~~~~~~~~~~~~~~~~~~~~~~

This component provides access to remote file systems over the FTP and
SFTP protocols.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-ftp</artifactId> <version>x.x.x</version>See the
documentation of the Apache Commons <!-- use the same version as your
Camel core version --> </dependency>

 

 

More options

See link:file2.html[File] for more options as all the options from
link:file2.html[File] is inherited.

Absolute paths

Absolute path is *not* supported.

*Camel 2.16* will translate absolute paths to relative ones by trimming
all leading slashes from `directoryname`. There'll be WARN message
printed in the logs.

Consuming from remote FTP server

Make sure you read the section titled _Default when consuming files_
further below for details related to consuming files.

[[BookComponentAppendix-URIformat.22]]
URI format
^^^^^^^^^^

ftp://[username@]hostname[:port]/directoryname[?options]
sftp://[username@]hostname[:port]/directoryname[?options]
ftps://[username@]hostname[:port]/directoryname[?options]

Where *directoryname* represents the underlying directory. The directory
name is a relative path. Absolute paths are *not* supported. The
relative path can contain nested folders, such as /inbox/us.

For Camel versions before *Camel 2.16*, the directoryName *must* exist
already as this component does not support the `autoCreate` option
(which the file component does). The reason is that its the FTP
administrator (FTP server) task to properly setup user accounts, and
home directories with the right file permissions etc.

For *Camel 2.16*, `autoCreate` option is supported. When consumer
starts, before polling is scheduled, there's additional FTP operation
performed to create the directory configured for endpoint. The default
value for `autoCreate` is `true`.

If no *username* is provided, then `anonymous` login is attempted using
no password. +
If no *port* number is provided, Camel will provide default values
according to the protocol (ftp = 21, sftp = 22, ftps = 2222).

You can append query options to the URI in the following format,
`?option=value&option=value&...`

This component uses two different libraries for the actual FTP work. FTP
and FTPS uses http://commons.apache.org/net/[Apache Commons Net] while
SFTP uses http://www.jcraft.com/jsch/[JCraft JSCH].

The FTPS component is only available in Camel 2.2 or newer. +
FTPS (also known as FTP Secure) is an extension to FTP that adds support
for the Transport Layer Security (TLS) and the Secure Sockets Layer
(SSL) cryptographic protocols.

[[BookComponentAppendix-URIOptions.3]]
URI Options
^^^^^^^^^^^

The options below are exclusive for the FTP component.

More options

See link:file2.html[File] for more options as all the options from
link:file2.html[File] is inherited.

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`username` |`null` |Specifies the username to use to log in to the
remote file systen.

|`password` |`null` |Specifies the password to use to log in to the
remote file system.

|`account` |`null` |*Camel 2.15.2:* Specified the account to use to
login to the remote FTP server (only for FTP and FTP Secure)

|`binary` |`false` |Specifies the file transfer mode, BINARY or ASCII.
Default is ASCII (`false`).

|`disconnect` |`false` |*Camel 2.2:* Whether or not to disconnect from
remote FTP server right after use. Can be used for both consumer and
producer. Disconnect will only disconnect the current connection to the
FTP server. If you have a consumer which you want to stop, then you need
to stop the consumer/route instead.

|`localWorkDirectory` |`null` |When consuming, a local work directory
can be used to store the remote file content directly in local files, to
avoid loading the content into memory. This is beneficial, if you
consume a very big remote file and thus can conserve memory. See below
for more details.

|`passiveMode` |`false` |*FTP and FTPS only*: Specifies whether to use
passive mode connections. Default is active mode (`false`).

|`securityProtocol` |`TLS` |*FTPS only:* Sets the underlying security
protocol. The following values are defined: +
`TLS`: Transport Layer Security +
`SSL`: Secure Sockets Layer

|`disableSecureDataChannelDefaults` |`false` |*Camel 2.4: FTPS only*:
Whether or not to disable using default values for `execPbsz` and
`execProt` when using secure data transfer. You can set this option to
`true` if you want to be in full control what the options `execPbsz` and
`execProt` should be used.

|`download` |`true` |*Camel 2.11:* Whether the FTP consumer should
download the file. If this option is set to `false`, then the message
body will be `null`, but the consumer will still trigger a Camel
link:exchange.html[Exchange] that has details about the file such as
file name, file size, etc. It's just that the file will not be
downloaded.

|streamDownload |false |*Camel 2.11:* Whether the consumer should
download the entire file up front, the default behavior, or if it should
pass an InputStream read from the remote resource rather than an
in-memory array as the in body of
the Camel link:exchange.html[Exchange].  This option is ignored if
download is false or is localWorkDirectory is provided.  This option is
useful for working with large remote files.

|`execProt` |`null` |*Camel 2.4: FTPS only*: Will by default use option
`P` if secure data channel defaults hasn't been disabled. Possible
values are: +
`C`: Clear +
`S`: Safe (SSL protocol only) +
`E`: Confidential (SSL protocol only) +
`P`: Private

|`execPbsz` |`null` |*Camel 2.4: FTPS only*: This option specifies the
buffer size of the secure data channel. If option `useSecureDataChannel`
has been enabled and this option has not been explicit set, then value
`0` is used.

|`isImplicit` |`false` |*FTPS only:* Sets the security
mode(implicit/explicit). Default is explicit (`false`).

|`knownHostsFile` |`null` |*SFTP only:* Sets the `known_hosts` file, so
that the SFTP endpoint can do host key verification.

|`useUserKnownHostsFile` |true |*SFTP onlly: Camel 2.18:* If
knownHostFile has not been explicit configured then use the host file
from System.getProperty(user.home)/.ssh/known_hosts

|`knownHostsUri` |`null` |*SFTP only:* *Camel 2.11.1:* Sets the
`known_hosts` file (loaded from classpath by default), so that the SFTP
endpoint can do host key verification.

|`keyPair` |`null` |*SFTP only:* *Camel 2.12.0:* Sets the Java KeyPair
for SSH public key authentication, it supports DSA or RSA keys.

|`privateKeyFile` |`null` |*SFTP only:* Set the private key file to that
the SFTP endpoint can do private key verification.

|`privateKeyUri` |`null` |*SFTP only:* *Camel 2.11.1:* Set the private
key file (loaded from classpath by default) to that the SFTP endpoint
can do private key verification.

|`privateKey` |`null` |*SFTP only:* *Camel 2.11.1:* Set the private key
as byte[] to that the SFTP endpoint can do private key verification.

|`privateKeyFilePassphrase` |`null` |*SFTP only:* *Deprecated:* use
`privateKeyPassphrase` instead. Set the private key file passphrase to
that the SFTP endpoint can do private key verification.

|`privateKeyPassphrase` |`null` |*SFTP only:* *Camel 2.11.1:* Set the
private key file passphrase to that the SFTP endpoint can do private key
verification.

|`preferredAuthentications` |`null` |*SFTP only:* *Camel 2.10.7,
2.11.2,2.12.0:* set the preferred authentications which SFTP endpoint
will used. Some example include:password,publickey. If not specified the
default list from JSCH will be used.

|`ciphers` |`null` |*Camel 2.8.2, 2.9: SFTP only* Set a comma separated
list of ciphers that will be used in order of preference. Possible
cipher names are defined by http://www.jcraft.com/jsch/[JCraft JSCH].
Some examples include:
aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc.
If not specified the default list from JSCH will be used.

|`fastExistsCheck` |`false` |*Camel 2.8.2, 2.9:* If set this option to
be true, camel-ftp will use the list file directly to check if the file
exists. Since some FTP server may not support to list the file directly,
if the option is false, camel-ftp will use the old way to list the
directory and check if the file exists. Note from *Camel 2.10.1* onwards
this option also influences `readLock=changed` to control whether it
performs a fast check to update file information or not. This can be
used to speed up the process if the FTP server has a lot of files.

|`strictHostKeyChecking` |`no` |*SFTP only:* *Camel 2.2:* Sets whether
to use strict host key checking. Possible values are: `no`, `yes` and
`ask`. `ask` does not make sense to use as Camel cannot answer the
question for you as its meant for human intervention. *Note:* The
default in Camel 2.1 and below was `ask`.

|`maximumReconnectAttempts` |`3` |Specifies the maximum reconnect
attempts Camel performs when it tries to connect to the remote FTP
server. Use 0 to disable this behavior.

|`reconnectDelay` |`1000` |Delay in millis Camel will wait before
performing a reconnect attempt.

|`connectTimeout` |`10000` |*Camel 2.4:* Is the connect timeout in
millis. This corresponds to using `ftpClient.connectTimeout` for the
FTP/FTPS. For SFTP this option is also used when attempting to connect.

|`soTimeout` |`null / 30000` a|
*FTP and FTPS Only:* *Camel 2.4:* Is the `SocketOptions.SO_TIMEOUT`
value in millis. A good idea is to configure this to a value such as
300000 (5 minutes) to not hang a connection. On SFTP this option is set
as timeout on the JSCH Session instance.

Also SFTP from *Camel 2.14.3/2.15.3/2.16* onwards.

From *Camel 2.16* onwards the default is 300000 (300 sec).

|`timeout` |`30000` |*FTP and FTPS Only:* *Camel 2.4:* Is the data
timeout in millis. This corresponds to using `ftpClient.dataTimeout` for
the FTP/FTPS. For SFTP there is no data timeout.

|`throwExceptionOnConnectFailed` |`false` |*Camel 2.5:* Whether or not
to thrown an exception if a successful connection and login could not be
establish. This allows a custom `pollStrategy` to deal with the
exception, for example to stop the consumer or the likes.

|`siteCommand` |`null` |*FTP and FTPS Only:* *Camel 2.5:* To execute
site commands after successful login. Multiple site commands can be
separated using a new line character (\n). Use `help site` to see which
site commands your FTP server supports.

|`stepwise` |`true` |*Camel 2.6:* Whether or not stepwise traversing
directories should be used or not. Stepwise means that it will CD one
directory at a time. See more details below. You can disable this in
case you can't use this approach.

|`separator` |`UNIX` a|
*Camel 2.6:* Dictates what path separator char to use when uploading
files. `Auto` = Use the path provided without altering it. `UNIX` = Use
unix style path separators. `Windows` = Use Windows style path
separators.

Since *Camel 2.15.2*: The default value is changed to UNIX style path,
before *Camel 2.15.2*: The default value is `Auto.`

|`chmod` |`null` |*SFTP Producer Only:* *Camel 2.9:* Allows you to set
chmod on the stored file. For example `chmod=640`.

|`compression` |0 |*SFTP Only:* *Camel 2.8.3/2.9:* To use compression.
Specify a level from 1 to 10. *Important:* You must manually add the
needed JSCH zlib JAR to the classpath for compression support.

|`receiveBufferSize` |`32768` |*FTP/FTPS Only: Camel 2.15.1:* The buffer
size for downloading files. The default size is 32kb.

|`ftpClient` |`null` |*FTP and FTPS Only:* *Camel 2.1:* Allows you to
use a custom `org.apache.commons.net.ftp.FTPClient` instance.

|`ftpClientConfig` |`null` |*FTP and FTPS Only:* *Camel 2.1:* Allows you
to use a custom `org.apache.commons.net.ftp.FTPClientConfig` instance.

|`ftpClientConfig.XXX` |  |*FTP and FTPS Only:* To configure various
options on the FTPClient instance from the uri. For example:
`ftpClientConfig.receiveDataSocketBufferSize=8192&ftpClientConfig.sendDataSocketBufferSize=8192`

|`serverAliveInterval` |`0` |*SFTP Only:* *Camel 2.8* Allows you to set
the serverAliveInterval of the sftp session

|`serverAliveCountMax` |`1` |*SFTP Only:* *Camel 2.8* Allows you to set
the serverAliveCountMax of the sftp session

|`ftpClient.trustStore.file` |`null` |*FTPS Only:* Sets the trust store
file, so that the FTPS client can look up for trusted certificates.

|`ftpClient.trustStore.type` |`JKS` |*FTPS Only:* Sets the trust store
type.

|`ftpClient.trustStore.algorithm` |`SunX509` |*FTPS Only:* Sets the
trust store algorithm.

|`ftpClient.trustStore.password` |`null` |*FTPS Only:* Sets the trust
store password.

|`ftpClient.keyStore.file` |`null` |*FTPS Only:* Sets the key store
file, so that the FTPS client can look up for the private certificate.

|`ftpClient.keyStore.type` |`JKS` |*FTPS Only:* Sets the key store type.

|`ftpClient.keyStore.algorithm` |`SunX509` |*FTPS Only:* Sets the key
store algorithm.

|`ftpClient.keyStore.password` |`null` |*FTPS Only:* Sets the key store
password.

|`ftpClient.keyStore.keyPassword` |`null` |*FTPS Only:* Sets the private
key password.

|`sslContextParameters` |`null` |*FTPS Only:* *Camel 2.9:* Reference to
a `org.apache.camel.util.jsse.SSLContextParameters` in the
http://camel.apache.org/registry.html[Registry].  This reference
overrides any configured SSL related options on ftpClient as well as the
securityProtocol (SSL, TLS, etc.) set on FtpsConfiguration.  See
link:camel-configuration-utilities.html[Using the JSSE Configuration
Utility].

|`proxy` |`null` |*SFTP Only:* *Camel 2.10.7, 2.11.1:* Reference to a
`com.jcraft.jsch.Proxy` in the
http://camel.apache.org/registry.html[Registry].  This proxy is used to
consume/send messages from the target SFTP host.

|`useList` |`true` |*FTP/FTPS Only:* *Camel 2.12.1:* Whether the
consumer should use FTP LIST command to retrieve directory listing to
see which files exists. If this option is set to `false`, then
`stepwise=false` must be configured, and also `fileName` must be
configured to a fixed name, so the consumer knows the name of the file
to retrieve. When doing this only that single file can be retrieved. See
further below for more details.

|`ignoreFileNotFoundOrPermissionError` |`false` |*Camel 2.12.1:* Whether
the consumer should ignore when a file was attempted to be retrieved but
did not exist (for some reason), or failure due insufficient file
permission error. *Camel 2.14.2:* This option now applies to directories
as well.

|`sendNoop` |`true` |*Camel 2.16:* Producer only. Whether to send a noop
command as a pre-write check before uploading files to the FTP server.
This is enabled by default as a validation of the connection is still
valid, which allows to silently re-connect to be able to upload the
file. However if this causes problems, you can turn this option off.

|`jschLoggingLevel` |`WARN` |*SFTP Only: Camel 2.15.3/2.16:* The logging
level to use for JSCH activity logging. As JSCH is verbose at by default
at INFO level the threshold is WARN by default.

|`bulkRequest` |  |*SFTP Only: Camel 2.17.1:* Specifies how many
requests may be outstanding at any one time. Increasing this value may
slightly improve file transfer speed but will increase memory usage.

|`disconnectOnBatchComplete` |false |*Camel 2.18:* Whether or not to
disconnect from remote FTP server after a Batch is complete. Can be used
for both consumer and producer. Disconnect will only disconnect the
current connection to the FTP server. If you have a consumer which you
want to stop, then you need to stop the consumer/route instead.

|`activePortRange` |  |*Camel 2.18:* Set the client side port range in
active mode. The syntax is: minPort-maxPort. Both port numbers are
inclusive, eg 10000-19999 to include all 1xxxx ports.
|=======================================================================

FTPS component default trust store

When using the `ftpClient.` properties related to SSL with the FTPS
component, the trust store accepts all certificates. If you only want
trust selective certificates, you have to configure the trust store with
the `ftpClient.trustStore.xxx` options or by configuring a custom
`ftpClient`.

When using `sslContextParameters`, the trust store is managed by the
configuration of the provided SSLContextParameters instance.

You can configure additional options on the `ftpClient` and
`ftpClientConfig` from the URI directly by using the `ftpClient.` or
`ftpClientConfig.` prefix.

For example to set the `setDataTimeout` on the `FTPClient` to 30 seconds
you can do:

from("ftp://foo@myserver?password=secret&ftpClient.dataTimeout=30000").to("bean:foo");

You can mix and match and have use both prefixes, for example to
configure date format or timezones.

from("ftp://foo@myserver?password=secret&ftpClient.dataTimeout=30000&ftpClientConfig.serverLanguageCode=fr").to("bean:foo");

You can have as many of these options as you like.

See the documentation of the Apache Commons FTP FTPClientConfig for
possible options and more details. And as well for Apache Commons FTP
FTPClient.

If you do not like having many and long configuration in the url you can
refer to the `ftpClient` or `ftpClientConfig` to use by letting Camel
lookup in the link:registry.html[Registry] for it.

For example:

<bean id="myConfig" class="org.apache.commons.net.ftp.FTPClientConfig">
<property name="lenientFutureDates" value="true"/> <property
name="serverLanguageCode" value="fr"/> </bean>

And then let Camel lookup this bean when you use the # notation in the
url.

from("ftp://foo@myserver?password=secret&ftpClientConfig=#myConfig").to("bean:foo");

[[BookComponentAppendix-MoreURIoptions]]
More URI options
^^^^^^^^^^^^^^^^

title:More options

See link:file2.html[File2] as all the options there also applies for
this component.

[[BookComponentAppendix-Examples.5]]
Examples
^^^^^^^^

`ftp://someone@someftpserver.com/public/upload/images/holiday2008?password=secret&binary=true` +
`ftp://someoneelse@someotherftpserver.co.uk:12049/reports/2008/password=secret&binary=false` +
`ftp://publicftpserver.com/download`

FTP Consumer does not support concurrency

The FTP consumer (with the same endpoint) does not support concurrency
(the backing FTP client is not thread safe). +
You can use multiple FTP consumers to poll from different endpoints. It
is only a single endpoint that does not support concurrent consumers.

The FTP producer does *not* have this issue, it supports concurrency.

More information

This component is an extension of the link:file2.html[File] component.
So there are more samples and details on the link:file2.html[File]
component page.

[[BookComponentAppendix-Defaultwhenconsumingfiles]]
Default when consuming files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The link:ftp2.html[FTP] consumer will by default leave the consumed
files untouched on the remote FTP server. You have to configure it
explicitly if you want it to delete the files or move them to another
location. For example you can use `delete=true` to delete the files, or
use `move=.done` to move the files into a hidden done sub directory.

The regular link:file2.html[File] consumer is different as it will by
default move files to a `.camel` sub directory. The reason Camel does
*not* do this by default for the FTP consumer is that it may lack
permissions by default to be able to move or delete files.

[[BookComponentAppendix-limitations]]
limitations
+++++++++++

The option *readLock* can be used to force Camel *not* to consume files
that are currently being written. However, this option is turned off by
default, as it requires that the user has write access. See the options
table at link:file2.html[File2] for more details about read locks. +
There are other solutions to avoid consuming files that are currently
being written over FTP; for instance, you can write to a temporary
destination and move the file after it has been written.

When moving files using `move` or `preMove` option the files are
restricted to the FTP_ROOT folder. That prevents you from moving files
outside the FTP area. If you want to move files to another area you can
use soft links and move files into a soft linked folder.

[[BookComponentAppendix-MessageHeaders.3]]
Message Headers
^^^^^^^^^^^^^^^

The following message headers can be used to affect the behavior of the
component

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelFileName` |Specifies the output file name (relative to the
endpoint directory) to be used for the output message when sending to
the endpoint. If this is not present and no expression either, then a
generated message ID is used as the filename instead.

|`CamelFileNameProduced` |The actual filepath (path + name) for the
output file that was written. This header is set by Camel and its
purpose is providing end-users the name of the file that was written.

|`CamelBatchIndex` |Current index out of total number of files being
consumed in this batch.

|`CamelBatchSize` |Total number of files being consumed in this batch.

|`CamelFileHost` |The remote hostname.

|`CamelFileLocalWorkPath` |Path to the local work file, if local work
directory is used.
|=======================================================================

In addition the FTP/FTPS consumer and producer will enrich the Camel
`Message` with the following headers

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelFtpReplyCode` |*Camel 2.11.1:* The FTP client reply code (the
type is a integer)

|`CamelFtpReplyString` |*Camel 2.11.1:* The FTP client reply string
|=======================================================================

[[BookComponentAppendix-Abouttimeouts]]
About timeouts
^^^^^^^^^^^^^^

The two set of libraries (see top) have different APIs for setting
timeout. You can use the `connectTimeout` option for both of them to set
a timeout in millis to establish a network connection. An individual
`soTimeout` can also be set on the FTP/FTPS, which corresponds to using
`ftpClient.soTimeout`. Notice SFTP will automatically use
`connectTimeout` as its `soTimeout`. The `timeout` option only applies
for FTP/FTSP as the data timeout, which corresponds to the
`ftpClient.dataTimeout` value. All timeout values are in millis.

[[BookComponentAppendix-UsingLocalWorkDirectory]]
Using Local Work Directory
^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel supports consuming from remote FTP servers and downloading the
files directly into a local work directory. This avoids reading the
entire remote file content into memory as it is streamed directly into
the local file using `FileOutputStream`.

Camel will store to a local file with the same name as the remote file,
though with `.inprogress` as extension while the file is being
downloaded. Afterwards, the file is renamed to remove the `.inprogress`
suffix. And finally, when the link:exchange.html[Exchange] is complete
the local file is deleted.

So if you want to download files from a remote FTP server and store it
as files then you need to route to a file endpoint such as:

javafrom("ftp://someone@someserver.com?password=secret&localWorkDirectory=/tmp").to("file://inbox");
Optimization by renaming work file

The route above is ultra efficient as it avoids reading the entire file
content into memory. It will download the remote file directly to a
local file stream. The `java.io.File` handle is then used as the
link:exchange.html[Exchange] body. The file producer leverages this fact
and can work directly on the work file `java.io.File` handle and perform
a `java.io.File.rename` to the target filename. As Camel knows it's a
local work file, it can optimize and use a rename instead of a file
copy, as the work file is meant to be deleted anyway.

[[BookComponentAppendix-Stepwisechangingdirectories]]
Stepwise changing directories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel link:ftp2.html[FTP] can operate in two modes in terms of
traversing directories when consuming files (eg downloading) or
producing files (eg uploading)

* stepwise
* not stepwise

You may want to pick either one depending on your situation and security
issues. Some Camel end users can only download files if they use
stepwise, while others can only download if they do not. At least you
have the choice to pick (from Camel 2.6 onwards).

In Camel 2.0 - 2.5 there is only one mode and it is:

* before 2.5 not stepwise
* 2.5 stepwise

From Camel 2.6 onwards there is now an option `stepwise` you can use to
control the behavior.

Note that stepwise changing of directory will in most cases only work
when the user is confined to it's home directory and when the home
directory is reported as `"/"`.

The difference between the two of them is best illustrated with an
example. Suppose we have the following directory structure on the remote
FTP server we need to traverse and download files:

/ /one /one/two /one/two/sub-a /one/two/sub-b

And that we have a file in each of sub-a (a.txt) and sub-b (b.txt)
folder.

[[BookComponentAppendix-Usingstepwise=true(defaultmode)]]
Using stepwise=true (default mode)
++++++++++++++++++++++++++++++++++

TYPE A 200 Type set to A PWD 257 "/" is current directory. CWD one 250
CWD successful. "/one" is current directory. CWD two 250 CWD successful.
"/one/two" is current directory. SYST 215 UNIX emulated by FileZilla
PORT 127,0,0,1,17,94 200 Port command successful LIST 150 Opening data
channel for directory list. 226 Transfer OK CWD sub-a 250 CWD
successful. "/one/two/sub-a" is current directory. PORT 127,0,0,1,17,95
200 Port command successful LIST 150 Opening data channel for directory
list. 226 Transfer OK CDUP 200 CDUP successful. "/one/two" is current
directory. CWD sub-b 250 CWD successful. "/one/two/sub-b" is current
directory. PORT 127,0,0,1,17,96 200 Port command successful LIST 150
Opening data channel for directory list. 226 Transfer OK CDUP 200 CDUP
successful. "/one/two" is current directory. CWD / 250 CWD successful.
"/" is current directory. PWD 257 "/" is current directory. CWD one 250
CWD successful. "/one" is current directory. CWD two 250 CWD successful.
"/one/two" is current directory. PORT 127,0,0,1,17,97 200 Port command
successful RETR foo.txt 150 Opening data channel for file transfer. 226
Transfer OK CWD / 250 CWD successful. "/" is current directory. PWD 257
"/" is current directory. CWD one 250 CWD successful. "/one" is current
directory. CWD two 250 CWD successful. "/one/two" is current directory.
CWD sub-a 250 CWD successful. "/one/two/sub-a" is current directory.
PORT 127,0,0,1,17,98 200 Port command successful RETR a.txt 150 Opening
data channel for file transfer. 226 Transfer OK CWD / 250 CWD
successful. "/" is current directory. PWD 257 "/" is current directory.
CWD one 250 CWD successful. "/one" is current directory. CWD two 250 CWD
successful. "/one/two" is current directory. CWD sub-b 250 CWD
successful. "/one/two/sub-b" is current directory. PORT 127,0,0,1,17,99
200 Port command successful RETR b.txt 150 Opening data channel for file
transfer. 226 Transfer OK CWD / 250 CWD successful. "/" is current
directory. QUIT 221 Goodbye disconnected.

As you can see when stepwise is enabled, it will traverse the directory
structure using CD xxx.

[[BookComponentAppendix-Usingstepwise=false]]
Using stepwise=false
++++++++++++++++++++

230 Logged on TYPE A 200 Type set to A SYST 215 UNIX emulated by
FileZilla PORT 127,0,0,1,4,122 200 Port command successful LIST one/two
150 Opening data channel for directory list 226 Transfer OK PORT
127,0,0,1,4,123 200 Port command successful LIST one/two/sub-a 150
Opening data channel for directory list 226 Transfer OK PORT
127,0,0,1,4,124 200 Port command successful LIST one/two/sub-b 150
Opening data channel for directory list 226 Transfer OK PORT
127,0,0,1,4,125 200 Port command successful RETR one/two/foo.txt 150
Opening data channel for file transfer. 226 Transfer OK PORT
127,0,0,1,4,126 200 Port command successful RETR one/two/sub-a/a.txt 150
Opening data channel for file transfer. 226 Transfer OK PORT
127,0,0,1,4,127 200 Port command successful RETR one/two/sub-b/b.txt 150
Opening data channel for file transfer. 226 Transfer OK QUIT 221 Goodbye
disconnected.

As you can see when not using stepwise, there are no CD operation
invoked at all.

[[BookComponentAppendix-Samples.3]]
Samples
^^^^^^^

In the sample below we set up Camel to download all the reports from the
FTP server once every hour (60 min) as BINARY content and store it as
files on the local file
system.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FromFtpToBinarySampleTest.java}And
the route using Spring DSL:

xml <route> <from
uri="ftp://scott@localhost/public/reports?password=tiger&amp;binary=true&amp;delay=60000"/>
<to uri="file://target/test-reports"/> </route>

[[BookComponentAppendix-ConsumingaremoteFTPSserver(implicitSSL)andclientauthentication]]
Consuming a remote FTPS server (implicit SSL) and client authentication
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

from("ftps://admin@localhost:2222/public/camel?password=admin&securityProtocol=SSL&isImplicit=true
&ftpClient.keyStore.file=./src/test/resources/server.jks
&ftpClient.keyStore.password=password&ftpClient.keyStore.keyPassword=password")
.to("bean:foo");

[[BookComponentAppendix-ConsumingaremoteFTPSserver(explicitTLS)andacustomtruststoreconfiguration]]
Consuming a remote FTPS server (explicit TLS) and a custom trust store
configuration
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

from("ftps://admin@localhost:2222/public/camel?password=admin&ftpClient.trustStore.file=./src/test/resources/server.jks&ftpClient.trustStore.password=password")
.to("bean:foo");

[[BookComponentAppendix-Filterusingorg.apache.camel.component.file.GenericFileFilter.1]]
Filter using `org.apache.camel.component.file.GenericFileFilter`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel supports pluggable filtering strategies. This strategy can be
provided by
implementing `org.apache.camel.component.file.GenericFileFilter` in
Java. You can then configure the endpoint with such a filter to skip
certain filters before being processed.

In the sample we have built our own filter that only accepts files
starting with report in the
filename.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FromFtpRemoteFileFilterTest.java}And
then we can configure our route using the *filter* attribute to
reference our filter (using `#` notation) that we have defined in the
spring XML file:

xml <!-- define our sorter as a plain spring bean --> <bean
id="myFilter" class="com.mycompany.MyFileFilter"/> <route> <from
uri="ftp://someuser@someftpserver.com?password=secret&amp;filter=#myFilter"/>
<to uri="bean:processInbox"/> </route>

[[BookComponentAppendix-FilteringusingANTpathmatcher.1]]
Filtering using ANT path matcher
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ANT path matcher is a filter that is shipped out-of-the-box in the
*camel-spring* jar. So you need to depend on *camel-spring* if you are
using Maven. +
The reason is that we leverage Spring's
http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/util/AntPathMatcher.html[AntPathMatcher]
to do the actual matching.

The file paths are matched with the following rules:

* `?` matches one character
* `*` matches zero or more characters
* `**` matches zero or more directories in a path

The sample below demonstrates how to use
it:\{snippet:id=example|lang=xml|url=camel/trunk/tests/camel-itest/src/test/resources/org/apache/camel/itest/ftp/SpringFileAntPathMatcherRemoteFileFilterTest-context.xml}

[[BookComponentAppendix-UsingaproxywithSFTP]]
Using a proxy with SFTP
^^^^^^^^^^^^^^^^^^^^^^^

To use an HTTP proxy to connect to your remote host, you can configure
your route in the following way:

xml<!-- define our sorter as a plain spring bean --> <bean id="proxy"
class="com.jcraft.jsch.ProxyHTTP"> <constructor-arg value="localhost"/>
<constructor-arg value="7777"/> </bean> <route> <from
uri="sftp://localhost:9999/root?username=admin&password=admin&proxy=#proxy"/>
<to uri="bean:processFile"/> </route>

You can also assign a user name and password to the proxy, if necessary.
Please consult the documentation for `com.jcraft.jsch.Proxy` to discover
all options.

[[BookComponentAppendix-SettingpreferredSFTPauthenticationmethod]]
Setting preferred SFTP authentication method
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you want to explicitly specify the list of authentication methods
that should be used by `sftp` component, use `preferredAuthentications`
option. If for example you would like Camel to attempt to authenticate
with private/public SSH key and fallback to user/password authentication
in the case when no public key is available, use the following route
configuration:

from("sftp://localhost:9999/root?username=admin&password=admin&preferredAuthentications=publickey,password").
to("bean:processFile");

[[BookComponentAppendix-Consumingasinglefileusingafixedname]]
Consuming a single file using a fixed name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When you want to download a single file and know the file name, you can
use `fileName=myFileName.txt` to tell Camel the name of the file to
download. By default the consumer will still do a FTP LIST command to do
a directory listing and then filter these files based on the `fileName`
option. Though in this use-case it may be desirable to turn off the
directory listing by setting `useList=false`. For example the user
account used to login to the FTP server may not have permission to do a
FTP LIST command. So you can turn off this with `useList=false`, and
then provide the fixed name of the file to download with
`fileName=myFileName.txt`, then the FTP consumer can still download the
file. If the file for some reason does not exist, then Camel will by
default throw an exception, you can turn this off and ignore this by
setting `ignoreFileNotFoundOrPermissionError=true`.

For example to have a Camel route that picks up a single file, and
deletes it after use you can write

from("ftp://admin@localhost:21/nolist/?password=admin&stepwise=false&useList=false&ignoreFileNotFoundOrPermissionError=true&fileName=report.txt&delete=true")
.to("activemq:queue:report");

Notice that we have used all the options we talked above.

You can also use this with `ConsumerTemplate`. For example to download a
single file (if it exists) and grab the file content as a String type:

String data =
template.retrieveBodyNoWait("ftp://admin@localhost:21/nolist/?password=admin&stepwise=false&useList=false&ignoreFileNotFoundOrPermissionError=true&fileName=report.txt&delete=true",
String.class);

[[BookComponentAppendix-Debuglogging.1]]
Debug logging
^^^^^^^^^^^^^

This component has log level *TRACE* that can be helpful if you have
problems.

link:endpoint-see-also.html[Endpoint See Also]

* link:file2.html[File2]

[[BookComponentAppendix-CamelComponentsforGoogleAppEngine]]
Camel Components for Google App Engine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[Warning]
====


This component is deprecated and will be removed form Camel 2.18
onwards.

====

[Tip]
====
 **Tutorials**

* A good starting point for using Camel on GAE is the
link:tutorial-for-camel-on-google-app-engine.html[Tutorial for Camel on
Google App Engine]
* The link:tutorial-oauth.html[OAuth tutorial] demonstrates how to
implement http://oauth.net/[OAuth] in web applications.

====

The Camel components for http://code.google.com/appengine/[Google App
Engine] (GAE) are part of the `camel-gae` project and provide
connectivity to GAE's
http://code.google.com/appengine/docs/java/apis.html[cloud computing
services]. They make the GAE cloud computing environment accessible to
applications via Camel interfaces. Following this pattern for other
cloud computing environments could make it easier to port Camel
applications from one cloud computing provider to another. The following
table lists the cloud computing services provided by Google and the
supporting Camel components. The documentation of each component can be
found by following the link in the _Camel Component_ column.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|GAE service |Camel component |Component description
|http://code.google.com/appengine/docs/java/urlfetch/[URL fetch service]
|link:ghttp.html[ghttp] |Provides connectivity to the GAE URL fetch
service but can also be used to receive messages from servlets.

|http://code.google.com/appengine/docs/java/taskqueue/[Task queueing
service] |link:gtask.html[gtask] |Supports asynchronous message
processing on GAE by using the task queueing service as message queue.

|http://code.google.com/appengine/docs/java/mail/[Mail service]
|link:gmail.html[gmail] |Supports sending of emails via the GAE mail
service. Receiving mails is not supported yet but will be added later.

|http://code.google.com/appengine/docs/java/memcache/[Memcache service]
|  |Not supported yet.

|http://code.google.com/appengine/docs/java/xmpp/[XMPP service] |  |Not
supported yet.

|http://code.google.com/appengine/docs/java/images/[Images service] | 
|Not supported yet.

|http://code.google.com/appengine/docs/java/datastore/[Datastore
service] |  |Not supported yet.

|http://code.google.com/apis/accounts/[Accounts service]
|link:gauth.html[gauth] +
link:glogin.html[glogin] |These components interact with the Google
Accounts API for authentication and authorization. Google Accounts is
not specific to Google App Engine but is often used by GAE applications
for implementing security. The link:gauth.html[gauth] component is used
by web applications to implement a
http://code.google.com/apis/accounts/docs/OAuth.html[Google-specific
OAuth] consumer. This component can also be used to OAuth-enable non-GAE
web applications. The link:glogin.html[glogin] component is used by Java
clients (outside GAE) for programmatic login to GAE applications. For
instructions how to protect GAE applications against unauthorized access
refer to the link:gsec.html[Security for Camel GAE applications] page.
|=======================================================================

[[BookComponentAppendix-Camelcontext]]
Camel context
^^^^^^^^^^^^^

Setting up a `SpringCamelContext` on Google App Engine differs between
Camel 2.1 and higher versions. The problem is that usage of the
Camel-specific Spring configuration XML schema from the
`http://camel.apache.org/schema/spring` namespace requires JAXB and
Camel 2.1 depends on a Google App Engine SDK version that doesn't
support JAXB yet. This limitation has been removed since Camel 2.2.

JMX must be disabled in any case because the `javax.management` package
isn't on the App Engine JRE whitelist.

[[BookComponentAppendix-Camel2.1]]
Camel 2.1
+++++++++

`camel-gae` 2.1 comes with the following `CamelContext` implementations.

* `org.apache.camel.component.gae.context.GaeDefaultCamelContext`
(extends `org.apache.camel.impl.DefaultCamelContext`)
* `org.apache.camel.component.gae.context.GaeSpringCamelContext`
(extends `org.apache.camel.spring.SpringCamelContext`)

Both disable JMX before startup. The `GaeSpringCamelContext`
additionally provides setter methods adding route builders as shown in
the next example.

*appctx.xml*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
    
    <bean id="camelContext" 
        class="org.apache.camel.component.gae.context.GaeSpringCamelContext">
        <property name="routeBuilder" ref="myRouteBuilder" />
    </bean>
    
    <bean id="myRouteBuilder"
        class="org.example.MyRouteBuilder">
    </bean>
    
</beans>
----

Alternatively, use the `routeBuilders` property of the
`GaeSpringCamelContext` for setting a list of route builders. Using this
approach, a `SpringCamelContext` can be configured on GAE without the
need for JAXB.

[[BookComponentAppendix-Camel2.2orhigher]]
Camel 2.2 or higher
+++++++++++++++++++

With Camel 2.2 or higher, applications can use the
`http://camel.apache.org/schema/spring` namespace for configuring a
`SpringCamelContext` but still need to disable JMX. Here's an example.

*appctx.xml*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:camel="http://camel.apache.org/schema/spring"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://camel.apache.org/schema/spring
http://camel.apache.org/schema/spring/camel-spring.xsd">
    
    <camel:camelContext id="camelContext">
        <camel:jmxAgent id="agent" disabled="true" />
        <camel:routeBuilder ref="myRouteBuilder"/>
    </camel:camelContext>
    
    <bean id="myRouteBuilder"
        class="org.example.MyRouteBuilder">
    </bean>
    
</beans>
----

[[BookComponentAppendix-web-xml]]

[[BookComponentAppendix-Theweb.xml]]
The web.xml
^^^^^^^^^^^

Running Camel on GAE requires usage of the `CamelHttpTransportServlet`
from `camel-servlet`. The following example shows how to configure this
servlet together with a Spring application context XML file.

*web.xml*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<web-app 
xmlns="http://java.sun.com/xml/ns/javaee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
xsi:schemaLocation="
http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5">
    
    <servlet>
        <servlet-name>CamelServlet</servlet-name>
        <servlet-class>org.apache.camel.component.servlet.CamelHttpTransportServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>appctx.xml</param-value>
        </init-param>
    </servlet>

    <!--
        Mapping used for external requests
     -->
    <servlet-mapping>
        <servlet-name>CamelServlet</servlet-name>
        <url-pattern>/camel/*</url-pattern>
    </servlet-mapping>
    
    <!--
        Mapping used for web hooks accessed by task queueing service.
     -->
    <servlet-mapping>
        <servlet-name>CamelServlet</servlet-name>
        <url-pattern>/worker/*</url-pattern>
    </servlet-mapping>

</web-app>
----

The location of the Spring application context XML file is given by the
`contextConfigLocation` init parameter. The `appctx.xml` file must be on
the classpath. The servlet mapping makes the Camel application
accessible under `http://<appname>.appspot.com/camel/...` when deployed
to Google App Engine where `<appname>` must be replaced by a real GAE
application name. The second servlet mapping is used internally by the
task queueing service for background processing via
http://www.webhooks.org/[web hooks]. This mapping is relevant for the
link:gtask.html[gtask] component and is explained there in more detail.

[[BookComponentAppendix-HazelcastComponent]]
Hazelcast Component
~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.7*

The *hazelcast:* component allows you to work with the
http://www.hazelcast.com[Hazelcast] distributed data grid / cache.
Hazelcast is a in memory data grid, entirely written in Java (single
jar). It offers a great palette of different data stores like map, multi
map (same key, n values), queue, list and atomic number. The main reason
to use Hazelcast is its simple cluster support. If you have enabled
multicast on your network you can run a cluster with hundred nodes with
no extra configuration. Hazelcast can simply configured to add
additional features like n copies between nodes (default is 1), cache
persistence, network configuration (if needed), near cache, enviction
and so on. For more information consult the Hazelcast documentation on
http://www.hazelcast.com/docs.jsp.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-hazelcast</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.23]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
hazelcast:[ map | multimap | queue | topic | seda | set | atomicvalue | instance | list | ringbuffer]:cachename[?options]
----

[Info]
====


Topic support is available as of Camel 2.15. 

====

[Info]
====


RingBuffer support is available as of Camel 2.16. 

====

[[BookComponentAppendix-Options.18]]
Options
^^^^^^^

[cols=",,",options="header",]
|=======================================================================
|Name |Required |Description
|hazelcastInstance |No |**Camel 2.14:** The hazelcast instance
*reference* which can be used for hazelcast endpoint. If you don't
specify the instance reference, camel use the default hazelcast instance
from the camel-hazelcast instance.

|hazelcastInstanceName |No |**Camel 2.16:** The hazelcast instance
*reference name* which can be used for hazelcast endpoint. If you don't
specify the instance reference, camel use the default hazelcast instance
from the camel-hazelcast instance.

|operation |-1 |To specify a default operation to use, if no operation
header has been provided. **deprecated** use defaultOperation instead.

|defaultOperation |-1 |**Camel 2.15:** To specify a default operation to
use, if no operation header has been provided.
|=======================================================================

[Warning]
====


You have to use the second prefix to define which type of data store you
want to use.

====

[[BookComponentAppendix-Sections]]
Sections
^^^^^^^^

1.  Usage of link:hazelcast-component.html[#map]
2.  Usage of link:hazelcast-component.html[#multimap]
3.  Usage of link:hazelcast-component.html[#queue]
4.  Usage of link:hazelcast-component.html[#topic]
5.  Usage of link:hazelcast-component.html[#list]
6.  Usage of link:hazelcast-component.html[#seda]
7.  Usage of link:hazelcast-component.html[atomic number]
8.  Usage of link:hazelcast-component.html[#cluster] support (instance)
9.  Usage of link:hazelcast-component.html[#replicatedmap] 
10. Usage of link:hazelcast-component.html[#ringbuffer] 

[[BookComponentAppendix-map]]

[[BookComponentAppendix-UsageofMap]]
Usage of Map
^^^^^^^^^^^^

[[BookComponentAppendix-mapcacheproducer-to("hazelcast:map:foo")]]
map cache producer - to("hazelcast:map:foo")
++++++++++++++++++++++++++++++++++++++++++++

If you want to store a value in a map you can use the map cache
producer. The map cache producer provides 5 operations (put, get,
update, delete, query). For the first 4 you have to provide the
operation inside the "hazelcast.operation.type" header variable. In Java
DSL you can use the constants from
`org.apache.camel.component.hazelcast.HazelcastConstants`.

Header Variables for the request message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.operation.type` |`String` |valid values are: put, delete,
get, update, query

|`hazelcast.objectId` |`String` |the object id to store / find your
object inside the cache (not needed for the query operation)
|=======================================================================

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastOperationType` |`String` a|
valid values are: put, delete, get, update, query
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

**From Camel 2.16:** getAll, putIfAbsent, clear.

|`CamelHazelcastObjectId` |`String` |the object id to store / find your
object inside the cache (not needed for the query operation)
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

You can call the samples with:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
template.sendBodyAndHeader("direct:[put|get|update|delete|query]", "my-foo", HazelcastConstants.OBJECT_ID, "4711");
----

[[BookComponentAppendix-Sampleforput:]]
Sample for *put*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:put")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.PUT_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.MAP_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:put" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>put</constant>
    </setHeader>
    <to uri="hazelcast:map:foo" />
</route>
----

[[BookComponentAppendix-Sampleforget:]]
Sample for *get*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:get")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.GET_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.MAP_PREFIX)
.to("seda:out");
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:get" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>get</constant>
    </setHeader>
    <to uri="hazelcast:map:foo" />
    <to uri="seda:out" />
</route>
----

[[BookComponentAppendix-Sampleforupdate:]]
Sample for *update*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:update")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.UPDATE_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.MAP_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:update" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>update</constant>
    </setHeader>
    <to uri="hazelcast:map:foo" />
</route>
----

[[BookComponentAppendix-Samplefordelete:]]
Sample for *delete*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:delete")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.DELETE_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.MAP_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:delete" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>delete</constant>
    </setHeader>
    <to uri="hazelcast:map:foo" />
</route>
----

[[BookComponentAppendix-Sampleforquery]]
Sample for *query*

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:query")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.QUERY_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.MAP_PREFIX)
.to("seda:out");
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:query" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>query</constant>
    </setHeader>
    <to uri="hazelcast:map:foo" />
    <to uri="seda:out" />
</route>
----

For the query operation Hazelcast offers a SQL like syntax to query your
distributed map.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
String q1 = "bar > 1000";
template.sendBodyAndHeader("direct:query", null, HazelcastConstants.QUERY, q1);
----

[[BookComponentAppendix-mapcacheconsumer-from("hazelcast:map:foo")]]
map cache consumer - from("hazelcast:map:foo")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Hazelcast provides event listeners on their data grid. If you want to be
notified if a cache will be manipulated, you can use the map consumer.
There're 4 events: *put*, *update*, *delete* and *envict*. The event
type will be stored in the "*hazelcast.listener.action*" header
variable. The map consumer provides some additional information inside
these variables:

Header Variables inside the response message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.listener.time` |`Long` |time of the event in millis

|`hazelcast.listener.type` |`String` |the map consumer sets here
"cachelistener"

|`hazelcast.listener.action` |`String` |type of event - here *added*,
*updated*, *envicted* and *removed*

|`hazelcast.objectId` |`String` |the oid of the object

|`hazelcast.cache.name` |`String` |the name of the cache - e.g. "foo"

|`hazelcast.cache.type` |`String` |the type of the cache - here map
|=======================================================================

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastListenerTime` |`Long` |time of the event in millis
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerType` |`String` |the map consumer sets here
"cachelistener"
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerAction` |`String` |type of event - here *added*,
*updated*, *envicted* and *removed*.
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastObjectId` |`String` |the oid of the object
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastCacheName` |`String` |the name of the cache - e.g. "foo"
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastCacheType` |`String` |the type of the cache - here map
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

The object value will be stored within *put* and *update* actions inside
the message body.

Here's a sample:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
fromF("hazelcast:%sfoo", HazelcastConstants.MAP_PREFIX)
.log("object...")
.choice()
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ADDED))
         .log("...added")
         .to("mock:added")
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ENVICTED))
         .log("...envicted")
         .to("mock:envicted")
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.UPDATED))
         .log("...updated")
         .to("mock:updated")
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.REMOVED))
         .log("...removed")
         .to("mock:removed")
    .otherwise()
         .log("fail!");
----

[[BookComponentAppendix-multimap]]

[[BookComponentAppendix-UsageofMultiMap]]
Usage of Multi Map
^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-multimapcacheproducer-to("hazelcast:multimap:foo")]]
multimap cache producer - to("hazelcast:multimap:foo")
++++++++++++++++++++++++++++++++++++++++++++++++++++++

A multimap is a cache where you can store n values to one key. The
multimap producer provides 4 operations (put, get, removevalue, delete).

Header Variables for the request message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.operation.type` |`String` |valid values are: put, get,
removevalue, delete

|`hazelcast.objectId` |`String` |the object id to store / find your
object inside the cache
|=======================================================================

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastOperationType` |`String` a|
valid values are: put, get, removevalue, delete
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

***From Camel 2.16:*** clear.

|`CamelHazelcastObjectId` |`String` |the object id to store / find your
object inside the cache
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

[[BookComponentAppendix-Sampleforput:.1]]
Sample for *put*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:put")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.PUT_OPERATION))
.to(String.format("hazelcast:%sbar", HazelcastConstants.MULTIMAP_PREFIX));
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:put" />
    <log message="put.."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>put</constant>
    </setHeader>
    <to uri="hazelcast:multimap:foo" />
</route>
----

[[BookComponentAppendix-Sampleforremovevalue:]]
Sample for *removevalue*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:removevalue")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.REMOVEVALUE_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.MULTIMAP_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:removevalue" />
    <log message="removevalue..."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>removevalue</constant>
    </setHeader>
    <to uri="hazelcast:multimap:foo" />
</route>
----

To remove a value you have to provide the value you want to remove
inside the message body. If you have a multimap object
\{`key: "4711" values: { "my-foo", "my-bar"`}} you have to put "my-foo"
inside the message body to remove the "my-foo" value.

[[BookComponentAppendix-Sampleforget:.1]]
Sample for *get*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:get")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.GET_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.MULTIMAP_PREFIX)
.to("seda:out");
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:get" />
    <log message="get.."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>get</constant>
    </setHeader>
    <to uri="hazelcast:multimap:foo" />
    <to uri="seda:out" />
</route>
----

[[BookComponentAppendix-Samplefordelete:.1]]
Sample for *delete*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:delete")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.DELETE_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.MULTIMAP_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:delete" />
    <log message="delete.."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>delete</constant>
    </setHeader>
    <to uri="hazelcast:multimap:foo" />
</route>
----

you can call them in your test class with:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
template.sendBodyAndHeader("direct:[put|get|removevalue|delete]", "my-foo", HazelcastConstants.OBJECT_ID, "4711");
----

[[BookComponentAppendix-multimapcacheconsumer-from("hazelcast:multimap:foo")]]
multimap cache consumer - from("hazelcast:multimap:foo")
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

For the multimap cache this component provides the same listeners /
variables as for the map cache consumer (except the update and enviction
listener). The only difference is the *multimap* prefix inside the URI.
Here is a sample:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
fromF("hazelcast:%sbar", HazelcastConstants.MULTIMAP_PREFIX)
.log("object...")
.choice()
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ADDED))
        .log("...added")
                .to("mock:added")
        //.when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ENVICTED))
        //        .log("...envicted")
        //        .to("mock:envicted")
        .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.REMOVED))
                .log("...removed")
                .to("mock:removed")
        .otherwise()
                .log("fail!");
----

Header Variables inside the response message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.listener.time` |`Long` |time of the event in millis

|`hazelcast.listener.type` |`String` |the map consumer sets here
"cachelistener"

|`hazelcast.listener.action` |`String` |type of event - here *added* and
*removed* (and soon *envicted*)

|`hazelcast.objectId` |`String` |the oid of the object

|`hazelcast.cache.name` |`String` |the name of the cache - e.g. "foo"

|`hazelcast.cache.type` |`String` |the type of the cache - here multimap
|=======================================================================

Eviction will be added as feature, soon (this is a Hazelcast issue).

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastListenerTime` |`Long` |time of the event in millis
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerType` |`String` |the map consumer sets here
"cachelistener"
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerAction` |`String` |type of event - here *added*
and *removed* (and soon *envicted*)
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastObjectId` |`String` |the oid of the object
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastCacheName` |`String` |the name of the cache - e.g. "foo"
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastCacheType` |`String` |the type of the cache - here
multimap
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

[[BookComponentAppendix-queue]]

[[BookComponentAppendix-UsageofQueue]]
Usage of Queue
^^^^^^^^^^^^^^

[[BookComponentAppendix-Queueproducer–to(“hazelcast:queue:foo”)]]
Queue producer – to(“hazelcast:queue:foo”)
++++++++++++++++++++++++++++++++++++++++++

The queue producer provides 6 operations (add, put, poll, peek, offer,
removevalue).

[[BookComponentAppendix-Sampleforadd:]]
Sample for *add*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:add")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.ADD_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.QUEUE_PREFIX);
----

[[BookComponentAppendix-Sampleforput:.2]]
Sample for *put*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:put")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.PUT_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.QUEUE_PREFIX);
----

[[BookComponentAppendix-Sampleforpoll:]]
Sample for *poll*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:poll")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.POLL_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.QUEUE_PREFIX);
----

[[BookComponentAppendix-Sampleforpeek:]]
Sample for *peek*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:peek")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.PEEK_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.QUEUE_PREFIX);
----

[[BookComponentAppendix-Sampleforoffer:]]
Sample for *offer*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:offer")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.OFFER_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.QUEUE_PREFIX);
----

[[BookComponentAppendix-Sampleforremovevalue:.1]]
Sample for *removevalue*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:removevalue")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.REMOVEVALUE_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.QUEUE_PREFIX);
----

[[BookComponentAppendix-Queueconsumer–from(“hazelcast:queue:foo”)]]
Queue consumer – from(“hazelcast:queue:foo”)
++++++++++++++++++++++++++++++++++++++++++++

The queue consumer provides 2 operations (add, remove).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
fromF("hazelcast:%smm", HazelcastConstants.QUEUE_PREFIX)
   .log("object...")
   .choice()
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ADDED))
            .log("...added")
        .to("mock:added")
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.REMOVED))
        .log("...removed")
        .to("mock:removed")
    .otherwise()
        .log("fail!");
----

[[BookComponentAppendix-topic]]
[[BookComponentAppendix-topic]]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-UsageofTopic]]
Usage of Topic
^^^^^^^^^^^^^^

[[BookComponentAppendix-Topicproducer–to(“hazelcast:topic:foo”)]]
Topic producer – to(“hazelcast:topic:foo”)
++++++++++++++++++++++++++++++++++++++++++

The topic producer provides only one operation (publish).

[[BookComponentAppendix-Sampleforpublish:]]
Sample for *publish*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:add")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.PUBLISH_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.PUBLISH_OPERATION);
----

[[BookComponentAppendix-Topicconsumer–from(“hazelcast:topic:foo”)]]
Topic consumer – from(“hazelcast:topic:foo”)
++++++++++++++++++++++++++++++++++++++++++++

The topic consumer provides only one operation (received). This
component is supposed to support multiple consumption as it's expected
when it comes to topics so you are free to have as much consumers as you
need on the same hazelcast topic.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
fromF("hazelcast:%sfoo", HazelcastConstants.TOPIC_PREFIX)
  .choice()
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.RECEIVED))
      .log("...message received")
    .otherwise()
      .log("...this should never have happened")
----

 

[[BookComponentAppendix-list]]

[[BookComponentAppendix-UsageofList]]
Usage of List
^^^^^^^^^^^^^

[[BookComponentAppendix-Listproducer–to(“hazelcast:list:foo”)]]
List producer – to(“hazelcast:list:foo”)
++++++++++++++++++++++++++++++++++++++++

The list producer provides 4 operations (add, addAll, set, get,
removevalue, removeAll, clear).

[[BookComponentAppendix-Sampleforadd:.1]]
Sample for *add*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:add")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.ADD_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.LIST_PREFIX);
----

[[BookComponentAppendix-Sampleforget:.2]]
Sample for *get*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:get")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.GET_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.LIST_PREFIX)
.to("seda:out");
----

[[BookComponentAppendix-Sampleforsetvalue:]]
Sample for *setvalue*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:set")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.SETVALUE_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.LIST_PREFIX);
----

[[BookComponentAppendix-Sampleforremovevalue:.2]]
Sample for *removevalue*:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:removevalue")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.REMOVEVALUE_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.LIST_PREFIX);
----

Note that *CamelHazelcastObjectIndex* header is used for indexing
purpose.

[[BookComponentAppendix-Thelistconsumerprovides2operations(add,remove).Listconsumer–from(“hazelcast:list:foo”)]]
The list consumer provides 2 operations (add, remove).List consumer –
from(“hazelcast:list:foo”)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
fromF("hazelcast:%smm", HazelcastConstants.LIST_PREFIX)
    .log("object...")
    .choice()
        .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ADDED))
            .log("...added")
                        .to("mock:added")
        .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.REMOVED))
            .log("...removed")
                        .to("mock:removed")
                .otherwise()
                        .log("fail!");
----

[[BookComponentAppendix-seda]]

[[BookComponentAppendix-UsageofSEDA]]
Usage of SEDA
^^^^^^^^^^^^^

SEDA component differs from the rest components provided. It implements
a work-queue in order to support asynchronous SEDA architectures,
similar to the core "SEDA" component.

[[BookComponentAppendix-SEDAproducer–to(“hazelcast:seda:foo”)]]
SEDA producer – to(“hazelcast:seda:foo”)
++++++++++++++++++++++++++++++++++++++++

The SEDA producer provides no operations. You only send data to the
specified queue.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |default value |Description
|`transferExchange` |`false` |*Camel 2.8.0:* if set to true the whole
Exchange will be transfered. If header or body contains not serializable
objects, they will be skipped.
|=======================================================================

Java DSL :

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:foo")
.to("hazelcast:seda:foo");
----

Spring DSL :

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
   <from uri="direct:start" />
   <to uri="hazelcast:seda:foo" />
</route>
----

[[BookComponentAppendix-SEDAconsumer–from(“hazelcast:seda:foo”)]]
SEDA consumer – from(“hazelcast:seda:foo”)
++++++++++++++++++++++++++++++++++++++++++

The SEDA consumer provides no operations. You only retrieve data from
the specified queue.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |default value |Description
|`pollInterval` |`1000` |The timeout used when consuming from the SEDA
queue. When a timeout occurs, the consumer can check whether it is
allowed to continue running. Setting a lower value allows the consumer
to react more quickly upon shutdown. (*deprecated* from Camel 2.15
onwards, use pollTimeout instead).

|`pollTimeout` |1000 |*Camel 2.15:* The timeout used when consuming from
the SEDA queue. When a timeout occurs, the consumer can check whether it
is allowed to continue running. Setting a lower value allows the
consumer to react more quickly upon shutdown.

|`concurrentConsumers` |`1` |To use concurrent consumers polling from
the SEDA queue.

|`transferExchange` |`false` |*Camel 2.8.0:* if set to true the whole
Exchange will be transfered. If header or body contains not serializable
objects, they will be skipped.

|`transacted` |`false` |*Camel 2.10.4:* if set to true then the consumer
runs in transaction mode, where the messages in the seda queue will only
be removed if the transaction commits, which happens when the processing
is complete.
|=======================================================================

Java DSL :

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("hazelcast:seda:foo")
.to("mock:result");
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
  <from uri="hazelcast:seda:foo" />
  <to uri="mock:result" />
</route>
----

[[BookComponentAppendix-atomicnumber]]

[[BookComponentAppendix-UsageofAtomicNumber]]
Usage of Atomic Number
^^^^^^^^^^^^^^^^^^^^^^

[Warning]
====


There is no consumer for this endpoint!

====

[[BookComponentAppendix-atomicnumberproducer-to("hazelcast:atomicnumber:foo")]]
atomic number producer - to("hazelcast:atomicnumber:foo")
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

An atomic number is an object that simply provides a grid wide number
(long). The operations for this producer are setvalue (set the number
with a given value), get, increase (+1), decrease (-1) and destroy.

Header Variables for the request message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.operation.type` |`String` |valid values are: setvalue, get,
increase, decrease, destroy
|=======================================================================

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastOperationType` |`String` |valid values are: setvalue,
get, increase, decrease, destroy *Available as of Camel version 2.8*
|=======================================================================

[[BookComponentAppendix-Sampleforset:]]
Sample for *set*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:set")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.SETVALUE_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.ATOMICNUMBER_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:set" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>setvalue</constant>
    </setHeader>
    <to uri="hazelcast:atomicvalue:foo" />
</route>
----

Provide the value to set inside the message body (here the value is 10):
`template.sendBody("direct:set", 10);`

[[BookComponentAppendix-Sampleforget:.3]]
Sample for *get*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:get")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.GET_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.ATOMICNUMBER_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:get" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>get</constant>
    </setHeader>
    <to uri="hazelcast:atomicvalue:foo" />
</route>
----

You can get the number with
`long body = template.requestBody("direct:get", null, Long.class);`.

[[BookComponentAppendix-Sampleforincrement:]]
Sample for *increment*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:increment")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.INCREMENT_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.ATOMICNUMBER_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:increment" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>increment</constant>
    </setHeader>
    <to uri="hazelcast:atomicvalue:foo" />
</route>
----

The actual value (after increment) will be provided inside the message
body.

[[BookComponentAppendix-Samplefordecrement:]]
Sample for *decrement*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:decrement")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.DECREMENT_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.ATOMICNUMBER_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:decrement" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>decrement</constant>
    </setHeader>
    <to uri="hazelcast:atomicvalue:foo" />
</route>
----

The actual value (after decrement) will be provided inside the message
body.

[[BookComponentAppendix-Samplefordestroy]]
Sample for *destroy*

[Warning]
====


There's a bug inside Hazelcast. So this feature may not work properly.
Will be fixed in 1.9.3.

====

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:destroy")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.DESTROY_OPERATION))
.toF("hazelcast:%sfoo", HazelcastConstants.ATOMICNUMBER_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:destroy" />
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>destroy</constant>
    </setHeader>
    <to uri="hazelcast:atomicvalue:foo" />
</route>
----

[[BookComponentAppendix-cluster]]

[[BookComponentAppendix-clustersupport]]
cluster support
^^^^^^^^^^^^^^^

[Warning]
====


This endpoint provides no producer!

====

[[BookComponentAppendix-instanceconsumer-from("hazelcast:instance:foo")]]
instance consumer - from("hazelcast:instance:foo")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Hazelcast makes sense in one single "server node", but it's extremly
powerful in a clustered environment. The instance consumer fires if a
new cache instance will join or leave the cluster.

Here's a sample:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
fromF("hazelcast:%sfoo", HazelcastConstants.INSTANCE_PREFIX)
.log("instance...")
.choice()
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ADDED))
        .log("...added")
        .to("mock:added")
    .otherwise()
        .log("...removed")
        .to("mock:removed");
----

Each event provides the following information inside the message header:

Header Variables inside the response message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.listener.time` |`Long` |time of the event in millis

|`hazelcast.listener.type` |`String` |the map consumer sets here
"instancelistener"

|`hazelcast.listener.action` |`String` |type of event - here *added* or
*removed*

|`hazelcast.instance.host` |`String` |host name of the instance

|`hazelcast.instance.port` |`Integer` |port number of the instance
|=======================================================================

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastListenerTime` |`Long` |time of the event in millis
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerType` |`String` |the map consumer sets here
"instancelistener"
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerActionn` |`String` |type of event - here *added*
or *removed*.
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastInstanceHost` |`String` |host name of the instance
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastInstancePort` |`Integer` |port number of the instance
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

[[BookComponentAppendix-Usinghazelcastreference]]
Using hazelcast reference
^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-Byitsname]]
By its name
+++++++++++

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<bean id="hazelcastLifecycle" class="com.hazelcast.core.LifecycleService"
      factory-bean="hazelcastInstance" factory-method="getLifecycleService"
      destroy-method="shutdown" />

<bean id="config" class="com.hazelcast.config.Config">
    <constructor-arg type="java.lang.String" value="HZ.INSTANCE" />
</bean>

<bean id="hazelcastInstance" class="com.hazelcast.core.Hazelcast" factory-method="newHazelcastInstance">
    <constructor-arg type="com.hazelcast.config.Config" ref="config"/>
</bean>
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <route id="testHazelcastInstanceBeanRefPut">
        <from uri="direct:testHazelcastInstanceBeanRefPut"/>
        <setHeader headerName="CamelHazelcastOperationType">
            <constant>put</constant>
        </setHeader>
        <to uri="hazelcast:map:testmap?hazelcastInstanceName=HZ.INSTANCE"/>
    </route>

    <route id="testHazelcastInstanceBeanRefGet">
        <from uri="direct:testHazelcastInstanceBeanRefGet" />
        <setHeader headerName="CamelHazelcastOperationType">
            <constant>get</constant>
        </setHeader>
        <to uri="hazelcast:map:testmap?hazelcastInstanceName=HZ.INSTANCE"/>
        <to uri="seda:out" />
    </route>
</camelContext>
----

[[BookComponentAppendix-Byinstance]]
By instance
+++++++++++

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<bean id="hazelcastInstance" class="com.hazelcast.core.Hazelcast"
      factory-method="newHazelcastInstance" />
<bean id="hazelcastLifecycle" class="com.hazelcast.core.LifecycleService"
      factory-bean="hazelcastInstance" factory-method="getLifecycleService"
      destroy-method="shutdown" />

<camelContext xmlns="http://camel.apache.org/schema/spring">
    <route id="testHazelcastInstanceBeanRefPut">
        <from uri="direct:testHazelcastInstanceBeanRefPut"/>
        <setHeader headerName="CamelHazelcastOperationType">
            <constant>put</constant>
        </setHeader>
        <to uri="hazelcast:map:testmap?hazelcastInstance=#hazelcastInstance"/>
    </route>

    <route id="testHazelcastInstanceBeanRefGet">
        <from uri="direct:testHazelcastInstanceBeanRefGet" />
        <setHeader headerName="CamelHazelcastOperationType">
            <constant>get</constant>
        </setHeader>
        <to uri="hazelcast:map:testmap?hazelcastInstance=#hazelcastInstance"/>
        <to uri="seda:out" />
    </route>
</camelContext>
----

[[BookComponentAppendix-PublishinghazelcastinstanceasanOSGIservice]]
Publishing hazelcast instance as an OSGI service
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If operating in an OSGI container and you would want to use one instance
of hazelcast across all bundles in the same container. You can publish
the instance as an OSGI service and bundles using the cache al need is
to reference the service in the hazelcast endpoint.

[[BookComponentAppendix-BundleAcreateaninstanceandpublishesitasanOSGIservice]]
Bundle A create an instance and publishes it as an OSGI service
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<bean id="config" class="com.hazelcast.config.FileSystemXmlConfig">
    <argument type="java.lang.String" value="${hazelcast.config}"/>
</bean>

<bean id="hazelcastInstance" class="com.hazelcast.core.Hazelcast" factory-method="newHazelcastInstance">
    <argument type="com.hazelcast.config.Config" ref="config"/>
</bean>

<!-- publishing the hazelcastInstance as a service -->
<service ref="hazelcastInstance" interface="com.hazelcast.core.HazelcastInstance" />
----

[[BookComponentAppendix-BundleBusestheinstance]]
Bundle B uses the instance
++++++++++++++++++++++++++

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<!-- referencing the hazelcastInstance as a service -->
<reference ref="hazelcastInstance" interface="com.hazelcast.core.HazelcastInstance" />

<camelContext xmlns="http://camel.apache.org/schema/blueprint">
    <route id="testHazelcastInstanceBeanRefPut">
        <from uri="direct:testHazelcastInstanceBeanRefPut"/>
        <setHeader headerName="CamelHazelcastOperationType">
            <constant>put</constant>
        </setHeader>
        <to uri="hazelcast:map:testmap?hazelcastInstance=#hazelcastInstance"/>
    </route>

    <route id="testHazelcastInstanceBeanRefGet">
        <from uri="direct:testHazelcastInstanceBeanRefGet" />
        <setHeader headerName="CamelHazelcastOperationType">
            <constant>get</constant>
        </setHeader>
        <to uri="hazelcast:map:testmap?hazelcastInstance=#hazelcastInstance"/>
        <to uri="seda:out" />
    </route>
</camelContext>
----

[[BookComponentAppendix-replicatedmap]]

[[BookComponentAppendix-UsageofReplicatedmap]]
Usage of Replicated map
^^^^^^^^^^^^^^^^^^^^^^^

*Avalaible from Camel 2.16*

[[BookComponentAppendix-replicatedmapcacheproducer-to("hazelcast:replicatedmap:foo")]]
replicatedmap cache producer -
to("http://hazelcastreplicatedmapfoo[hazelcast:replicatedmap:foo]")
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

A replicated map is a weakly consistent, distributed key-value data
structure with no data partition. The replicatedmap producer provides 4
operations (put, get, delete, clear).

Header Variables for the request message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.operation.type` |`String` |valid values are: put, get,
delete, clear

|`hazelcast.objectId` |`String` |the object id to store / find your
object inside the cache
|=======================================================================

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastOperationType` |`String` |valid values are: put, get,
removevalue, delete
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastObjectId` |`String` |the object id to store / find your
object inside the cache
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

[[BookComponentAppendix-Sampleforput:.3]]
Sample for *put*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:put")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.PUT_OPERATION))
.to(String.format("hazelcast:%sbar", HazelcastConstants.REPLICATEDMAP_PREFIX));
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:put" />
    <log message="put.."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>put</constant>
    </setHeader>
    <to uri="hazelcast:replicatedmap:foo" />
</route>
----

[[BookComponentAppendix-Sampleforget:.4]]
Sample for *get*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:get")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.GET_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.REPLICATEDMAP_PREFIX)
.to("seda:out");
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:get" />
    <log message="get.."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>get</constant>
    </setHeader>
    <to uri="hazelcast:replicatedmap:foo" />
    <to uri="seda:out" />
</route>
----

[[BookComponentAppendix-Samplefordelete:.2]]
Sample for *delete*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:delete")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.DELETE_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.REPLICATEDMAP_PREFIX);
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:delete" />
    <log message="delete.."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>delete</constant>
    </setHeader>
    <to uri="hazelcast:replicatedmap:foo" />
</route>
----

you can call them in your test class with:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
template.sendBodyAndHeader("direct:[put|get|delete|clear]", "my-foo", HazelcastConstants.OBJECT_ID, "4711");
----

[[BookComponentAppendix-replicatedmapcacheconsumer-from("hazelcast:replicatedmap:foo")]]
replicatedmap cache consumer -
from("http://hazelcastreplicatedmapfoo[hazelcast:replicatedmap:foo]")
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

For the multimap cache this component provides the same listeners /
variables as for the map cache consumer (except the update and enviction
listener). The only difference is the *multimap* prefix inside the URI.
Here is a sample:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
fromF("hazelcast:%sbar", HazelcastConstants.MULTIMAP_PREFIX)
.log("object...")
.choice()
    .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ADDED))
        .log("...added")
                .to("mock:added")
        //.when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.ENVICTED))
        //        .log("...envicted")
        //        .to("mock:envicted")
        .when(header(HazelcastConstants.LISTENER_ACTION).isEqualTo(HazelcastConstants.REMOVED))
                .log("...removed")
                .to("mock:removed")
        .otherwise()
                .log("fail!");
----

Header Variables inside the response message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.listener.time` |`Long` |time of the event in millis

|`hazelcast.listener.type` |`String` |the map consumer sets here
"cachelistener"

|`hazelcast.listener.action` |`String` |type of event - here *added* and
*removed* (and soon *envicted*)

|`hazelcast.objectId` |`String` |the oid of the object

|`hazelcast.cache.name` |`String` |the name of the cache - e.g. "foo"

|`hazelcast.cache.type` |`String` |the type of the cache - here
replicatedmap
|=======================================================================

Eviction will be added as feature, soon (this is a Hazelcast issue).

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastListenerTime` |`Long` |time of the event in millis
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerType` |`String` |the map consumer sets here
"cachelistener"
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastListenerAction` |`String` |type of event - here *added*
and *removed* (and soon *envicted*)
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastObjectId` |`String` |the oid of the object
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastCacheName` |`String` |the name of the cache - e.g. "foo"
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastCacheType` |`String` |the type of the cache - here
replicatedmap
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

[[BookComponentAppendix-ringbuffer]]

[[BookComponentAppendix-UsageofRingbuffer]]
Usage of Ringbuffer
^^^^^^^^^^^^^^^^^^^

*Avalaible from Camel 2.16*

[[BookComponentAppendix-ringbuffercacheproducer-to("hazelcast:ringbuffer:foo")]]
ringbuffer cache producer -
to("http://hazelcastreplicatedmapfoo/[hazelcast:ringbuffer:foo]")
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Ringbuffer is a distributed data structure where the data is stored in a
ring-like structure. You can think of it as a circular array with a
certain capacity. The ringbuffer producer provides 5 operations (add,
readonceHead, readonceTail, remainingCapacity, capacity).

Header Variables for the request message:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`hazelcast.operation.type` |`String` |valid values are:
add, readonceHead, readonceTail, remainingCapacity, capacity
|=======================================================================

[Warning]
====


Header variables have changed in Camel 2.8

====

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelHazelcastOperationType` |`String` |valid values are: put, get,
removevalue, delete
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*

|`CamelHazelcastObjectId` |`String` |the object id to store / find your
object inside the cache
*https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Version+2.8&linkCreation=true&fromPageId=25202845[Version
2.8]*
|=======================================================================

[[BookComponentAppendix-Sampleforput:.4]]
Sample for *put*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:put")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.ADD_OPERATION))
.to(String.format("hazelcast:%sbar", HazelcastConstants.RINGBUFFER_PREFIX));
----

Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:put" />
    <log message="put.."/>
        <!-- If using version 2.8 and above set headerName to "CamelHazelcastOperationType" -->
    <setHeader headerName="hazelcast.operation.type">
        <constant>add</constant>
    </setHeader>
    <to uri="hazelcast:ringbuffer:foo" />
</route>
----

[[BookComponentAppendix-Sampleforreadoncefromhead:]]
Sample for *readonce from head*:

Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:get")
.setHeader(HazelcastConstants.OPERATION, constant(HazelcastConstants.READ_ONCE_HEAD_OPERATION))
.toF("hazelcast:%sbar", HazelcastConstants.RINGBUFFER_PREFIX)
.to("seda:out");
----

[[BookComponentAppendix-HDFSComponent]]
HDFS Component
~~~~~~~~~~~~~~

*Available as of Camel 2.8*

The *hdfs* component enables you to read and write messages from/to an
HDFS file system. HDFS is the distributed file system at the heart of
http://hadoop.apache.org[Hadoop].

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-hdfs</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.24]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
hdfs://hostname[:port][/path][?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...` +
The path is treated in the following way:

1.  as a consumer, if it's a file, it just reads the file, otherwise if
it represents a directory it scans all the file under the path
satisfying the configured pattern. All the files under that directory
must be of the same type.
2.  as a producer, if at least one split strategy is defined, the path
is considered a directory and under that directory the producer creates
a different file per split named using the configured
link:uuidgenerator.html[UuidGenerator].

[Note]
====


When consuming from hdfs then in normal mode, a file is split into
chunks, producing a message per chunk. You can configure the size of the
chunk using the chunkSize option. If you want to read from hdfs and
write to a regular file using the file component, then you can use the
fileMode=Append to append each of the chunks together.

====

 

[[BookComponentAppendix-Options.19]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`overwrite` |`true` |The file can be overwritten

|`append` |`false` |Append to existing file. Notice that not all HDFS
file systems support the append option.

|`bufferSize` |`4096` |The buffer size used by HDFS

|`replication` |`3` |The HDFS replication factor

|`blockSize` |`67108864` |The size of the HDFS blocks

|`fileType` |`NORMAL_FILE` |It can be SEQUENCE_FILE, MAP_FILE,
ARRAY_FILE, or BLOOMMAP_FILE, see Hadoop

|`fileSystemType` |`HDFS` |It can be LOCAL for local filesystem

|`keyType` |`NULL` |The type for the key in case of sequence or map
files. See below.

|`valueType` |`TEXT` |The type for the key in case of sequence or map
files. See below.

|`splitStrategy` |  |A string describing the strategy on how to split
the file based on different criteria. See below.

|`openedSuffix` |`opened` |When a file is opened for reading/writing the
file is renamed with this suffix to avoid to read it during the writing
phase.

|`readSuffix` |`read` |Once the file has been read is renamed with this
suffix to avoid to read it again.

|`initialDelay` |`0` |For the consumer, how much to wait (milliseconds)
before to start scanning the directory.

|`delay` |`0` |The interval (milliseconds) between the directory scans.

|`pattern` |`*` |The pattern used for scanning the directory

|`chunkSize` |`4096` |When reading a normal file, this is split into
chunks producing a message per chunk.

|`connectOnStartup` |`true` |*Camel 2.9.3/2.10.1:* Whether to connect to
the HDFS file system on starting the producer/consumer. If `false` then
the connection is created on-demand. Notice that HDFS may take up till
15 minutes to establish a connection, as it has hardcoded 45 x 20 sec
redelivery. By setting this option to `false` allows your application to
startup, and not block for up till 15 minutes.

|`owner` |  |*Camel 2.13/2.12.4:* The file owner must match this owner
for the consumer to pickup the file. Otherwise the file is skipped.
|=======================================================================

[[BookComponentAppendix-KeyTypeandValueType]]
KeyType and ValueType
+++++++++++++++++++++

* NULL it means that the key or the value is absent
* BYTE for writing a byte, the java Byte class is mapped into a BYTE
* BYTES for writing a sequence of bytes. It maps the java ByteBuffer
class
* INT for writing java integer
* FLOAT for writing java float
* LONG for writing java long
* DOUBLE for writing java double
* TEXT for writing java strings

BYTES is also used with everything else, for example, in Camel a file is
sent around as an InputStream, int this case is written in a sequence
file or a map file as a sequence of bytes.

[[BookComponentAppendix-SplittingStrategy]]
Splitting Strategy
^^^^^^^^^^^^^^^^^^

In the current version of Hadoop opening a file in append mode is
disabled since it's not very reliable. So, for the moment, it's only
possible to create new files. The Camel HDFS endpoint tries to solve
this problem in this way:

* If the split strategy option has been defined, the hdfs path will be
used as a directory and files will be created using the configured
link:uuidgenerator.html[UuidGenerator]
* Every time a splitting condition is met, a new file is created. +
The splitStrategy option is defined as a string with the following
syntax: +
splitStrategy=<ST>:<value>,<ST>:<value>,*

where <ST> can be:

* BYTES a new file is created, and the old is closed when the number of
written bytes is more than <value>
* MESSAGES a new file is created, and the old is closed when the number
of written messages is more than <value>
* IDLE a new file is created, and the old is closed when no writing
happened in the last <value> milliseconds

[Note]
====


note that this strategy currently requires either setting an IDLE value
or setting the HdfsConstants.HDFS_CLOSE header to false to use the
BYTES/MESSAGES configuration...otherwise, the file will be closed with
each message

====

for example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
hdfs://localhost/tmp/simple-file?splitStrategy=IDLE:1000,BYTES:5
----

it means: a new file is created either when it has been idle for more
than 1 second or if more than 5 bytes have been written. So, running
`hadoop fs -ls /tmp/simple-file` you'll see that multiple files have
been created.

[[BookComponentAppendix-MessageHeaders.4]]
Message Headers
^^^^^^^^^^^^^^^

The following headers are supported by this component:

[[BookComponentAppendix-Produceronly]]
Producer only
+++++++++++++

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelFileName` |*Camel 2.13:* Specifies the name of the file to write
(relative to the endpoint path). The name can be a `String` or an
link:expression.html[Expression] object. Only relevant when not using a
split strategy.
|=======================================================================

[[BookComponentAppendix-Controllingtoclosefilestream]]
Controlling to close file stream
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.10.4*

When using the link:hdfs.html[HDFS] producer *without* a split strategy,
then the file output stream is by default closed after the write.
However you may want to keep the stream open, and only explicitly close
the stream later. For that you can use the header
`HdfsConstants.HDFS_CLOSE` (value = `"CamelHdfsClose"`) to control this.
Setting this value to a boolean allows you to explicit control whether
the stream should be closed or not.

Notice this does not apply if you use a split strategy, as there are
various strategies that can control when the stream is closed.

[[BookComponentAppendix-UsingthiscomponentinOSGi]]
Using this component in OSGi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This component is fully functional in an OSGi environment, however, it
requires some actions from the user. Hadoop uses the thread context
class loader in order to load resources. Usually, the thread context
classloader will be the bundle class loader of the bundle that contains
the routes. So, the default configuration files need to be visible from
the bundle class loader. A typical way to deal with it is to keep a copy
of core-default.xml in your bundle root. That file can be found in the
hadoop-common.jar.

[[BookComponentAppendix-HibernateComponent]]
Hibernate Component
~~~~~~~~~~~~~~~~~~~

The *hibernate:* component allows you to work with databases using
Hibernate as the object relational mapping technology to map POJOs to
database tables. The *camel-hibernate* library is provided by the
http://code.google.com/p/camel-extra/[Camel Extra] project which hosts
all *GPL related components for Camel.

[Info]
====


Note that Camel also ships with a link:jpa.html[JPA] component. The
link:jpa.html[JPA] component abstracts from the underlying persistence
provider and allows you to work with Hibernate, OpenJPA or EclipseLink.

====

[[BookComponentAppendix-Sendingtotheendpoint.1]]
Sending to the endpoint
^^^^^^^^^^^^^^^^^^^^^^^

Sending POJOs to the hibernate endpoint inserts entities into the
database. The body of the message is assumed to be an entity bean that
you have mapped to a relational table using the hibernate `.hbm.xml`
files.

If the body does not contain an entity bean, use a
link:message-translator.html[Message Translator] in front of the
endpoint to perform the necessary conversion first.

[[BookComponentAppendix-Consumingfromtheendpoint.1]]
Consuming from the endpoint
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Consuming messages removes (or updates) entities in the database. This
allows you to use a database table as a logical queue; consumers take
messages from the queue and then delete/update them to logically remove
them from the queue.

If you do not wish to delete the entity when it has been processed, you
can specify `consumeDelete=false` on the URI. This will result in the
entity being processed each poll.

If you would rather perform some update on the entity to mark it as
processed (such as to exclude it from a future query) then you can
annotate a method with
http://activemq.apache.org/camel/maven/camel-hibernate/apidocs/org/apache/camel/component/hibernate/Consumed.html[@Consumed]
which will be invoked on your entity bean when the entity bean is
consumed.

[[BookComponentAppendix-URIformat.25]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
hibernate:[entityClassName][?options]
----

For sending to the endpoint, the *entityClassName* is optional. If
specified it is used to help use the type conversion to ensure the body
is of the correct type.

For consuming the *entityClassName* is mandatory.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.20]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`entityType` |_entityClassName_ |Is the provided _entityClassName_ from
the URI.

|`consumeDelete` |`true` |Option for HibernateConsumer only. Specifies
whether or not the entity is deleted after it is consumed.

|`consumeLockEntity` |`true` |Option for HibernateConsumer only.
Specifies whether or not to use exclusive locking of each entity while
processing the results from the pooling.

|`flushOnSend` |`true` |Option for HibernateProducer only. Flushes the
http://java.sun.com/javaee/5/docs/api/javax/persistence/EntityManager.html[EntityManager]
after the entity bean has been persisted.

|`maximumResults` |`-1` |Option for HibernateConsumer only. Set the
maximum number of results to retrieve on the
http://java.sun.com/javaee/5/docs/api/javax/persistence/Query.html[Query].

|`consumer.delay` |`500` |Option for HibernateConsumer only. Delay in
millis between each poll.

|`consumer.initialDelay` |`1000` |Option for HibernateConsumer only.
Millis before polling starts.

|`consumer.userFixedDelay` |`false` |Option for HibernateConsumer only.
Set to `true` to use fixed delay between polls, otherwise fixed rate is
used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.
|=======================================================================

[[BookComponentAppendix-SeeAlso.12]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:hibernate-example.html[Hibernate Example]

[[BookComponentAppendix-HipchatComponent]]
Hipchat Component
~~~~~~~~~~~~~~~~~

*Available as of Camel 2.15.0*

The Hipchat component supports producing and consuming messages from/to
https://www.hipchat.com[Hipchat] service.

[Info]
====
 **Prerequisites**

You must have a valid Hipchat user account and get a
https://www.hipchat.com/account/api[personal access token] that you can
use to produce/consume messages.

====

[[BookComponentAppendix-URIFormat.1]]
URI Format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
hipchat://[host][:port]?options
----

You can append query options to the URI in the following format,
?options=value&option2=value&...

[[BookComponentAppendix-URIOptions.4]]
URI Options
^^^^^^^^^^^

[width="99%",cols="20%,16%,16%,16%,16%,16%",options="header",]
|=======================================================================
|*Name* |*Default Value* |*Context* |*Required* |*Producer/Consumer*
|*Description*
|protocol |`null` |Shared |Yes |Both |Default protocol to connect to the
Hipchat server such as http or https

|host |null |Shared |Yes |Both |The API host of the Hipchat to connect
to, such as api.hipchat.com

|port |80 |Shared |No |Both |The port to connect to on the Hipchat host

|authToken |`null` |Shared |Yes |Both a|
Authorization token(personal access token) obtained from
https://www.hipchat.com/account/api[Hipchat]

 

|delay |5000 |Shared |No |Consumer |The poll interval in millisec for
consuming messages from consumeUsers provided. Please read about
https://www.hipchat.com/docs/apiv2/rate_limiting[rate limits] before
decreasing this.

|consumeUsers |`null` |Shared |No |Consumer |Comma separated list of
user @Mentions or emails whose messages to the owner of authToken must
be consumed
|=======================================================================

[[BookComponentAppendix-ScheduledPollConsumer]]
Scheduled Poll Consumer
^^^^^^^^^^^^^^^^^^^^^^^

This component implements the
link:polling-consumer.html[ScheduledPollConsumer]. Only the last message
from the provided 'consumeUsers' are retrieved and sent as Exchange
body. If you do not want the same message to be retrieved again when
there are no new messages on next poll then you can add the
link:idempotent-consumer.html[idempotent consumer] as shown below. All
the options on the link:polling-consumer.html[ScheduledPollConsumer] can
also be used for more control on the consumer.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Override
public void configure() throws Exception {
 String hipchatEndpointUri = "hipchat://?authToken=XXXX&consumeUsers=@Joe,@John";
 from(hipchatEndpointUri)
  .idempotentConsumer(
    simple("${in.header.HipchatMessageDate} ${in.header.HipchatFromUser}"),
    MemoryIdempotentRepository.memoryIdempotentRepository(200)
  )
  .to("mock:result");
}
----

[[BookComponentAppendix-MessageheaderssetbytheHipchatconsumer]]
Message headers set by the Hipchat consumer
+++++++++++++++++++++++++++++++++++++++++++

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|*Header* |*Constant* |*Type* |*Description*
|HipchatFromUser |HipchatConstants.FROM_USER |_String_ |The body has the
message that was sent from this user to the owner of authToken

|HipchatMessageDate |HipchatConstants.MESSAGE_DATE |_String_ |The date
message was sent. The format is ISO-8601 as present in the Hipchat
https://www.hipchat.com/docs/apiv2/method/view_recent_privatechat_history[response].

|HipchatFromUserResponseStatus
|HipchatConstants.FROM_USER_RESPONSE_STATUS 
|_http://hc.apache.org/httpcomponents-core-4.2.x/httpcore/apidocs/org/apache/http/StatusLine.html[StatusLine]_
|The status of the API response received.
|=======================================================================

[[BookComponentAppendix-HipchatProducer]]
Hipchat Producer
^^^^^^^^^^^^^^^^

Producer can send messages to both Room's and User's simultaneously. The
body of the exchange is sent as message. Sample usage is shown below.
Appropriate headers needs to be set.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Override
 public void configure() throws Exception {
  String hipchatEndpointUri = "hipchat://?authToken=XXXX";
  from("direct:start")
   .to(hipchatEndpointUri)
   .to("mock:result");
 }
----

[[BookComponentAppendix-MessageheadersevaluatedbytheHipchatproducer]]
Message headers evaluated by the Hipchat producer
+++++++++++++++++++++++++++++++++++++++++++++++++

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|*Header* |*Constant* |*Type* |*Description*
|HipchatToUser |HipchatConstants.TO_USER |_String_ |The Hipchat user to
which the message needs to be sent.

|HipchatToRoom |HipchatConstants.TO_ROOM |_String_ |The Hipchat room to
which the message needs to be sent.

|HipchatMessageFormat |HipchatConstants.MESSAGE_FORMAT |String |Valid
formats are 'text' or 'html'. *Default: 'text'*

|HipchatMessageBackgroundColor
|HipchatConstants.MESSAGE_BACKGROUND_COLOR |_String_ |Valid color values
are 'yellow', 'green', 'red', 'purple', 'gray', 'random'. *Default:
'yellow' (Room Only)* 

|HipchatTriggerNotification |HipchatConstants.TRIGGER_NOTIFY |_String_
|Valid values are 'true' or 'false'. Whether this message should trigger
a user notification (change the tab color, play a sound, notify mobile
phones, etc). *Default: 'false' (Room Only)*
|=======================================================================

[[BookComponentAppendix-MessageheaderssetbytheHipchatproducer]]
Message headers set by the Hipchat producer
+++++++++++++++++++++++++++++++++++++++++++

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|*Header* |*Constant* |*Type* |*Description*
|HipchatToUserResponseStatus |HipchatConstants.TO_USER_RESPONSE_STATUS
|_http://hc.apache.org/httpcomponents-core-4.2.x/httpcore/apidocs/org/apache/http/StatusLine.html[StatusLine]_
|The status of the API response received when message sent to the user.

|HipchatFromUserResponseStatus |HipchatConstants.TO_ROOM_RESPONSE_STATUS
|_http://hc.apache.org/httpcomponents-core-4.2.x/httpcore/apidocs/org/apache/http/StatusLine.html[StatusLine]_
|The status of the API response received when message sent to the room.
|=======================================================================

[[BookComponentAppendix-Dependencies.2]]
Dependencies
++++++++++++

Maven users will need to add the following dependency to their pom.xml.

*pom.xml*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-hipchat</artifactId>
    <version>${camel-version}</version>
</dependency>
----

where `${camel-version`} must be replaced by the actual version of Camel
(2.15.0 or higher)

[[BookComponentAppendix-HL7Component]]
HL7 Component
~~~~~~~~~~~~~

The *HL7* component is used for working with the HL7 MLLP protocol and
http://www.hl7.org/implement/standards/product_brief.cfm?product_id=185[HL7
v2 messages] using the http://hl7api.sourceforge.net[HAPI library].

This component supports the following:

* HL7 MLLP codec for link:mina2.html[Mina]
* HL7 MLLP codec for link:netty4.html[Netty4] from *Camel 2.15* onwards
* link:type-converter.html[Type Converter] from/to HAPI and String
* HL7 DataFormat using the HAPI library
* Even more ease-of-use as it's integrated well with the
link:mina2.html[camel-mina2] component.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-hl7</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency>

[[BookComponentAppendix-HL7MLLPprotocol]]
HL7 MLLP protocol
^^^^^^^^^^^^^^^^^

HL7 is often used with the HL7 MLLP protocol, which is a text based TCP
socket based protocol. This component ships with a Mina and Netty4 Codec
that conforms to the MLLP protocol so you can easily expose an HL7
listener accepting HL7 requests over the TCP transport layer. To expose
a HL7 listener service, the link:mina2.html[camel-mina2] or
link:netty4.html[camel-netty4] component is used with the
`HL7MLLPCodec` (mina2) or `HL7MLLPNettyDecoder/HL7MLLPNettyEncoder`
(Netty4).

HL7 MLLP codec can be configured as follows:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`startByte` |`0x0b` |The start byte spanning the HL7 payload.

|`endByte1` |`0x1c` |The first end byte spanning the HL7 payload.

|`endByte2` |`0x0d` |The 2nd end byte spanning the HL7 payload.

|`charset` |JVM Default |The encoding (a
http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html[charset
name]) to use for the codec. If not provided, Camel will use the
http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html#defaultCharset()[JVM
default Charset].

|`produceString` |`true` |*(as of Camel 2.14.1)* If true, the codec
creates a string using the defined charset. If false, the codec sends a
plain byte array into the route, so that the HL7 Data Format can
determine the actual charset from the HL7 message content.

|`convertLFtoCR` |`false` |Will convert `\n` to `\r` (`0x0d`, 13
decimal) as HL7 stipulates `\r` as segment terminators. The HAPI library
requires the use of `\r`.
|=======================================================================

[[BookComponentAppendix-ExposinganHL7listenerusingMina]]
Exposing an HL7 listener using Mina
+++++++++++++++++++++++++++++++++++

In the Spring XML file, we configure a mina2 endpoint to listen for HL7
requests using TCP on port `8888`:

xml <endpoint id="hl7MinaListener"
uri="mina2:tcp://localhost:8888?sync=true&amp;codec=#hl7codec"/>

*sync=true* indicates that this listener is synchronous and therefore
will return a HL7 response to the caller. The HL7 codec is setup with
*codec=#hl7codec*. Note that `hl7codec` is just a Spring bean ID, so it
could be named `mygreatcodecforhl7` or whatever. The codec is also set
up in the Spring XML file:

xml <bean id="hl7codec"
class="org.apache.camel.component.hl7.HL7MLLPCodec"> <property
name="charset" value="iso-8859-1"/> </bean>

The endpoint *hl7MinaLlistener* can then be used in a route as a
consumer, as this Java DSL example illustrates:

java from("hl7MinaListener").beanRef("patientLookupService");

This is a very simple route that will listen for HL7 and route it to a
service named *patientLookupService*. This is also Spring bean ID,
configured in the Spring XML as:

xml <bean id="patientLookupService"
class="com.mycompany.healthcare.service.PatientLookupService"/>

The business logic can be implemented in POJO classes that do not depend
on Camel, as shown here:

javaimport ca.uhn.hl7v2.HL7Exception; import ca.uhn.hl7v2.model.Message;
import ca.uhn.hl7v2.model.v24.segment.QRD; public class
PatientLookupService \{ public Message lookupPatient(Message input)
throws HL7Exception \{ QRD qrd = (QRD)input.get("QRD"); String patientId
= qrd.getWhoSubjectFilter(0).getIDNumber().getValue(); // find patient
data based on the patient id and create a HL7 model object with the
response Message response = ... create and set response data return
response }

[[BookComponentAppendix-ExposinganHL7listenerusingNetty(availablefromCamel2.15onwards)]]
Exposing an HL7 listener using Netty (available from Camel 2.15 onwards)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In the Spring XML file, we configure a netty4 endpoint to listen for HL7
requests using TCP on port `8888`:

xml <endpoint id="hl7NettyListener"
uri="netty4:tcp://localhost:8888?sync=true&amp;encoder=#hl7encoder&amp;decoder=#hl7decoder"/>

*sync=true* indicates that this listener is synchronous and therefore
will return a HL7 response to the caller. The HL7 codec is setup with
*encoder=#hl7encoder* and *decoder=#hl7decoder*. Note that `hl7encoder`
and `hl7decoder` are just bean IDs, so they could be named differently.
The beans can be set in the Spring XML file:

xml <bean id="hl7decoder"
class="org.apache.camel.component.hl7.HL7MLLPNettyDecoderFactory"/>  
<bean id="hl7encoder"
class="org.apache.camel.component.hl7.HL7MLLPNettyEncoderFactory"/>

The endpoint *hl7NettyListener* can then be used in a route as a
consumer, as this Java DSL example illustrates:

java from("hl7NettyListener").beanRef("patientLookupService");

[[BookComponentAppendix-HL7Modelusingjava.lang.Stringorbyte[]]]
HL7 Model using java.lang.String or byte[]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The HL7 MLLP codec uses plain String as its data format. Camel uses its
link:type-converter.html[Type Converter] to convert to/from strings to
the HAPI HL7 model objects, but you can use the plain String objects if
you prefer, for instance if you wish to parse the data yourself.

As of Camel 2.14.1 you can also let both the Mina and Netty codecs use a
plain `byte[]` as its data format by setting the `produceString`
property to false. The Type Converter is also capable of converting
the `byte[]` to/from HAPI HL7 model objects.

[[BookComponentAppendix-HL7v2ModelusingHAPI]]
HL7v2 Model using HAPI
^^^^^^^^^^^^^^^^^^^^^^

The HL7v2 model uses Java objects from the HAPI library. Using this
library, you can encode and decode from the EDI format (ER7) that is
mostly used with HL7v2.

The sample below is a request to lookup a patient with the patient ID
`0101701234`.

MSH|^~\\&|MYSENDER|MYRECEIVER|MYAPPLICATION||200612211200||QRY^A19|1234|P|2.4
QRD|200612211200|R|I|GetPatient|||1^RD|0101701234|DEM||

Using the HL7 model you can work with a `ca.uhn.hl7v2.model.Message`
object, e.g. to retrieve a patient ID:

javaMessage msg = exchange.getIn().getBody(Message.class); QRD qrd =
(QRD)msg.get("QRD"); String patientId =
qrd.getWhoSubjectFilter(0).getIDNumber().getValue(); // 0101701234

This is powerful when combined with the HL7 listener, because you don't
have to work with `byte[]`, `String` or any other simple object formats.
You can just use the HAPI HL7v2 model objects. If you know the message
type in advance, you can be more type-safe:

javaQRY_A19 msg = exchange.getIn().getBody(QRY_A19.class); String
patientId =
msg.getQRD().getWhoSubjectFilter(0).getIDNumber().getValue();

 

 

link:hl7-dataformat.html[HL7 DataFormat]

[[BookComponentAppendix-MessageHeaders.5]]
Message Headers
^^^^^^^^^^^^^^^

The unmarshal operation adds these fields from the MSH segment as
headers on the Camel message:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Key |MSH field |Example
|`CamelHL7SendingApplication` |`MSH-3` |`MYSERVER`

|`CamelHL7SendingFacility` |`MSH-4` |`MYSERVERAPP`

|`CamelHL7ReceivingApplication` |`MSH-5` |`MYCLIENT`

|`CamelHL7ReceivingFacility` |`MSH-6` |`MYCLIENTAPP`

|`CamelHL7Timestamp` |`MSH-7` |`20071231235900`

|`CamelHL7Security` |`MSH-8` |`null`

|`CamelHL7MessageType` |`MSH-9-1` |`ADT`

|`CamelHL7TriggerEvent` |`MSH-9-2` |`A01`

|`CamelHL7MessageControl` |`MSH-10` |`1234`

|`CamelHL7ProcessingId` |`MSH-11` |`P`

|`CamelHL7VersionId` |`MSH-12` |`2.4`

|`CamelHL7Context ``` |- |*(Camel 2.14)* contains the
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/HapiContext.html[HapiContext]
that +
was used to parse the message

|`CamelHL7Charset` |`MSH-18` |*(Camel 2.14.1)* `UNICODE UTF-8`
|=======================================================================

All headers except `CamelHL7Context `are `String` types. If a header
value is missing, its value is `null`.

[[BookComponentAppendix-Options.21]]
Options
^^^^^^^

The HL7 Data Format supports the following options:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`validate` |true |Whether the HAPI Parser should validate the message
using the default validation rules. It is recommended to use the
`parser` or `hapiContext` option and initialize it with the desired HAPI
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/validation/ValidationContext.html[`ValidationContext`]

|`parser` |`ca.uhn.hl7v2.parser.GenericParser` |Custom parser to be
used. Must be of type
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/parser/Parser.html[`ca.uhn.hl7v2.parser.Parser`].
Note that
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/parser/GenericParser.html[`GenericParser`]
also allows to parse XML-encoded HL7v2 messages

|`hapiContext` |`ca.uhn.hl7v2.DefaultHapiContext` |*Camel 2.14:* Custom
HAPI context that can define a custom parser, custom ValidationContext
etc. This gives you full control over the HL7 parsing and rendering
process.
|=======================================================================

[[BookComponentAppendix-Dependencies.3]]
Dependencies
^^^^^^^^^^^^

To use HL7 in your Camel routes you'll need to add a dependency on
*camel-hl7* listed above, which implements this data format.

The HAPI library is split into a
http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-base[base library] and
several structure libraries, one for each HL7v2 message version:

* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v21[v2.1
structures library]
* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v22[v2.2
structures library]
* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v23[v2.3
structures library]
* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v231[v2.3.1
structures library]
* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v24[v2.4
structures library]
* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v25[v2.5
structures library]
* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v251[v2.5.1
structures library]
* http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-structures-v26[v2.6
structures library]

By default `camel-hl7` only references the HAPI
http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-base[base library].
Applications are responsible for including structure libraries
themselves. For example, if an application works with HL7v2 message
versions 2.4 and 2.5 then the following dependencies must be added:

xml<dependency> <groupId>ca.uhn.hapi</groupId>
<artifactId>hapi-structures-v24</artifactId> <version>2.2</version> <!--
use the same version as your hapi-base version --> </dependency>
<dependency> <groupId>ca.uhn.hapi</groupId>
<artifactId>hapi-structures-v25</artifactId> <version>2.2</version> <!--
use the same version as your hapi-base version --> </dependency>

Alternatively, an OSGi bundle containing the base library, all
structures libraries and required dependencies (on the bundle classpath)
can be downloaded from the
http://repo1.maven.org/maven2/ca/uhn/hapi/hapi-osgi-base[central Maven
repository].

xml<dependency> <groupId>ca.uhn.hapi</groupId>
<artifactId>hapi-osgi-base</artifactId> <version>2.2</version>
</dependency>

[[BookComponentAppendix-Terserlanguage]]
Terser language
^^^^^^^^^^^^^^^

http://hl7api.sourceforge.net[HAPI] provides a
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/util/Terser.html[Terser]
class that provides access to fields using a commonly used terse
location specification syntax. The Terser language allows to use this
syntax to extract values from messages and to use them as expressions
and predicates for filtering, content-based routing etc.

Sample:

javaimport static org.apache.camel.component.hl7.HL7.terser; ... //
extract patient ID from field QRD-8 in the QRY_A19 message above and put
into message header from("direct:test1")
.setHeader("PATIENT_ID",terser("QRD-8(0)-1")) .to("mock:test1");  //
continue processing if extracted field equals a message header
from("direct:test2")
.filter(terser("QRD-8(0)-1").isEqualTo(header("PATIENT_ID"))
.to("mock:test2");

[[BookComponentAppendix-HL7Validationpredicate]]
HL7 Validation predicate
^^^^^^^^^^^^^^^^^^^^^^^^

Often it is preferable to first parse a HL7v2 message and in a separate
step validate it against a HAPI
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/validation/ValidationContext.html[ValidationContext].

Sample:

javaimport static org.apache.camel.component.hl7.HL7.messageConformsTo;
import ca.uhn.hl7v2.validation.impl.DefaultValidation; ... // Use
standard or define your own validation rules ValidationContext
defaultContext = new DefaultValidation(); // Throws
PredicateValidationException if message does not validate
from("direct:test1") .validate(messageConformsTo(defaultContext))
.to("mock:test1");

[[BookComponentAppendix-HL7ValidationpredicateusingtheHapiContext(Camel2.14)]]
HL7 Validation predicate using the HapiContext (Camel 2.14)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The HAPI Context is always configured with a
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/validation/ValidationContext.html[ValidationContext]
(or a
http://hl7api.sourceforge.net/base/apidocs/ca/uhn/hl7v2/validation/builder/ValidationRuleBuilder.html[ValidationRuleBuilder]),
so you can access the validation rules indirectly. Furthermore, when
unmarshalling the HL7DataFormat forwards the configured HAPI context in
the `CamelHL7Context` header, and the validation rules of this context
can be easily reused:

javaimport static org.apache.camel.component.hl7.HL7.messageConformsTo;
import static org.apache.camel.component.hl7.HL7.messageConforms ...
HapiContext hapiContext = new DefaultHapiContext();
hapiContext.getParserConfiguration().setValidating(false); // don't
validate during parsing // customize HapiContext some more ... e.g.
enforce that PID-8 in ADT_A01 messages of version 2.4 is not empty
ValidationRuleBuilder builder = new ValidationRuleBuilder() \{ @Override
protected void configure() \{ forVersion(Version.V24) .message("ADT",
"A01") .terser("PID-8", not(empty())); } };
hapiContext.setValidationRuleBuilder(builder); HL7DataFormat hl7 = new
HL7DataFormat(); hl7.setHapiContext(hapiContext); from("direct:test1")
.unmarshal(hl7) // uses the GenericParser returned from the HapiContext
.validate(messageConforms()) // uses the validation rules returned from
the HapiContext // equivalent with
.validate(messageConformsTo(hapiContext)) // route continues from here

 

[[BookComponentAppendix-HL7Acknowledgementexpression]]
HL7 Acknowledgement expression
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A common task in HL7v2 processing is to generate an acknowledgement
message as response to an incoming HL7v2 message, e.g. based on a
validation result. The `ack` expression lets us accomplish this very
elegantly:

javaimport static org.apache.camel.component.hl7.HL7.messageConformsTo;
import static org.apache.camel.component.hl7.HL7.ack; import
ca.uhn.hl7v2.validation.impl.DefaultValidation; ... // Use standard or
define your own validation rules ValidationContext defaultContext = new
DefaultValidation(); from("direct:test1") .onException(Exception.class)
.handled(true) .transform(ack()) // auto-generates negative ack because
of exception in Exchange .end()
.validate(messageConformsTo(defaultContext)) // do something meaningful
here ... // acknowledgement .transform(ack())

[[BookComponentAppendix-MoreSamples]]
More Samples
^^^^^^^^^^^^

In the following example, a plain `String` HL7 request is sent to an HL7
listener that sends back a response:

\{snippet:id=e2|lang=java|url=camel/trunk/components/camel-hl7/src/test/java/org/apache/camel/component/hl7/HL7MLLPCodecTest.java}

In the next sample, HL7 requests from the HL7 listener are routed to the
business logic, which is implemented as plain POJO registered in the
registry as `hl7service`.

\{snippet:id=e2|lang=java|url=camel/trunk/components/camel-hl7/src/test/java/org/apache/camel/component/hl7/HL7RouteTest.java}

Then the Camel routes using the `RouteBuilder` may look as follows:

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-hl7/src/test/java/org/apache/camel/component/hl7/HL7RouteTest.java}

Note that by using the HL7 DataFormat the Camel message headers are
populated with the fields from the MSH segment. The headers are
particularly useful for filtering or content-based routing as shown in
the example above.

 

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-HTTPComponent]]
HTTP Component
~~~~~~~~~~~~~~

The *http:* component provides HTTP based link:endpoint.html[endpoints]
for consuming external HTTP resources (as a client to call external
servers using HTTP).

Maven users will need to add the following dependency to their
*`pom.xml`* for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-http</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIFormat.2]]
URI Format
^^^^^^^^^^

http:hostname[:port][/resourceUri][?param1=value1][&param2=value2]

Will by default use port *`80`* for HTTP and *`443`* for HTTPS.

camel-http vs camel-jetty

You can only produce to endpoints generated by the HTTP component.
Therefore it should never be used as input into your camel Routes. To
bind/expose an HTTP endpoint via a HTTP server as input to a camel
route, you can use the link:jetty.html[Jetty Component] or the
link:servlet.html[Servlet Component]

[[BookComponentAppendix-Examples.6]]
Examples
^^^^^^^^

Call the URL with the body using *`POST`* and return response as
the *`OUT`* message. If body is *`null`* call URL using *`GET`* and
return response as *`OUT`* message:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Java DSL |Spring DSL
|from("direct:start") .to("http://myhost/mypath"); |xml<from
uri="direct:start"/> <to uri="http://oldhost"/>
|=======================================================================

You can override the HTTP endpoint URI by adding a header. Camel will
call the http://newhost. This is very handy for e.g. REST URLs:

[width="100%",cols="100%",options="header",]
|=======================================================================
|Java DSL
|javafrom("direct:start") .setHeader(Exchange.HTTP_URI,
simple("http://myserver/orders/$\{header.orderId}"))
.to("http://dummyhost");
|=======================================================================

URI parameters can either be set directly on the endpoint URI or as a
header:

[width="100%",cols="100%",options="header",]
|=======================================================================
|Java DSL
|javafrom("direct:start") .to("http://oldhost?order=123&detail=short");
from("direct:start") .setHeader(Exchange.HTTP_QUERY,
constant("order=123&detail=short")) .to("http://oldhost");
|=======================================================================

Set the HTTP request method to *`POST`*:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Java DSL |Spring DSL
|from("direct:start") .setHeader(Exchange.HTTP_METHOD, constant("POST"))
.to("http://www.google.com"); |xml<from uri="direct:start"/> <setHeader
headerName="CamelHttpMethod"> <constant>POST</constant> </setHeader> <to
uri="http://www.google.com"/> <to uri="mock:results"/>
|=======================================================================

[[BookComponentAppendix-HttpEndpointOptions]]
`HttpEndpoint` Options
^^^^^^^^^^^^^^^^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`throwExceptionOnFailure` |`true` |Option to disable throwing the
*`HttpOperationFailedException`* in case of failed responses from the
remote server. This allows you to get all responses regardless of the
HTTP status code.

|`bridgeEndpoint` |`false` a|
If the option is *`true`*, *`HttpProducer`* will ignore
the *`Exchange.HTTP_URI`* header, and use the endpoint's URI for
request. You may also set *`throwExceptionOnFailure=false`* to ensure
all responses are propagated back to the  *`HttpProducer`*.

From *Camel 2.3:* when *`true`* the *`HttpProducer`*
and *`CamelServlet`* will skip *`gzip`* processing when
*`content-encoding=gzip`*.

|`disableStreamCache` |`false` a|
When *`false`* the *`DefaultHttpBinding`* will copy the request input
stream into a stream cache and put it into message body which allows it
to be read more than once.

When *`true`* the *`DefaultHttpBinding`* will set the request input
stream direct into the message body.

From *Camel 2.17:* this options is now also support by the producer to
allow using the response stream directly instead of stream caching as by
default.

|[line-through]*`httpBindingRef`* |[line-through]*`null`*
|[line-through]**Deprecated and removed in Camel 2.17:* Reference to a
`org.apache.camel.component.http.HttpBinding` in the
link:registry.html[Registry]. Use the `httpBinding` option instead.*

|`httpBinding` |`null` |From *Camel 2.3:* reference to a
*`org.apache.camel.component.http.HttpBinding`* in the
link:registry.html[Registry].

|[line-through]*`httpClientConfigurerRef`* |[line-through]*`null`*
|[line-through]**Deprecated and removed in Camel 2.17:* Reference to a
`org.apache.camel.component.http.HttpClientConfigurer` in the
link:registry.html[Registry]. Use the `httpClientConfigurer` option
instead.*

|`httpClientConfigurer` |`null` |From *Camel 2.3:* reference to a
*`org.apache.camel.component.http.HttpClientConfigurer`* in the
link:registry.html[Registry].

|`httpClient.XXX` |`null` a|
Use this to option to configure the underlying
http://hc.apache.org/httpclient-3.x/apidocs/org/apache/commons/httpclient/params/HttpClientParams.html[HttpClientParams].

Example: *`httpClient.soTimeout=5000`* will set the *`SO_TIMEOUT`* to 5
seconds.

|`clientConnectionManager` |`null` |To use a custom
*`org.apache.http.conn.ClientConnectionManager`*.

|`transferException` |`false` a|
From *Camel 2.6:* If enabled and an link:exchange.html[Exchange] failed
processing on the consumer side, and if the caused *`Exception`* was
send back serialized in the response as a
*`application/x-java-serialized-object`* content type (for example using
link:jetty.html[Jetty] or link:servlet.html[SERVLET] Camel components).

On the producer side the exception will be deserialized and thrown as
is, instead of the *`HttpOperationFailedException`*. The caused
exception will be serialized.

|`headerFilterStrategy` |`null` |From *Camel 2.11:* reference to a
instance of *`org.apache.camel.spi.HeaderFilterStrategy`* in the
link:registry.html[Registry]. It will be used to apply the
custom *`headerFilterStrategy`* on the new create *`HttpEndpoint`*.

|`urlRewrite` |`null` a|
From *Camel 2.11:* _*Producer only!*_

Refers to a custom *`org.apache.camel.component.http.UrlRewrite`* which
allows you to rewrite URLs when you bridge/proxy endpoints.

See more details at link:urlrewrite.html[UrlRewrite] and
link:how-to-use-camel-as-a-http-proxy-between-a-client-and-server.html[How
to use Camel as a HTTP proxy between a client and server].

|`eagerCheckContentAvailable` |`false` a|
From *Camel 2.15.3/2.16:* _*Consumer only*!_

Whether to eager check whether the HTTP requests has content when
*`content-length=0`* or is not present.

This option should be set to *`true`* for those HTTP clients that do not
send streamed data.

|`copyHeaders` |`true` a|
From *Camel 2.16:* if this option is true then *`IN`* exchange headers
will be copied to *`OUT`* exchange headers according to copy strategy.

Setting this to *`false`*, allows to only include the headers from the
HTTP response (not propagating *`IN`* headers).

|`okStatusCodeRange` |`200-299` |From *Camel 2.16:* the range of HTTP
status codes for which a response is considered a success. The values
are inclusive. The range must be in the form *`from-to`*, dash included.

|`ignoreResponseBody` |`false` |From *Camel 2.16:* when *`true`*
the *`HttpProducer`* will not read the response body nor cache the input
stream.

|`cookieHandler` |`null` |From *Camel: 2.19:* configure a cookie handler
to maintain a HTTP session
|=======================================================================

[[BookComponentAppendix-AuthenticationandProxy]]
Authentication and Proxy
^^^^^^^^^^^^^^^^^^^^^^^^

The following authentication options can also be set on the
*`HttpEndpoint`*:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`authMethod` |`null` |Authentication method, either as *`Basic`*,
*`Digest`* or *`NTLM`*.

|`authMethodPriority` |`null` a|
Priority of authentication methods. Is a list separated with comma.

For example: `Basic,Digest` to exclude *`NTLM`*.

|`authUsername` |`null` |Username for authentication.

|`authPassword` |`null` |Password for authentication.

|`authDomain` |`null` |Domain for *`NTLM`* authentication.

|`authHost` |`null` |Optional host for *`NTLM`* authentication.

|`proxyHost` |`null` |The proxy host name.

|`proxyPort` |`null` |The proxy port number.

|`proxyAuthMethod` |`null` |Authentication method for proxy, either as
*`Basic`*, *`Digest`* or *`NTLM`*.

|`proxyAuthUsername` |`null` |Username for proxy authentication.

|`proxyAuthPassword` |`null` |Password for proxy authentication.

|`proxyAuthDomain` |`null` |Domain for proxy *`NTLM`* authentication.

|`proxyAuthHost` |`null` |Optional host for proxy *`NTLM`*
authentication.
|=======================================================================

When using authentication you *must* provide the choice of method for
the *`authMethod`* or *`authProxyMethod`* options. You can configure the
proxy and authentication details on either the *`HttpComponent`* or the
*`HttpEndoint`*. Values provided on the *`HttpEndpoint`* will take
precedence over *`HttpComponent`*. Its most likely best to configure
this on the *`HttpComponent`* which allows you to do this once.

The link:http.html[HTTP] component uses convention over configuration
which means that if you have not explicit set a *`authMethodPriority`*
then it will fallback and use the select(ed) *`authMethod`* as priority
as well. So if you use *`authMethod.Basic`* then the
*`auhtMethodPriority`* will be *`Basic`* only.

*Note*: *`camel-http`* is based on HttpClient v3.x and as such has only
http://hc.apache.org/httpclient-3.x/authentication.html#NTLM[limited
support] for what is known as NTLMv1, the early version of the NTLM
protocol. It does not support NTLMv2 at all. *`camel-http4`* has support
for NTLMv2.

[[BookComponentAppendix-HttpComponentOptions]]
`HttpComponent` Options
^^^^^^^^^^^^^^^^^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`httpBinding` |`null` |To use a custom
*`org.apache.camel.component.http.HttpBinding`*.

|`httpClientConfigurer` |`null` |To use a custom
*`org.apache.camel.component.http.HttpClientConfigurer`*.

|`httpConnectionManager` |`null` |To use a custom
*`org.apache.commons.httpclient.HttpConnectionManager`*.

|`httpConfiguration` |`null` |To use a custom
*`org.apache.camel.component.http.HttpConfiguration.`*

|`allowJavaSerializedObject` |`false` a|
*Camel 2.16.1/2.15.5:* Whether to allow java serialization when a
request uses *`context-type=application/x-java-serialized-object`*.

If you enable this then be aware that Java will deserialize the incoming
data from the request to Java and that can be a potential security risk.

|=======================================================================

*`HttpConfiguration`* contains all the options listed in the table above
under the section _HttpConfiguration - Setting Authentication and
Proxy_.

[[BookComponentAppendix-MessageHeaders.6]]
Message Headers
^^^^^^^^^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`Exchange.HTTP_URI` |`String` |URI to call. Will override existing URI
set directly on the endpoint. This URI is the URI of the HTTP server to
call. Its not the same as the Camel endpoint URI, where you can
configure endpoint options such as security etc. This header does not
support that, its only the URI of the HTTP server.

|`Exchange.HTTP_METHOD` |`String` a|
HTTP method/verb to use.

Can be one of:

* *`GET`*
* *`POST`*
* *`PUT`*
* *`DELETE`*
* *`HEAD`*
* *`OPTIONS`*
* *`TRACE`*

|`Exchange.HTTP_PATH` |`String` a|
The request URI's path. The header will be used to build the request URI
with the *`HTTP_URI`*.

From *Camel 2.3.0:* if the path starts with a *`/`*,
the *`HttpProducer`* will try to find the relative path based on
the *`Exchange.HTTP_BASE_URI`* header or the
*`exchange.getFromEndpoint().getEndpointUri();`*.

|`Exchange.HTTP_QUERY` |`String` |URI parameters. Will override existing
URI parameters set directly on the endpoint.

|`Exchange.HTTP_RESPONSE_CODE` |`int` |The HTTP response code from the
external server. Is *`200`* for OK.

|`Exchange.HTTP_CHARACTER_ENCODING` |`String` |Character encoding.

|`Exchange.CONTENT_TYPE` |`String` |The HTTP content type. Is set on
both the *`IN`* and *`OUT`* message to provide a content type, such as
*`text/html`*.

|`Exchange.CONTENT_ENCODING` |`String` |The HTTP content encoding. Is
set on both the *`IN`* and *`OUT`* message to provide a content
encoding, such as *`gzip`.*

|`Exchange.HTTP_SERVLET_REQUEST` |`HttpServletRequest` |The
*`HttpServletRequest`* object.

|`Exchange.HTTP_SERVLET_RESPONSE` |`HttpServletResponse` |The
*`HttpServletResponse`* object.

|`Exchange.HTTP_PROTOCOL_VERSION` |`String` |From *Camel 2.5:* You can
set the HTTP protocol version with this header, e.g., *`HTTP/1.0`*. If
the header is not present the *`HttpProducer`* will use the default
value *`HTTP/1.1`*.
|=======================================================================

*Note*: The header names above are constants. For the spring DSL you
have to use the value of the constant instead of the name.

[[BookComponentAppendix-MessageBody.1]]
Message Body
^^^^^^^^^^^^

Camel will store the HTTP response from the external server on
the *`OUT`* body. All headers from the *`IN`* message will be copied to
the *`OUT`* message, so headers are preserved during routing.
Additionally Camel will add the HTTP response headers as well to
the *`OUT`* message headers.

[[BookComponentAppendix-ResponseCode]]
Response Code
^^^^^^^^^^^^^

Camel will handle according to the HTTP response code:

* Response code is in the range *`100..299`*, Camel regards it as a
success response.
* Response code is in the range *`300..399`*, Camel regards it as a
redirection response and will throw a *`HttpOperationFailedException`*
with the information.
* Response code is *`400+`*, Camel regards it as an external server
failure and will throw a *`HttpOperationFailedException`* with the
information.
+
throwExceptionOnFailure
+
The option, *`throwExceptionOnFailure`,* can be set to *`false`* to
prevent the *`HttpOperationFailedException`* from being thrown for
failed response codes. This allows you to get any response from the
remote server. +
There is a sample below demonstrating this.

[[BookComponentAppendix-HttpOperationFailedException]]
`HttpOperationFailedException`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This exception contains the following information:

* The HTTP status code.
* The HTTP status line (text of the status code).
* Redirect location, if server returned a redirect.
* Response body as a *`java.lang.String`*, if server provided a body as
response.

[[BookComponentAppendix-CallingUsingGETorPOST]]
Calling Using `GET` or `POST`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following algorithm is used to determine if either *`GET`* or
*`POST`* HTTP method should be used:

1.  Use method provided in header.
2.  *`GET`* if query string is provided in header.
3.  *`GET`* if endpoint is configured with a query string.
4.  *`POST`* if there is data to send (body is not null).
5.  *`GET`* otherwise.

[[BookComponentAppendix-HowToAccessTheHttpServletRequestandHttpServletResponse]]
How To Access The `HttpServletRequest` and `HttpServletResponse`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can get access to these two using the Camel type converter system
using:

javaHttpServletRequest request =
exchange.getIn().getBody(HttpServletRequest.class); HttpServletRequest
response = exchange.getIn().getBody(HttpServletResponse.class);

[[BookComponentAppendix-UsingClientTimeout-SO_TIMEOUT]]
Using Client Timeout - `SO_TIMEOUT`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

See the unit test in
http://svn.apache.org/viewvc?view=rev&revision=781775[this link]

[[BookComponentAppendix-MoreExamples]]
More Examples
~~~~~~~~~~~~~

[[BookComponentAppendix-ConfiguringaProxy]]
Configuring a Proxy
^^^^^^^^^^^^^^^^^^^

[width="100%",cols="100%",options="header",]
|=======================================================================
|Java DSL
|from("direct:start")
.to("http://oldhost?proxyHost=www.myproxy.com&proxyPort=80");
|=======================================================================

There is also support for proxy authentication via the *`proxyUsername`*
and *`proxyPassword`* options.

[[BookComponentAppendix-UsingProxySettingsOutsideoftheURI]]
Using Proxy Settings Outside of the URI
+++++++++++++++++++++++++++++++++++++++

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Java DSL |Spring DSL
|context.getProperties().put("http.proxyHost", "172.168.18.9");
context.getProperties().put("http.proxyPort" "8080"); |<camelContext>
<properties> <property key="http.proxyHost" value="172.168.18.9"/>
<property key="http.proxyPort" value="8080"/> </properties>
</camelContext>
|=======================================================================

Options on *`Endpoint`* will override options on the context.

[[BookComponentAppendix-Configuringcharset]]
Configuring `charset`
^^^^^^^^^^^^^^^^^^^^^

If you are using *`POST`* to send data you can configure the
*`charset`*:

.setProperty(Exchange.CHARSET_NAME, "iso-8859-1");

[[BookComponentAppendix-SamplewithScheduledPoll]]
Sample with Scheduled Poll
^^^^^^^^^^^^^^^^^^^^^^^^^^

The sample polls the Google homepage every 10 seconds and write the page
to the file *`message.html`*:

javafrom("timer://foo?fixedRate=true&delay=0&period=10000")
.to("http://www.google.com") .setHeader(FileComponent.HEADER_FILE_NAME,
"message.html") .to("file:target/google");

[[BookComponentAppendix-GettingtheResponseCode]]
Getting the Response Code
^^^^^^^^^^^^^^^^^^^^^^^^^

You can get the HTTP response code from the HTTP component by getting
the value from the *`OUT`* message header with
*`Exchange.HTTP_RESPONSE_CODE`*:

javaExchange exchange = template.send("http://www.google.com/search",
new Processor() \{ public void process(Exchange exchange) throws
Exception \{ exchange.getIn().setHeader(Exchange.HTTP_QUERY,
constant("hl=en&q=activemq")); } }); Message out = exchange.getOut();
int responseCode = out.getHeader(Exchange.HTTP_RESPONSE_CODE,
Integer.class);

[[BookComponentAppendix-UsingthrowExceptionOnFailure=falseToObtainAllServerResponses]]
Using `throwExceptionOnFailure=false` To Obtain All Server Responses
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the route below we want to route a message that we
link:content-enricher.html[enrich] with data returned from a remote HTTP
call. As we want all responses from the remote server, we set the
*`throwExceptionOnFailure=false`* so we get any response in the
*`AggregationStrategy`*. As the code is based on a unit test that
simulates a HTTP status code 404, there is some assertion code
etc.\{snippet:id=e1|lang=java|url=camel/tags/camel-2.2.0/components/camel-jetty/src/test/java/org/apache/camel/component/jetty/JettySimplifiedHandle404Test.java}

[[BookComponentAppendix-DisablingCookies]]
Disabling Cookies
^^^^^^^^^^^^^^^^^

To disable cookies you can set the HTTP Client to ignore cookies by
adding this URI option: *`httpClient.cookiePolicy=ignoreCookies`*

[[BookComponentAppendix-AdvancedUsage]]
Advanced Usage
^^^^^^^^^^^^^^

If you need more control over the HTTP producer you should use the
*`HttpComponent`* where you can set various classes to give you custom
behavior.

[[BookComponentAppendix-SettingMaxConnectionsPerHost]]
Setting `MaxConnectionsPerHost`
+++++++++++++++++++++++++++++++

The link:http.html[HTTP] Component has a
*`org.apache.commons.httpclient.HttpConnectionManager`* where you can
configure various global configuration for the given component. By
global, we mean that any endpoint the component creates has the same
shared *`HttpConnectionManager`*. So, if we want to set a different
value for the max connection per host, we need to define it on the HTTP
component and _not_ on the endpoint URI that we usually use. So here
comes:

First, we define the *`http`* component in Spring XML. Yes, we use the
same scheme name, *`http`*, because otherwise Camel will auto-discover
and create the component with default settings. What we need is to
overrule this so we can set our options. In the sample below we set the
max connection to 5 instead of the default of
2.\{snippet:id=e1|lang=xml|url=camel/tags/camel-2.2.0/tests/camel-itest/src/test/resources/org/apache/camel/itest/http/HttpMaxConnectionPerHostTest-context.xml}And
then we can just use it as we normally do in our
routes:\{snippet:id=e2|lang=xml|url=camel/tags/camel-2.2.0/tests/camel-itest/src/test/resources/org/apache/camel/itest/http/HttpMaxConnectionPerHostTest-context.xml}

[[BookComponentAppendix-UsingPre-EmptiveAuthentication]]
Using Pre-Emptive Authentication
++++++++++++++++++++++++++++++++

If an HTTP server should fail to respond correctly with an expected
`401 Authorization Required` response for a failed authentication
attempt a client can instead use preemptive authentication by specifying
the URI option: *`httpClient.authenticationPreemptive=true`*.

[[BookComponentAppendix-AcceptingSelf-SignedCertificatesFromRemoteServer]]
Accepting Self-Signed Certificates From Remote Server
+++++++++++++++++++++++++++++++++++++++++++++++++++++

See this
http://www.nabble.com/Using-HTTPS-in-camel-http-when-remote-side-has-self-signed-cert-td25916878.html[link]
from a mailing list discussion with some code to outline how to do this
with the Apache Commons HTTP API.

[[BookComponentAppendix-SettingupSSLforHTTPClient]]
Setting up SSL for HTTP Client
++++++++++++++++++++++++++++++

[[BookComponentAppendix-UsingtheJSSEConfigurationUtility.1]]
Using the JSSE Configuration Utility

From *Camel 2.8*: the *`HTTP4`* component supports SSL/TLS configuration
through the link:camel-configuration-utilities.html[Camel JSSE
Configuration Utility].  This utility greatly decreases the amount of
component specific code you need to write and is configurable at the
endpoint and component levels.  The following examples demonstrate how
to use the utility with the *`HTTP4`* component.

The version of the Apache HTTP client used in this component resolves
SSL/TLS information from a global "protocol" registry.  This component
provides an implementation,
*`org.apache.camel.component.http.SSLContextParametersSecureProtocolSocketFactory`*,
of the HTTP client's protocol socket factory in order to support the use
of the Camel JSSE Configuration utility.  The following example
demonstrates how to configure the protocol registry and use the
registered protocol information in a route.

javaKeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("/users/home/server/keystore.jks");
ksp.setPassword("keystorePassword"); KeyManagersParameters kmp = new
KeyManagersParameters(); kmp.setKeyStore(ksp);
kmp.setKeyPassword("keyPassword"); SSLContextParameters scp = new
SSLContextParameters(); scp.setKeyManagers(kmp); ProtocolSocketFactory
factory = new SSLContextParametersSecureProtocolSocketFactory(scp);
Protocol.registerProtocol("https", new Protocol("https", factory, 443));
from("direct:start") .to("https://mail.google.com/mail/")
.to("mock:results");

[[BookComponentAppendix-ConfiguringApacheHTTPClientDirectly]]
Configuring Apache HTTP Client Directly

Basically *`camel-http`* component is built on the top of Apache HTTP
client, and you can implement a custom
*`org.apache.camel.component.http.HttpClientConfigurer`* to do some
configuration on the HTTP client if you need full control of it.

However, if you _just_ want to specify the *`keystore`*
and *`truststore`* you can do this with Apache HTTP
*`HttpClientConfigurer`*, for example:

javaProtocol authhttps = new Protocol("https", new
AuthSSLProtocolSocketFactory(new URL("file:my.keystore"), "mypassword",
new URL("file:my.truststore"), "mypassword"), 443);
Protocol.registerProtocol("https", authhttps);

And then you need to create a class that implements
*`HttpClientConfigurer`*, and registers HTTPS protocol providing
a *`keystore`* or *`truststore`* per example above. Then, from your
Camel RouteBuilder class you can hook it up like so:

javaHttpComponent httpComponent = getContext().getComponent("http",
HttpComponent.class); httpComponent.setHttpClientConfigurer(new
MyHttpClientConfigurer());

If you are doing this using the Spring DSL, you can specify your
*`HttpClientConfigurer`* using the URI. For example:

xml<bean id="myHttpClientConfigurer"
class="my.https.HttpClientConfigurer"/> <to
uri="https://myhostname.com:443/myURL?httpClientConfigurerRef=myHttpClientConfigurer"/>

As long as you implement the *`HttpClientConfigurer`* and configure
your *`keystore`* and *`truststore`* as described above, it will work
fine.

link:endpoint-see-also.html[Endpoint See Also]

* link:jetty.html[Jetty]

[[BookComponentAppendix-iBATIS]]
iBATIS
~~~~~~

The *ibatis:* component allows you to query, poll, insert, update and
delete data in a relational database using
http://ibatis.apache.org/[Apache iBATIS].

Prefer MyBatis

The Apache iBatis project is no longer active. The project is moved
outside Apache and is now know as the MyBatis project. +
Therefore we encourage users to use link:mybatis.html[MyBatis] instead.
This camel-ibatis component will be removed in Camel 3.0.

iBatis do not support Spring 4.x. So you can only use Spring 3.x or
older with iBatis.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-ibatis</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.26]]
URI format
^^^^^^^^^^

ibatis:statementName[?options]

Where *statementName* is the name in the iBATIS XML configuration file
which maps to the query, insert, update or delete operation you wish to
evaluate.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

This component will by default load the iBatis SqlMapConfig file from
the root of the classpath and expected named as `SqlMapConfig.xml`. +
It uses Spring resource loading so you can define it using `classpath`,
`file` or `http` as prefix to load resources with those schemes. +
In Camel 2.2 you can configure this on the iBatisComponent with the
`setSqlMapConfig(String)` method.

[[BookComponentAppendix-Options.22]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |Type |Default |Description
|`consumer.onConsume` |`String` |`null` |Statements to run after
consuming. Can be used, for example, to update rows after they have been
consumed and processed in Camel. See sample later. Multiple statements
can be separated with comma.

|`consumer.useIterator` |`boolean` |`true` |If `true` each row returned
when polling will be processed individually. If `false` the entire
`List` of data is set as the IN body.

|`consumer.routeEmptyResultSet` |`boolean` |`false` |Sets whether empty
result set should be routed or not. By default, empty result sets are
not routed.

|`statementType` |`StatementType` |`null` |Mandatory to specify for
IbatisProducer to control which iBatis `SqlMapClient` method to invoke.
The enum values are: `QueryForObject`, `QueryForList`, `Insert`,
`Update`, `Delete`.

|`maxMessagesPerPoll` |`int` |`0` |An integer to define a maximum
messages to gather per poll. By default, no maximum is set. Can be used
to set a limit of e.g. 1000 to avoid when starting up the server that
there are thousands of files. Set a value of 0 or negative to disabled
it.

|`isolation` |`String` |`TRANSACTION_REPEATABLE_READ` |*Camel 2.9:* A
String the defines the transaction isolation level of the will be used.
Allowed values are TRANSACTION_NONE, TRANSACTION_READ_UNCOMMITTED,
TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ,
TRANSACTION_SERIALIZABLE
|=======================================================================

[width="100%",cols="25%,25%,25%,25%",]
|=======================================================================
|`isolation` |`String` |`TRANSACTION_REPEATABLE_READ` |*Camel 2.9:* A
String the defines the transaction isolation level of the will be used.
Allowed values are TRANSACTION_NONE, TRANSACTION_READ_UNCOMMITTED,
TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ,
TRANSACTION_SERIALIZABLE
|=======================================================================

[[BookComponentAppendix-MessageHeaders.7]]
Message Headers
^^^^^^^^^^^^^^^

Camel will populate the result message, either IN or OUT with a header
with the operationName used:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelIBatisStatementName` |`String` |The *statementName* used (for
example: insertAccount).

|`CamelIBatisResult` |`Object` |The *response* returned from iBatis in
any of the operations. For instance an `INSERT` could return the
auto-generated key, or number of rows etc.
|=======================================================================

[[BookComponentAppendix-MessageBody.2]]
Message Body
^^^^^^^^^^^^

The response from iBatis will only be set as body if it's a `SELECT`
statement. That means, for example, for `INSERT` statements Camel will
not replace the body. This allows you to continue routing and keep the
original body. The response from iBatis is always stored in the header
with the key `CamelIBatisResult`.

[[BookComponentAppendix-Samples.4]]
Samples
^^^^^^^

For example if you wish to consume beans from a JMS queue and insert
them into a database you could do the following:

from("activemq:queue:newAccount").
to("ibatis:insertAccount?statementType=Insert");

Notice we have to specify the `statementType`, as we need to instruct
Camel which `SqlMapClient` operation to invoke.

Where *insertAccount* is the iBatis ID in the SQL map file:

xml <!-- Insert example, using the Account parameter class --> <insert
id="insertAccount" parameterClass="Account"> insert into ACCOUNT (
ACC_ID, ACC_FIRST_NAME, ACC_LAST_NAME, ACC_EMAIL ) values ( #id#,
#firstName#, #lastName#, #emailAddress# ) </insert>

[[BookComponentAppendix-UsingStatementTypeforbettercontrolofIBatis]]
Using StatementType for better control of IBatis
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When routing to an iBatis endpoint you want more fine grained control so
you can control whether the SQL statement to be executed is a `SELEECT`,
`UPDATE`, `DELETE` or `INSERT` etc. So for instance if we want to route
to an iBatis endpoint in which the IN body contains parameters to a
`SELECT` statement we can do:

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-ibatis/src/test/java/org/apache/camel/component/ibatis/IBatisQueryForObjectTest.java}

In the code above we can invoke the iBatis statement `selectAccountById`
and the IN body should contain the account id we want to retrieve, such
as an `Integer` type.

We can do the same for some of the other operations, such as
`QueryForList`:

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-ibatis/src/test/java/org/apache/camel/component/ibatis/IBatisQueryForListTest.java}

And the same for `UPDATE`, where we can send an `Account` object as IN
body to iBatis:

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-ibatis/src/test/java/org/apache/camel/component/ibatis/IBatisQueryForUpdateTest.java}

[[BookComponentAppendix-Scheduledpollingexample]]
Scheduled polling example
+++++++++++++++++++++++++

Since this component does not support scheduled polling, you need to use
another mechanism for triggering the scheduled polls, such as the
link:timer.html[Timer] or link:quartz.html[Quartz] components.

In the sample below we poll the database, every 30 seconds using the
link:timer.html[Timer] component and send the data to the JMS queue:

javafrom("timer://pollTheDatabase?delay=30000").to("ibatis:selectAllAccounts?statementType=QueryForList").to("activemq:queue:allAccounts");

And the iBatis SQL map file used:

xml <!-- Select with no parameters using the result map for Account
class. --> <select id="selectAllAccounts" resultMap="AccountResult">
select * from ACCOUNT </select>

[[BookComponentAppendix-UsingonConsume]]
Using onConsume
+++++++++++++++

This component supports executing statements *after* data have been
consumed and processed by Camel. This allows you to do post updates in
the database. Notice all statements must be `UPDATE` statements. Camel
supports executing multiple statements whose name should be separated by
comma.

The route below illustrates we execute the *consumeAccount* statement
data is processed. This allows us to change the status of the row in the
database to processed, so we avoid consuming it twice or more.

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-ibatis/src/test/java/org/apache/camel/component/ibatis/IBatisQueueTest.java}

And the statements in the sqlmap file:

\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-ibatis/src/test/resources/org/apache/camel/component/ibatis/Account.xml}\{snippet:id=e2|lang=xml|url=camel/trunk/components/camel-ibatis/src/test/resources/org/apache/camel/component/ibatis/Account.xml}

link:endpoint-see-also.html[Endpoint See Also]

* link:mybatis.html[MyBatis]

[[BookComponentAppendix-IRCComponent]]
IRC Component
~~~~~~~~~~~~~

The *irc* component implements an
http://en.wikipedia.org/wiki/Internet_Relay_Chat[IRC] (Internet Relay
Chat) transport.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-irc</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.27]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
irc:nick@host[:port]/#room[?options]
irc:nick@host[:port]?channels=#channel1,#channel2,#channel3[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.23]]
Options
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Description |Example |Default Value
|`channels` |Comma separated list of IRC channels to join.
|`channels=#channel1,#channel2` |`null`

|`nickname` |The nickname used in chat.
|`irc:MyNick@irc.server.org#channel` or
`irc:irc.server.org#channel?nickname=MyUser` |`null`

|`username` |The IRC server user name.
|`irc:MyUser@irc.server.org#channel` or
`irc:irc.server.org#channel?username=MyUser` |Same as nickname.

|`password` |The IRC server password. |`password=somepass` |_None_

|`realname` |The IRC user's actual name. |`realname=MyName` |_None_

|`nickPassword` |*Camel 2.18:* Your IRC server nickname password.
|nickPassword=mysecret |_None_

|`colors` |Whether or not the server supports color codes.
|`true, false` |`true`

|`onReply` |Whether or not to handle general responses to commands or
informational messages. |`true, false` |`false`

|`onNick` |Handle nickname change events. |`true, false` |`true`

|`onQuit` |Handle user quit events. |`true, false` |`true`

|`onJoin` |Handle user join events. |`true, false` |`true`

|`onKick` |Handle kick events. |`true, false` |`true`

|`onMode` |Handle mode change events. |`true, false` |`true`

|`onPart` |Handle user part events. |`true, false` |`true`

|`onTopic` |Handle topic change events. |`true, false` |`true`

|`onPrivmsg` |Handle message events. |`true, false` |`true`

|`trustManager` |The trust manager used to verify the SSL server's
certificate. |`trustManager=#referenceToTrustManagerBean` |The default
trust manager, which accepts _all_ certificates, will be used.

|`keys` |*Camel 2.2:* Comma separated list of IRC channel keys.
Important to be listed in same order as channels. When joining multiple
channels with only some needing keys just insert an empty value for that
channel. |`irc:MyNick@irc.server.org/#channel?keys=chankey` |`null`

|sslContextParameters |*Camel 2.9:* Reference to a
`org.apache.camel.util.jsse.SSLContextParameters` in the
http://camel.apache.org/registry.html[Registry].  This reference
overrides any configured SSLContextParameters at the component level. 
See
http://camel.apache.org/http4.html#HTTP4-UsingtheJSSEConfigurationUtility[Using
the JSSE Configuration Utility].  Note that this setting overrides the
trustManager option. |#mySslContextParameters |`null`
|=======================================================================

[[BookComponentAppendix-SSLSupport]]
SSL Support
^^^^^^^^^^^

[[BookComponentAppendix-UsingtheJSSEConfigurationUtility.2]]
Using the JSSE Configuration Utility
++++++++++++++++++++++++++++++++++++

As of Camel 2.9, the IRC component supports SSL/TLS configuration
through the link:camel-configuration-utilities.html[Camel JSSE
Configuration Utility].  This utility greatly decreases the amount of
component specific code you need to write and is configurable at the
endpoint and component levels.  The following examples demonstrate how
to use the utility with the IRC component.

[[BookComponentAppendix-Programmaticconfigurationoftheendpoint]]
Programmatic configuration of the endpoint

[source,brush:,java;,gutter:,false;,theme:,Default]
----
KeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("/users/home/server/truststore.jks");
ksp.setPassword("keystorePassword");

TrustManagersParameters tmp = new TrustManagersParameters();
tmp.setKeyStore(ksp);

SSLContextParameters scp = new SSLContextParameters();
scp.setTrustManagers(tmp);

Registry registry = ...
registry.bind("sslContextParameters", scp);

...

from(...)
    .to("ircs://camel-prd-user@server:6669/#camel-test?nickname=camel-prd&password=password&sslContextParameters=#sslContextParameters");
----

[[BookComponentAppendix-SpringDSLbasedconfigurationofendpoint.1]]
Spring DSL based configuration of endpoint

[source,brush:,java;,gutter:,false;,theme:,Default]
----
...
  <camel:sslContextParameters
      id="sslContextParameters">
    <camel:trustManagers>
      <camel:keyStore
          resource="/users/home/server/truststore.jks"
          password="keystorePassword"/>
    </camel:keyManagers>
  </camel:sslContextParameters>...
...
  <to uri="ircs://camel-prd-user@server:6669/#camel-test?nickname=camel-prd&password=password&sslContextParameters=#sslContextParameters"/>...
----

[[BookComponentAppendix-Usingthelegacybasicconfigurationoptions]]
Using the legacy basic configuration options
++++++++++++++++++++++++++++++++++++++++++++

You can also connect to an SSL enabled IRC server, as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ircs:host[:port]/#room?username=user&password=pass
----

By default, the IRC transport uses
http://moepii.sourceforge.net/irclib/javadoc/org/schwering/irc/lib/ssl/SSLDefaultTrustManager.html[SSLDefaultTrustManager].
If you need to provide your own custom trust manager, use the
`trustManager` parameter as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ircs:host[:port]/#room?username=user&password=pass&trustManager=#referenceToMyTrustManagerBean
----

[[BookComponentAppendix-Usingkeys]]
Using keys
^^^^^^^^^^

*Available as of Camel 2.2*

Some irc rooms requires you to provide a key to be able to join that
channel. The key is just a secret word.

For example we join 3 channels where as only channel 1 and 3 uses a key.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
irc:nick@irc.server.org?channels=#chan1,#chan2,#chan3&keys=chan1Key,,chan3key
----

[[BookComponentAppendix-SeeAlso.13]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-Jasyptcomponent]]
Jasypt component
~~~~~~~~~~~~~~~~

*Available as of Camel 2.5*

http://www.jasypt.org/[Jasypt] is a simplified encryption library which
makes encryption and decryption easy. Camel integrates with Jasypt to
allow sensitive information in link:properties.html[Properties] files to
be encrypted. By dropping *`camel-jasypt`* on the classpath those
encrypted values will automatically be decrypted on-the-fly by Camel.
This ensures that human eyes can't easily spot sensitive information
such as usernames and passwords.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jasypt</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-Tooling]]
Tooling
^^^^^^^

The link:jasypt.html[Jasypt] component provides a little command line
tooling to encrypt or decrypt values.

The console output the syntax and which options it provides:

Apache Camel Jasypt takes the following options -h or -help = Displays
the help screen -c or -command <command> = Command either encrypt or
decrypt -p or -password <password> = Password to use -i or -input
<input> = Text to encrypt or decrypt -a or -algorithm <algorithm> =
Optional algorithm to use

For example to encrypt the value `tiger` you run with the following
parameters. In the apache camel kit, you cd into the lib folder and run
the following java cmd, where _<CAMEL_HOME>_ is where you have
downloaded and extract the Camel distribution.

$ cd <CAMEL_HOME>/lib $ java -jar camel-jasypt-2.5.0.jar -c encrypt -p
secret -i tiger

Which outputs the following result

Encrypted text: qaEEacuW7BUti8LcMgyjKw==

This means the encrypted representation `qaEEacuW7BUti8LcMgyjKw==` can
be decrypted back to `tiger` if you know the master password which was
`secret`. +
If you run the tool again then the encrypted value will return a
different result. But decrypting the value will always return the
correct original value.

So you can test it by running the tooling using the following
parameters:

$ cd <CAMEL_HOME>/lib $ java -jar camel-jasypt-2.5.0.jar -c decrypt -p
secret -i qaEEacuW7BUti8LcMgyjKw==

Which outputs the following result:

Decrypted text: tiger

The idea is then to use those encrypted values in your
link:properties.html[Properties] files. Notice how the password value is
encrypted and the value has the tokens surrounding `ENC(value here)`

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jasypt/src/test/resources/org/apache/camel/component/jasypt/myproperties.properties}

[[BookComponentAppendix-ToolingdependenciesforCamel2.5and2.6]]
Tooling dependencies for Camel 2.5 and 2.6
++++++++++++++++++++++++++++++++++++++++++

The tooling requires the following JARs in the classpath, which has been
enlisted in the `MANIFEST.MF` file of `camel-jasypt` with `optional/` as
prefix. Hence why the java cmd above can pickup the needed JARs from the
Apache Distribution in the `optional` directory.

jasypt-1.6.jar commons-lang-2.4.jar commons-codec-1.4.jar
icu4j-4.0.1.jar Java 1.5 users

The `icu4j-4.0.1.jar` is only needed when running on JDK 1.5.

This JAR is not distributed by Apache Camel and you have to download it
manually and copy it to the `lib/optional` directory of the Camel
distribution. +
You can download it from
http://repo2.maven.org/maven2/com/ibm/icu/icu4j/4.0.1/[Apache Central
Maven repo].

[[BookComponentAppendix-ToolingdependenciesforCamel2.7orbetter]]
Tooling dependencies for Camel 2.7 or better
++++++++++++++++++++++++++++++++++++++++++++

Jasypt 1.7 onwards is now fully standalone so no additional JARs is
needed.

[[BookComponentAppendix-URIOptions.5]]
URI Options
^^^^^^^^^^^

The options below are exclusive for the link:jasypt.html[Jasypt]
component.

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Default Value |Type |Description
|`password` |`null` |`String` |Specifies the master password to use for
decrypting. This option is mandatory. See below for more details.

|`algorithm` |`null` |`String` |Name of an optional algorithm to use.
|=======================================================================

[[BookComponentAppendix-Protectingthemasterpassword]]
Protecting the master password
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The master password used by link:jasypt.html[Jasypt] must be provided,
so that it's capable of decrypting the values. However having this
master password out in the open may not be an ideal solution. Therefore
you could for example provide it as a JVM system property or as a OS
environment setting. If you decide to do so then the `password` option
supports prefixes which dictates this. `sysenv:` means to lookup the OS
system environment with the given key. `sys:` means to lookup a JVM
system property.

For example you could provided the password before you start the
application

$ export CAMEL_ENCRYPTION_PASSWORD=secret

Then start the application, such as running the start script.

When the application is up and running you can unset the environment

$ unset CAMEL_ENCRYPTION_PASSWORD

The `password` option is then a matter of defining as follows:
`password=sysenv:CAMEL_ENCRYPTION_PASSWORD`.

[[BookComponentAppendix-ExamplewithJavaDSL]]
Example with Java DSL
^^^^^^^^^^^^^^^^^^^^^

In Java DSL you need to configure link:jasypt.html[Jasypt] as a
`JasyptPropertiesParser` instance and set it on the
link:properties.html[Properties] component as show below:

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jasypt/src/test/java/org/apache/camel/component/jasypt/JasyptPropertiesTest.java}

The properties file `myproperties.properties` then contain the encrypted
value, such as shown below. Notice how the password value is encrypted
and the value has the tokens surrounding `ENC(value here)`

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jasypt/src/test/resources/org/apache/camel/component/jasypt/myproperties.properties}

[[BookComponentAppendix-ExamplewithSpringXML]]
Example with Spring XML
^^^^^^^^^^^^^^^^^^^^^^^

In Spring XML you need to configure the `JasyptPropertiesParser` which
is shown below. Then the Camel link:properties.html[Properties]
component is told to use `jasypt` as the properties parser, which means
link:jasypt.html[Jasypt] has its chance to decrypt values looked up in
the properties.

xml<!-- define the jasypt properties parser with the given password to
be used --> <bean id="jasypt"
class="org.apache.camel.component.jasypt.JasyptPropertiesParser">
<property name="password" value="secret"/> </bean> <!-- define the camel
properties component --> <bean id="properties"
class="org.apache.camel.component.properties.PropertiesComponent"> <!--
the properties file is in the classpath --> <property name="location"
value="classpath:org/apache/camel/component/jasypt/myproperties.properties"/>
<!-- and let it leverage the jasypt parser --> <property
name="propertiesParser" ref="jasypt"/> </bean>

The link:properties.html[Properties] component can also be inlined
inside the `<camelContext>` tag which is shown below. Notice how we use
the `propertiesParserRef` attribute to refer to
link:jasypt.html[Jasypt].

<!-- define the jasypt properties parser with the given password to be
used --> <bean id="jasypt"
class="org.apache.camel.component.jasypt.JasyptPropertiesParser"> <!--
password is mandatory, you can prefix it with sysenv: or sys: to
indicate it should use an OS environment or JVM system property value,
so you dont have the master password defined here --> <property
name="password" value="secret"/> </bean> <camelContext
xmlns="http://camel.apache.org/schema/spring"> <!-- define the camel
properties placeholder, and let it leverage jasypt -->
<propertyPlaceholder id="properties"
location="classpath:org/apache/camel/component/jasypt/myproperties.properties"
propertiesParserRef="jasypt"/> <route> <from uri="direct:start"/> <to
uri="\{\{cool.result}}"/> </route> </camelContext>

[[BookComponentAppendix-ExamplewithBlueprintXML]]
Example with Blueprint XML
^^^^^^^^^^^^^^^^^^^^^^^^^^

In Blueprint XML you need to configure
the `JasyptPropertiesParser` which is shown below. Then the
Camel link:properties.html[Properties] component is told to
use `jasypt` as the properties parser, which
means link:jasypt.html[Jasypt] has its chance to decrypt values looked
up in the properties.

xml<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
xsi:schemaLocation=" http://www.osgi.org/xmlns/blueprint/v1.0.0
http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd">
<cm:property-placeholder id="myblue" persistent-id="mypersistent"> <!--
list some properties for this test --> <cm:default-properties>
<cm:property name="cool.result" value="mock:\{\{cool.password}}"/>
<cm:property name="cool.password"
value="ENC(bsW9uV37gQ0QHFu7KO03Ww==)"/> </cm:default-properties>
</cm:property-placeholder> <!-- define the jasypt properties parser with
the given password to be used --> <bean id="jasypt"
class="org.apache.camel.component.jasypt.JasyptPropertiesParser">
<property name="password" value="secret"/> </bean> <camelContext
xmlns="http://camel.apache.org/schema/blueprint"> <!-- define the camel
properties placeholder, and let it leverage jasypt -->
<propertyPlaceholder id="properties" location="blueprint:myblue"
propertiesParserRef="jasypt"/> <route> <from uri="direct:start"/> <to
uri="\{\{cool.result}}"/> </route> </camelContext> </blueprint>

The link:properties.html[Properties] component can also be inlined
inside the `<camelContext>` tag which is shown below. Notice how we use
the `propertiesParserRef` attribute to refer
to link:jasypt.html[Jasypt].

xml<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
xsi:schemaLocation=" http://www.osgi.org/xmlns/blueprint/v1.0.0
http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"> <!-- define
the jasypt properties parser with the given password to be used -->
<bean id="jasypt"
class="org.apache.camel.component.jasypt.JasyptPropertiesParser">
<property name="password" value="secret"/> </bean> <camelContext
xmlns="http://camel.apache.org/schema/blueprint"> <!-- define the camel
properties placeholder, and let it leverage jasypt -->
<propertyPlaceholder id="properties"
location="classpath:org/apache/camel/component/jasypt/myproperties.properties"
propertiesParserRef="jasypt"/> <route> <from uri="direct:start"/> <to
uri="\{\{cool.result}}"/> </route> </camelContext> </blueprint>

 

[[BookComponentAppendix-SeeAlso.14]]
See Also
^^^^^^^^

* link:security.html[Security]
* link:properties.html[Properties]
* http://activemq.apache.org/encrypted-passwords.html[Encrypted
passwords in ActiveMQ] - ActiveMQ has a similar feature as this
`camel-jasypt` component

[[BookComponentAppendix-JavaSpaceComponent]]
JavaSpace Component
~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.1*

The *javaspace* component is a transport for working with any JavaSpace
compliant implementation and this component has been tested with both
the http://www.dancres.org/blitz/[Blitz implementation] and the
http://www.gigaspaces.com/[GigaSpace implementation]. +
This component can be used for sending and receiving any object
inheriting from the Jini `net.jini.core.entry.Entry` class. It is also
possible to pass the bean ID of a template that can be used for
reading/taking the entries from the space. +
This component can be used for sending/receiving any serializable object
acting as a sort of generic transport. The JavaSpace component contains
a special optimization for dealing with the `BeanExchange`. It can be
used to invoke a POJO remotely, using a JavaSpace as a transport. +
This latter feature can provide a simple implementation of the
master/worker pattern, where a POJO provides the business logic for the
worker. +
Look at the test cases for examples of various use cases for this
component.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-javaspace</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.28]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
javaspace:jini://host[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.24]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`spaceName` |`null` |Specifies the JavaSpace name.

|`verb` |`take` |Specifies the verb for getting JavaSpace entries. The
values can be: `take` or `read`.

|`transactional` |`false` |If `true`, sending and receiving entries is
performed within a transaction.

|`transactionalTimeout` |`Long.MAX_VALUE` |Specifies the transaction
timeout.

|`concurrentConsumers` |`1` |Specifies the number of concurrent
consumers getting entries from the JavaSpace.

|`templateId` |`null` |If present, this option specifies the Spring bean
ID of the template to use for reading/taking entries.
|=======================================================================

[[BookComponentAppendix-Examples.7]]
Examples
^^^^^^^^

[[BookComponentAppendix-SendingandReceivingEntries]]
Sending and Receiving Entries
+++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// sending route
from("direct:input")
    .to("javaspace:jini://localhost?spaceName=mySpace");

// receiving Route
from("javaspace:jini://localhost?spaceName=mySpace&templateId=template&verb=take&concurrentConsumers=1")
    .to("mock:foo");
----

In this case the payload can be any object that inherits from the Jini
`Entry` type.

[[BookComponentAppendix-Sendingandreceivingserializableobjects]]
Sending and receiving serializable objects
++++++++++++++++++++++++++++++++++++++++++

Using the preceding routes, it is also possible to send and receive any
serializable object. The JavaSpace component detects that the payload is
not a Jini `Entry` and then it automatically wraps the payload with a
Camel Jini `Entry`. In this way, a JavaSpace can be used as a generic
transport mechanism.

[[BookComponentAppendix-UsingJavaSpaceasaremoteinvocationtransport]]
Using JavaSpace as a remote invocation transport
++++++++++++++++++++++++++++++++++++++++++++++++

The JavaSpace component has been tailored to work in combination with
the Camel bean component. It is therefore possible to call a remote POJO
using JavaSpace as the transport:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
// client side
from("direct:input")
    .to("javaspace:jini://localhost?spaceName=mySpace");

// server side
from("javaspace:jini://localhost?concurrentConsumers=10&spaceName=mySpace")
    .to("mock:foo");
----

In the code there are two test cases showing how to use a POJO to
realize the master/worker pattern. The idea is to use the POJO to
provide the business logic and rely on Camel for sending/receiving
requests/replies with the proper correlation.

[[BookComponentAppendix-SeeAlso.15]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-JBIComponent]]
JBI Component
~~~~~~~~~~~~~

The *jbi* component is implemented by the
http://servicemix.apache.org/servicemix-camel.html[ServiceMix Camel
module] and provides integration with a JBI Normalized Message Router,
such as the one provided by http://servicemix.apache.org/[Apache
ServiceMix].

See below for information about how to use `StreamSource` types from
http://servicemix.apache.org/[ServiceMix] in Camel.

The following code:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("jbi:endpoint:http://foo.bar.org/MyService/MyEndpoint")
----

Automatically exposes a new endpoint to the bus, where the service QName
is \{`http://foo.bar.org}MyService` and the endpoint name is
`MyEndpoint` (see link:jbi.html[#URI-format]).

When a JBI endpoint appears at the end of a route, for example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
to("jbi:endpoint:http://foo.bar.org/MyService/MyEndpoint")
----

The messages sent by this producer endpoint are sent to the already
deployed JBI endpoint.

[[BookComponentAppendix-URI-format]]

[[BookComponentAppendix-URIformat.29]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
jbi:service:serviceNamespace[sep]serviceName[?options]
jbi:endpoint:serviceNamespace[sep]serviceName[sep]endpointName[?options]
jbi:name:endpointName[?options]
----

The separator that should be used in the endpoint URL is:

* `/` (forward slash), if `serviceNamespace` starts with `http://`, or
* `:` (colon), if `serviceNamespace` starts with `urn:foo:bar`.

For more details of valid JBI URIs see the
http://servicemix.apache.org/uris.html[ServiceMix URI Guide].

Using the `jbi:service:` or `jbi:endpoint:` URI formats sets the service
QName on the JBI endpoint to the one specified. Otherwise, the default
Camel JBI Service QName is used, which is:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
{http://activemq.apache.org/camel/schema/jbi}endpoint
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Examples.8]]
Examples
++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
jbi:service:http://foo.bar.org/MyService
jbi:endpoint:urn:foo:bar:MyService:MyEndpoint
jbi:endpoint:http://foo.bar.org/MyService/MyEndpoint
jbi:name:cheese
----

[[BookComponentAppendix-URIoptions]]
URI options
^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default value |Description
|`mep` |MEP of the Camel Exchange |Allows users to override the MEP set
on the Exchange object. Valid values for this option are `in-only`,
`in-out`, `robust-in-out` and `in-optional-out`.

|`operation` |Value of the `jbi.operation` header property |Specifies
the JBI operation for the `MessageExchange`. If no value is supplied,
the JBI binding will use the value of the `jbi.operation` header
property.

|`serialization` |`basic` |Default value (`basic`) will check if headers
are serializable by looking at the type, setting this option to `strict`
will detect objects that can not be serialized although they implement
the `Serializable` interface. Set to `nocheck` to disable this check
altogether, note that this should only be used for in-memory transports
like SEDAFlow, otherwise you can expect to get
`NotSerializableException` thrown at runtime.

|`convertException` |`false` |`false`: send any exceptions thrown from
the Camel route back unmodified +
`true`: convert all exceptions to a JBI FaultException (can be used to
avoid non-serializable exceptions or to implement generic error handling
|=======================================================================

[[BookComponentAppendix-Examples.9]]
Examples
++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
jbi:service:http://foo.bar.org/MyService?mep=in-out       (override the MEP, use InOut JBI MessageExchanges)
jbi:endpoint:urn:foo:bar:MyService:MyEndpoint?mep=in      (override the MEP, use InOnly JBI MessageExchanges)  
jbi:endpoint:urn:foo:bar:MyService:MyEndpoint?operation={http://www.mycompany.org}AddNumbers 
 (overide the operation for the JBI Exchange to {http://www.mycompany.org}AddNumbers)
----

[[BookComponentAppendix-UsingStreambodies]]
Using Stream bodies
^^^^^^^^^^^^^^^^^^^

If you are using a stream type as the message body, you should be aware
that a stream is only capable of being read once. So if you enable
`DEBUG` logging, the body is usually logged and thus read. To deal with
this, Camel has a `streamCaching` option that can cache the stream,
enabling you to read it multiple times.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("jbi:endpoint:http://foo.bar.org/MyService/MyEndpoint").streamCaching().to("xslt:transform.xsl", "bean:doSomething");
----

The stream caching is default enabled, so it is not necessary to set the
`streamCaching()` option. +
We store big input streams (by default, over 64K) in a `temp` file using
`CachedOutputStream`. When you close the input stream, the temp file
will be deleted.

[[BookComponentAppendix-CreatingaJBIServiceUnit]]
Creating a JBI Service Unit
^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have some Camel routes that you want to deploy inside JBI as a
Service Unit, you can use the link:jbi-service-unit-archetype.html[JBI
Service Unit Archetype] to create a new Maven project for the Service
Unit.

If you have an existing Maven project that you need to convert into a
JBI Service Unit, you may want to consult
http://servicemix.apache.org/maven-jbi-plugin.html[ServiceMix Maven JBI
Plugins] for further help. The key steps are as follows:

* Create a Spring XML file at `src/main/resources/camel-context.xml` to
bootstrap your routes inside the JBI Service Unit.
* Change the POM file's packaging to `jbi-service-unit`.

Your `pom.xml` should look something like this to enable the
`jbi-service-unit` packaging:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

  <modelVersion>4.0.0</modelVersion>

  <groupId>myGroupId</groupId>
  <artifactId>myArtifactId</artifactId>
  <packaging>jbi-service-unit</packaging>
  <version>1.0-SNAPSHOT</version>

  <name>A Camel based JBI Service Unit</name>

  <url>http://www.myorganization.org</url>

  <properties>
    <camel-version>x.x.x</camel-version>
    <servicemix-version>3.3</servicemix-version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.apache.servicemix</groupId>
      <artifactId>servicemix-camel</artifactId>
      <version>${servicemix-version}</version>
    </dependency>

    <dependency>
      <groupId>org.apache.servicemix</groupId>
      <artifactId>servicemix-core</artifactId>
      <version>${servicemix-version}</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>

  <build>
    <defaultGoal>install</defaultGoal>

    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>1.5</source>
          <target>1.5</target>
        </configuration>
      </plugin>

      <!-- creates the JBI deployment unit -->
      <plugin>
        <groupId>org.apache.servicemix.tooling</groupId>
        <artifactId>jbi-maven-plugin</artifactId>
        <version>${servicemix-version}</version>
        <extensions>true</extensions>
      </plugin>
    </plugins>
  </build>
</project>
----

[[BookComponentAppendix-SeeAlso.16]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* http://servicemix.apache.org/servicemix-camel.html[ServiceMix Camel
module]
* http://servicemix.apache.org/3-beginner-using-apache-camel-inside-servicemix.html[Using
Camel with ServiceMix]
* http://servicemix.apache.org/order-file-processing.html[Cookbook on
using Camel with ServiceMix]

[[BookComponentAppendix-JCRComponent]]
JCR Component
~~~~~~~~~~~~~

The *`jcr`* component allows you to add/read nodes to/from a JCR
compliant content repository (for example,
http://jackrabbit.apache.org/[Apache Jackrabbit]) with its producer, or
register an EventListener with the consumer.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-jcr</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.30]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
jcr://user:password@repository/path/to/node
----

[Tip]
====
 **Consumer added**

From *Camel 2.10* onwards you can use consumer as an EventListener in
JCR or a producer to read a node by identifier.

====

[[BookComponentAppendix-Usage.3]]
Usage
^^^^^

The `repository` element of the URI is used to look up the JCR
`Repository` object in the Camel context registry.

[[BookComponentAppendix-Producer.1]]
Producer
++++++++

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`CamelJcrOperation` |`CamelJcrInsert` |CamelJcrInsert or
CamelJcrGetById operation to use

|`CamelJcrNodeName` |`null` |Used to determine the node name to use.

|`CamelJcrNodeType` |`null` |*Camel 2.16:* To use a specify primary node
type when creating adding a new node.
|=======================================================================

When a message is sent to a JCR producer endpoint:

* If the operation is CamelJcrInsert: A new node is created in the
content repository, all the message headers of the IN message are
transformed to `javax.jcr.Value` instances and added to the new node and
the node's UUID is returned in the OUT message.
* If the operation is CamelJcrGetById: A new node is retrieved from the
repository using the message body as node identifier.

[Note]
====


Please note that the JCR Producer used message properties instead of
message headers in Camel versions earlier than 2.12.3. See
https://issues.apache.org/jira/browse/CAMEL-7067 for more details.

====

 

[[BookComponentAppendix-Consumer.1]]
Consumer
++++++++

The consumer will connect to JCR periodically and return a
List<http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/observation/Event.html[javax.jcr.observation.Event]>
in the message body.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`eventTypes` |`0` |A combination of one or more event types encoded as
a bit mask value such as javax.jcr.observation.Event.NODE_ADDED,
javax.jcr.observation.Event.NODE_REMOVED, etc.

|`deep` |`false` |When it is true, events whose associated parent node
is at current path or within its subgraph are received.

|`uuids` |`null` |Only events whose associated parent node has one of
the identifiers in the comma separated uuid list will be received.

|`nodeTypeNames` |`null` |Only events whose associated parent node has
one of the node types (or a subtype of one of the node types) in this
list will be received.

|`noLocal` |`false` |If `noLocal` is `true`, then events generated by
the session through which the listener was registered are ignored.
Otherwise, they are not ignored.

|`sessionLiveCheckInterval` |`60000` |Interval in milliseconds to wait
before each session live checking.

|`sessionLiveCheckIntervalOnStart` |`3000` |Interval in milliseconds to
wait before the first session live checking.

|username |  |*Camel 2.15:* Allows to specify the username as a uri
parameter instead of in the authority section of the uri

|password |  |*Camel 2.15:* Allows to specify the password as a uri
parameter instead of in the authority section of the uri

|workspaceName |`null` |**Camel 2.16:** Allows to specify a workspace
different from default
|=======================================================================

[[BookComponentAppendix-Example.2]]
Example
^^^^^^^

The snippet below creates a node named `node` under the `/home/test`
node in the content repository. One additional property is added to the
node as well: `my.contents.property` which will contain the body of the
message being sent.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:a").setHeader(JcrConstants.JCR_NODE_NAME, constant("node"))
    .setHeader("my.contents.property", body())
    .to("jcr://user:pass@repository/home/test");
----

 

The following code will register an EventListener under the path
import-application/inbox for Event.NODE_ADDED and Event.NODE_REMOVED
events (event types 1 and 2, both masked as 3) and listening deep for
all the children.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="jcr://user:pass@repository/import-application/inbox?eventTypes=3&deep=true" />
    <to uri="direct:execute-import-application" />
</route>
----

[[BookComponentAppendix-SeeAlso.17]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-JDBCComponent]]
JDBC Component
~~~~~~~~~~~~~~

The *jdbc* component enables you to access databases through JDBC, where
SQL queries (SELECT) and operations (INSERT, UPDATE, etc) are sent in
the message body. This component uses the standard JDBC API, unlike the
link:sql-component.html[SQL Component] component, which uses
spring-jdbc.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jdbc</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

This component can only be used to define producer endpoints, which
means that you cannot use the JDBC component in a `from()` statement.

[[BookComponentAppendix-URIformat.31]]
URI format
^^^^^^^^^^

jdbc:dataSourceName[?options]

This component only supports producer endpoints.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.25]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`readSize` |`0` |The default maximum number of rows that can be read by
a polling query. The default value is 0.

|`statement.<xxx>` |`null` |*Camel 2.1:* Sets additional options on the
`java.sql.Statement` that is used behind the scenes to execute the
queries. For instance, `statement.maxRows=10`. For detailed
documentation, see the
http://java.sun.com/j2se/1.5.0/docs/api/java/sql/Statement.html[`java.sql.Statement`
javadoc] documentation.

|`useJDBC4ColumnNameAndLabelSemantics` |`true` |*Camel 2.2:* Sets
whether to use JDBC 4/3 column label/name semantics. You can use this
option to turn it `false` in case you have issues with your JDBC driver
to select data. This only applies when using `SQL SELECT` using aliases
(e.g. `SQL SELECT id as identifier, name as given_name from persons`).

|`resetAutoCommit` |`true` |*Camel 2.9:* If true, Camel will set the
autoCommit on the JDBC connection to be false, commit the change after
executing the statement and reset the autoCommit flag of the connection
at the end. If the JDBC connection does not support resetting the
autoCommit flag, set this to false. +
When used with XA transactions you most likely need to set it to false
so that the transaction manager is in charge of committing this tx.

|`allowNamedParameters` |`true` |*Camel 2.12:* Whether to allow using
named parameters in the queries.

|`prepareStatementStrategy` |  |*Camel 2.12:* Allows to plugin to use a
custom `org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy` to
control preparation of the query and prepared statement.

|`useHeadersAsParameters` |`false` |*Camel 2.12:* Set this option to
`true` to use the `prepareStatementStrategy` with named parameters. This
allows to define queries with named placeholders, and use headers with
the dynamic values for the query placeholders.

|`outputType` |`SelectList` |*Camel 2.12.1:* outputType='SelectList',
for consumer or producer, will output a List of Map. `SelectOne` will
output single Java object in the following way: +
a) If the query has only single column, then that JDBC Column object is
returned. (such as SELECT COUNT( * ) FROM PROJECT will return a Long
object. +
b) If the query has more than one column, then it will return a Map of
that result. +
c) If the outputClass is set, then it will convert the query result into
an Java bean object by calling all the setters that match the column
names. It will assume your class has a default constructor to create
instance with. From *Camel 2.14* onwards then SelectList is also
supported. +
d) If the query resulted in more than one rows, it throws an non-unique
result exception. +
*Camel 2.14.0:* New `StreamList` output type value that streams the
result of the query using an `Iterator<Map<String, Object>>`, it can be
used along with the link:splitter.html[Splitter] EIP.

|`outputClass` |`null` |*Camel 2.12.1:* Specify the full package and
class name to use as conversion when outputType=SelectOne. From *Camel
2.14* onwards then SelectList is also supported.

|`beanRowMapper` |  |*Camel 2.12.1:* To use a custom
`org.apache.camel.component.jdbc.BeanRowMapper` when using
`outputClass`. The default implementation will lower case the row names
and skip underscores, and dashes. For example `"CUST_ID"` is mapped as
`"custId"`.

|`useGetBytesForBlob` |`false` |*Camel 2.16:* To read BLOB columns as
bytes instead of string data. This may be needed for certain databases
such as Oracle where you must read BLOB columns as bytes.
|=======================================================================

[[BookComponentAppendix-Result]]
Result
^^^^^^

By default the result is returned in the OUT body as an
`ArrayList<HashMap<String, Object>>`. The `List` object contains the
list of rows and the `Map` objects contain each row with the `String`
key as the column name. You can use the option `outputType` to control
the result.

*Note:* This component fetches `ResultSetMetaData` to be able to return
the column name as the key in the `Map`.

[[BookComponentAppendix-MessageHeaders.8]]
Message Headers
+++++++++++++++

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelJdbcRowCount` |If the query is a `SELECT`, query the row count is
returned in this OUT header.

|`CamelJdbcUpdateCount` |If the query is an `UPDATE`, query the update
count is returned in this OUT header.

|`CamelGeneratedKeysRows` |*Camel 2.10:* Rows that contains the
generated keys.

|`CamelGeneratedKeysRowCount` |*Camel 2.10:* The number of rows in the
header that contains generated keys.

|`CamelJdbcColumnNames` |*Camel 2.11.1:* The column names from the
ResultSet as a `java.util.Set` type.

|`CamelJdbcParameters` |*Camel 2.12:* A `java.util.Map` which has the
headers to be used if `useHeadersAsParameters` has been enabled.
|=======================================================================

[[BookComponentAppendix-Generatedkeys]]
Generated keys
^^^^^^^^^^^^^^

*Available as of Camel 2.10*

If you insert data using SQL INSERT, then the RDBMS may support auto
generated keys. You can instruct the link:jdbc.html[JDBC] producer to
return the generated keys in headers. +
To do that set the header `CamelRetrieveGeneratedKeys=true`. Then the
generated keys will be provided as headers with the keys listed in the
table above.

You can see more details in this
https://svn.apache.org/repos/asf/camel/trunk/components/camel-jdbc/src/test/java/org/apache/camel/component/jdbc/JdbcGeneratedKeysTest.java[unit
test].

Using generated keys does not work with together with named parameters.

[[BookComponentAppendix-Usingnamedparameters]]
Using named parameters
^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.12*

In the given route below, we want to get all the projects from the
projects table. Notice the SQL query has 2 named parameters, :?lic and
:?min. +
Camel will then lookup these parameters from the message headers. Notice
in the example above we set two headers with constant value +
for the named parameters:

from("direct:projects") .setHeader("lic", constant("ASF"))
.setHeader("min", constant(123)) .setBody("select * from projects where
license = :?lic and id > :?min order by id")
.to("jdbc:myDataSource?useHeadersAsParameters=true")

You can also store the header values in a `java.util.Map` and store the
map on the headers with the key `CamelJdbcParameters`.

[[BookComponentAppendix-Samples.5]]
Samples
^^^^^^^

In the following example, we fetch the rows from the customer table.

First we register our datasource in the Camel registry as
`testdb`:\{snippet:id=register|lang=java|url=camel/trunk/components/camel-jdbc/src/test/java/org/apache/camel/component/jdbc/AbstractJdbcTestSupport.java}Then
we configure a route that routes to the JDBC component, so the SQL will
be executed. Note how we refer to the `testdb` datasource that was bound
in the previous
step:\{snippet:id=route|lang=java|url=camel/trunk/components/camel-jdbc/src/test/java/org/apache/camel/component/jdbc/JdbcRouteTest.java}Or
you can create a `DataSource` in Spring like
this:\{snippet:id=example|lang=java|url=camel/trunk/components/camel-jdbc/src/test/resources/org/apache/camel/component/jdbc/camelContext.xml}We
create an endpoint, add the SQL query to the body of the IN message, and
then send the exchange. The result of the query is returned in the OUT
body:\{snippet:id=invoke|lang=java|url=camel/trunk/components/camel-jdbc/src/test/java/org/apache/camel/component/jdbc/JdbcRouteTest.java}If
you want to work on the rows one by one instead of the entire ResultSet
at once you need to use the link:splitter.html[Splitter] EIP such as:

In Camel 2.13.x or
older\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jdbc/src/test/java/org/apache/camel/component/jdbc/JdbcRouteSplitTest.java}In
Camel 2.14.x or newer

from("direct:hello") // here we split the data from the testdb into new
messages one by one // so the mock endpoint will receive a message per
row in the table // the StreamList option allows to stream the result of
the query without creating a List of rows // and notice we also enable
streaming mode on the splitter .to("jdbc:testdb?outputType=StreamList")
.split(body()).streaming() .to("mock:result");

[[BookComponentAppendix-Sample-Pollingthedatabaseeveryminute]]
 +
Sample - Polling the database every minute
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If we want to poll a database using the JDBC component, we need to
combine it with a polling scheduler such as the link:timer.html[Timer]
or link:quartz.html[Quartz] etc. In the following example, we retrieve
data from the database every 60 seconds:

javafrom("timer://foo?period=60000").setBody(constant("select * from
customer")).to("jdbc:testdb").to("activemq:queue:customers");

[[BookComponentAppendix-Sample-MoveDataBetweenDataSources]]
Sample - Move Data Between Data Sources +
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A common use case is to query for data, process it and move it to
another data source (ETL operations). In the following example, we
retrieve new customer records from the source table every hour,
filter/transform them and move them to a destination table:

javafrom("timer://MoveNewCustomersEveryHour?period=3600000")
.setBody(constant("select * from customer where create_time >
(sysdate-1/24)")) .to("jdbc:testdb") .split(body()) .process(new
MyCustomerProcessor()) //filter/transform results as needed
.setBody(simple("insert into processed_customer
values('$\{body[ID]}','$\{body[NAME]}')")) .to("jdbc:testdb");

 

link:endpoint-see-also.html[Endpoint See Also]

* link:sql.html[SQL]

[[BookComponentAppendix-JettyComponent]]
Jetty Component
~~~~~~~~~~~~~~~

The producer is deprecated - do not use. We only recommend using jetty
as consumer (eg from jetty)

 

The *`jetty`* component provides HTTP-based
link:endpoint.html[endpoints] for consuming and producing HTTP requests.
That is, the Jetty component behaves as a simple Web server. Jetty can
also be used as an HTTP client which mean you can also use it with Camel
as a producer.

Stream

The **`assert`** call appears in this example, because the code is part
of an unit test. Jetty is stream based, which means the input it
receives is submitted to Camel as a stream. That means you will only be
able to read the content of the stream *once*.

If you find a situation where the message body appears to be empty or
you need to access the *`Exchange.HTTP_RESPONSE_CODE`* data multiple
times, e.g., doing multi-casting, or re-delivery error handling, you
should use link:stream-caching.html[Stream caching] or convert the
message body to a *`String`* which is safe to be re-read multiple times.

Maven users should add the following dependency to their *`pom.xml`* to
use this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jetty</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIFormat.3]]
URI Format
^^^^^^^^^^

jetty:http://hostname[:port][/resourceUri][?options]

Query options should be appended to the URI using the following format:
*`?option=value&option=value&...`*

[[BookComponentAppendix-Options.26]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default Value |Description
|`bridgeEndpoint` |`false` a|
*Camel 2.1:* If the option is *`true`*, *`HttpProducer`* will ignore
the *`Exchange.HTTP_URI`* header, and use the endpoint's URI for
request. You may also set the *`throwExceptionOnFailure`* to be false to
let the *`HttpProducer`* send all the fault response back.

*Camel 2.3:* If the option is true, *`HttpProducer`*
and *`CamelServlet`* will skip the gzip processing if
the *`Content-Encoding`* is *`gzip`*.

Consider setting *`disableStreamCache=true`* to optimize when bridging.

|`chunked` |`true` |*Camel 2.2:* If this option is *`false`* Jetty
Servlet will disable the HTTP streaming and set the *`Content-Length`*
header on the response

|`continuationTimeout` |`null` a|
*Camel 2.6:* Allows to set a timeout in milliseconds when using
link:jetty.html[Jetty] as consumer (server). By default Jetty uses
*`30000`*. You can use a value of *`<= 0`* to never expire. If a timeout
occurs then the request will be expired and Jetty will return back an
HTTP error *`503`* to the client.

This option is only in use when using link:jetty.html[Jetty] with the
link:asynchronous-routing-engine.html[Asynchronous Routing Engine].

|`cookieHandler` |`null` |*Camel 2.19: Producer only* Configure a cookie
handler to maintain a HTTP session.

|`disableStreamCache` |`false` a|
*Camel 2.3:* Determines whether or not the raw input stream from Jetty
is cached or not (Camel will read the stream into a in memory/overflow
to file, link:stream-caching.html[Stream caching]) cache. By default
Camel will cache the Jetty input stream to support reading it multiple
times to ensure it Camel can retrieve all data from the stream. However,
you can set this option to *`true`* when you for example need to access
the raw stream, such as streaming it directly to a file or other
persistent store. 

*`DefaultHttpBinding`* will copy the request input stream into a stream
cache and put it into message body if this option is *`false`* to
support reading the stream multiple times. If you use
link:jetty.html[Jetty] to bridge/proxy an endpoint then consider
enabling this option to improve performance, in case you do not need to
read the message payload multiple times.

|`enableCORS` |`false` |*Camel 2.15:* if the option is *`true`*, Jetty
server will setup the *`CrossOriginFilter`* which supports the
https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS[CORS]
out of box.

|`enableJmx` |`false` |*Camel 2.3:* If this option is *`true`*, Jetty
JMX support will be enabled for this endpoint. See link:jetty.html[Jetty
JMX support] for more details.

|`enablemulti-partFilter` |`true` a|
*Camel 2.5:* Whether Jetty
*`org.eclipse.jetty.servlets.multi-partFilter`* is enabled or not.

Set this option to *`false`* when bridging endpoints, to ensure
multi-part requests is proxied/bridged as well.

|`filterInit.xxx` |`null` a|
*Camel 2.17*: Configuration for the *`InitParameters`* of filter.

For example, setting *`filterInit.parameter=value`* the parameter could
be used when calling the filter *`init()`* method.

|`filtersRef` |`null` |*Camel 2.9:* Allows using a custom filters which
is putted into a list and can be find in the
link:registry.html[Registry]

|`handlers` |`null` a|
Specifies a comma-delimited set of *`org.mortbay.jetty.Handler`*
instances in your link:registry.html[Registry] (such as your Spring
*`ApplicationContext`*). These handlers are added to the Jetty Servlet
context (for example, to add security).

*Note*: you can not use different handlers with different Jetty
endpoints using the same port number. The handlers is associated to the
port number. If you need different handlers, then use different port
numbers.

|`headerFilterStrategy` |`null` |*Camel 2.11:* Reference to a instance
of *`org.apache.camel.spi.HeaderFilterStrategy`* in the
link:registry.html[Registry]. It will be used to apply the
custom *`headerFilterStrategy`* on the new create *`HttpJettyEndpoint`*.

|`httpBindingRef` |`null` |Reference to an
*`org.apache.camel.component.http.HttpBinding`* in the
link:registry.html[Registry]. *`HttpBinding`* can be used to customize
how a response should be written for the consumer.

|`httpClient.xxx` |`null` |Configuration of Jetty's
http://www.eclipse.org/jetty/documentation/current/http-client-api.html[HttpClient].
For example, setting *`httpClient.idleTimeout=30000`* sets the idle
timeout to *`30`* seconds. And *`httpClient.timeout=30000`* sets the
request timeout to *`30`* seconds, in case you want to timeout sooner if
you have long running request/response calls.

|`httpClient` |`null` |To use a shared
*`org.eclipse.jetty.client.HttpClient`* for all producers created by
this endpoint. This option should only be used in special circumstances.

|`httpClientMinThreads` |`null` |*Camel 2.11:* *Producer only*: To set a
value for minimum number of threads in *`HttpClient`* thread pool. This
setting override any setting configured on component level. Notice that
both a min and max size must be configured. If not set it default to min
8 threads used in Jetty's thread pool.

|`httpClientMaxThreads` |`null` |*Camel 2.11:* *Producer only*: To set a
value for maximum number of threads in *`HttpClient`* thread pool. This
setting override any setting configured on component level. Notice that
both a min and max size must be configured. If not set it default to
max *`16`* threads used in Jetty's thread pool.

|`httpMethodRestrict` |`null` |*Camel 2.11:* *Consumer only*: Used to
only allow consuming if the *`HttpMethod`* matches, such
as *`GET/POST/PUT`* etc. From **Camel 2.15**: multiple methods can be
specified separated by comma.

|`jettyHttpBindingRef` |`null` |*Camel 2.6.0+:* Reference to an
*`org.apache.camel.component.jetty.JettyHttpBinding`* in the
link:registry.html[Registry]. *`JettyHttpBinding`* can be used to
customize how a response should be written for the producer.

|`matchOnUriPrefix` |`false` a|
Whether or not the *`CamelServlet`* should try to find a target consumer
by matching the URI prefix if no exact match is found.

See here link:how-do-i-let-jetty-match-wildcards.html[How do I let Jetty
match wildcards].

|`multi-partFilterRef` |`null` a|
*Camel 2.6:* Allows using a custom multi-part filter.

*Note*: setting *`multi-partFilterRef`* forces the value of
*`enablemulti-partFilter`* to *`true`*.

|`okStatusCodeRange` |`200-299` |**Camel 2.16:** *Producer only* The
status codes which is considered a success response. The values are
inclusive. The range must be defined as from-to with the dash included.

|`optionsEnabled` |`false` |*Camel 2.17:* Specifies whether to
enable *`HTTP OPTIONS`* for this Jetty consumer. By default *`OPTIONS`*
is turned off.

|`proxyHost` |`null` |*Camel 2.11:* *Producer only* The HTTP proxy Host
URL which will be used by Jetty client.

|`proxyPort` |`null` |*Camel 2.11:* *Producer only* The HTTP proxy port
which will be used by Jetty client.

|`responseBufferSize` |`null` |*Camel 2.12:* To use a custom buffer size
on the *`javax.servlet.ServletResponse`*.

|`sendDateHeader` |`false` a|
*Camel 2.14:* if the option is true, jetty server will send the date
header to the client which sends the request.

*Note*: ensure that there are no any other *`camel-jetty`* endpoints
that share the same port, otherwise this option may not work as
expected.

|`sendServerVersion` |`true` a|
*Camel 2.13:* if the option is true, jetty will send the server header
with the jetty version information to the client which sends the
request.

*Note*: ensure that there are no any other *`camel-jetty`* endpoints
that share the same port, otherwise this option may not work as
expected.

|`sessionSupport` |`false` |Specifies whether to enable the session
manager on the server side of Jetty.

|`sslContextParameters` |`null` a|
*Camel 2.17:* Reference to a
**`org.apache.camel.util.jsse.SSLContextParameters`** in the
link:registry.html[Registry].  This reference overrides any
configured *`SSLContextParameters`* at the component level.   

See link:camel-configuration-utilities.html[Using the JSSE Configuration
Utility].

|`sslContextParametersRef` |`null` a|
*Camel 2.8:* *Deprecated* Reference to a
*`org.apache.camel.util.jsse.SSLContextParameters`* in the
link:registry.html[Registry].  This reference overrides any
configured *`SSLContextParameters`* at the component level. 

See link:camel-configuration-utilities.html[Using the JSSE Configuration
Utility].

|`throwExceptionOnFailure` |`true` |Option to disable throwing the
*`HttpOperationFailedException`* in case of failed responses from the
remote server. This allows you to get all responses regardless of the
HTTP status code.

|`traceEnabled` |`false` |Specifies whether to enable *`HTTP TRACE`* for
this Jetty consumer. By default *`TRACE`* is turned off.

|`transferException` |`false` a|
*Camel 2.6:* If enabled and an link:exchange.html[Exchange] failed
processing on the consumer side, and if the caused Exception was send
back serialized in the response as a
*`application/x-java-serialized-object`* content type.

On the producer side the exception will be deserialized and thrown as
is, instead of the *`HttpOperationFailedException`*. The caused
exception is required to be serialized.

|`urlRewrite` |`null` a|
*Camel 2.11:* *Producer only* Refers to a custom
*`org.apache.camel.component.http.UrlRewrite`* which allows you to
rewrite URLs when you bridge/proxy endpoints.

See more details at link:urlrewrite.html[UrlRewrite] and
link:how-to-use-camel-as-a-http-proxy-between-a-client-and-server.html[How
to use Camel as a HTTP proxy between a client and server].

|`useContinuation` |`true` |*Camel 2.6:* Whether or not to use
http://wiki.eclipse.org/Jetty/Feature/Continuations[Jetty continuations]
for the Jetty Server.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.9]]
Message Headers
^^^^^^^^^^^^^^^

Camel uses the same message headers as the link:http.html[HTTP]
component. From *Camel 2.2*, it also uses
(*`Exchange.HTTP_CHUNKED`*, *`CamelHttpChunked`*) header to toggle
chunked encoding on the *`camel-jetty`* consumer. Camel also populates
_all_ *`request.parameter`* and *`request.headers`*. For example, given
a client request with the URL, `http://myserver/myserver?orderid=123`,
the exchange will contain a header named *`orderid`* with the value
*`123`*.

From *Camel 2.2.0*: you can get the request.parameter from the message
header not only from *`GET`* HTTP Method, but also other HTTP method.

[[BookComponentAppendix-Usage.4]]
Usage
^^^^^

The Jetty component supports both consumer and producer endpoints.
Another option for producing to other HTTP endpoints, is to use the
link:http.html[HTTP Component]

[[BookComponentAppendix-ComponentOptions]]
Component Options
^^^^^^^^^^^^^^^^^

The *`JettyHttpComponent`* provides the following options:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default Value |Description
|`allowJavaSerializedObject` |`false` a|
*Camel 2.16.1/2.15.5:* Whether to allow java serialization when a
request uses *`context-type=application/x-java-serialized-object`*.

When *`true`*, be aware that Java will deserialize the incoming data
from the request to Java and that can be a potential security risk.

|`enableJmx` |`false` |*Camel 2.3:* If this option is true, Jetty JMX
support will be enabled for this endpoint. See link:jetty.html[Jetty JMX
support] for more details.

|`errorHandler` |`null` |*Camel 2.15*: This option is used to set
the *`ErrorHandler`* that Jetty server uses.

|`httpClient` |`null` a|
*Deprecated:* *Producer only*: To use a custom *`HttpClient`* with the
jetty producer.

*Note*: from *Camel 2.11* this option has been removed. Set the option
on the endpoint instead.

|`httpClientMaxThreads` |`null` |*Producer only*: To set a value for
maximum number of threads in *`HttpClient`* thread pool. Notice that
both a min and max size must be configured.

|`httpClientMinThreads` |`null` |*Producer only*: To set a value for
minimum number of threads in *`HttpClient`* thread pool. Notice that
both a min and max size must be configured.

|`httpClientThreadPool` |`null` a|
*Deprecated:* *Producer only*: To use a custom thread pool for the
client.

*Note*: this option has been removed from *Camel 2.11*.

|`maxThreads` |`null` |*Camel 2.5* *Consumer only*: To set a value for
maximum number of threads in server thread pool. Notice that both a min
and max size must be configured.

|`minThreads` |`null` |*Camel 2.5* *Consumer only*: To set a value for
minimum number of threads in server thread pool. Notice that both a min
and max size must be configured.

|`proxyHost` |`null` |*Camel 2.12.2/2.11.3* To use an HTTP proxy.

|`proxyPort` |`null` |*Camel 2.12.2/2.11.3:* To use an HTTP proxy.

|`socketConnectors` |`null` |*Camel 2.5* *Consumer only:* A map which
contains per port number specific HTTP connectors. Uses the same
principle as *`sslSocketConnectors`* and therefore see section _SSL
support_ for more details.

|`socketConnectorProperties` |`null` |*Camel 2.5* *Consumer only*. A map
which contains general HTTP connector properties. Uses the same
principle as *`sslSocketConnectorProperties`* and therefore see section
_SSL support_ for more details.

|`sslContextParameters` |`null` a|
*Camel 2.8:* To configure a custom SSL/TLS configuration options at the
component level. 

See  http://camel.apache.org/camel-configuration-utilities.html[Using
the JSSE Configuration Utility] for more details.

|`sslKeyPassword` |`null` |*Consumer only*: The password for the
keystore when using SSL.

|`sslKeystore` |`null` |*Consumer only*: The path to the keystore.

|`sslPassword` |`null` |*Consumer only*: The password when using SSL.

|`sslSocketConnectors` |`null` |*Camel 2.3* *Consumer only:* A map which
contains per port number specific SSL connectors. See section _SSL
support_ for more details.

|`sslSocketConnectorProperties` |`null` |*Camel 2.5* *Consumer only*. A
map which contains general SSL connector properties. See section _SSL
support_ for more details.

|`requestBufferSize` |`null` |*Camel 2.11.2:* Allows to configure a
custom value of the request buffer size on the Jetty connectors.

|`requestHeaderSize` |`null` |*Camel 2.11.2:* Allows to configure a
custom value of the request header size on the Jetty connectors.

|`responseBufferSize` |`null` |*Camel 2.11.2:* Allows to configure a
custom value of the response buffer size on the Jetty connectors.

|`responseHeaderSize` |`null` |*Camel 2.11.2:* Allows to configure a
custom value of the response header size on the Jetty connectors.

|`threadPool` |`null` |*Camel 2.5* *Consumer only*: To use a custom
thread pool for the server. This option should only be used in special
circumstances.
|=======================================================================

[[BookComponentAppendix-ProducerExample]]
Producer Example
^^^^^^^^^^^^^^^^

The following is a basic example of how to send an HTTP request to an
existing HTTP endpoint.

*Java DSL*:

javafrom("direct:start") .to("jetty://http://www.google.com");

*XML DSL*:

xml<route> <from uri="direct:start"/> <to
uri="jetty://http://www.google.com"/> <route>

[[BookComponentAppendix-ConsumerExample]]
Consumer Example
^^^^^^^^^^^^^^^^

In this sample we define a route that exposes a HTTP service at
`http://localhost:8080/myapp/myservice`:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jetty9/src/test/java/org/apache/camel/component/jetty/JettyRouteTest.java}

Usage of localhost

When you specify *`localhost`* in a URL, Camel exposes the endpoint only
on the local TCP/IP network interface, so it cannot be accessed from
outside the machine it operates on.

If you need to expose a Jetty endpoint on a specific network interface,
the numerical IP address of this interface should be used as the host.
If you need to expose a Jetty endpoint on all network interfaces, the
*`0.0.0.0`* address should be used.

To listen across an entire URI prefix, see
link:how-do-i-let-jetty-match-wildcards.html[How do I let Jetty match
wildcards].

If you actually want to expose routes by HTTP and already have a
Servlet, you should instead refer to the
https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=46339[Servlet
Transport].

 

Our business logic is implemented in the *`MyBookService`* class, which
accesses the HTTP request contents and then returns a response. +
*Note:* The *`assert`* call appears in this example, because the code is
part of an unit
test.\{snippet:id=e2|lang=java|url=camel/trunk/components/camel-jetty9/src/test/java/org/apache/camel/component/jetty/JettyRouteTest.java}The
following sample shows a content-based route that routes all requests
containing the URI parameter, *`one`*, to the endpoint, *`mock:one`*,
and all others to
*`mock:other`*.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jetty9/src/test/java/org/apache/camel/component/jetty/JettyContentBasedRouteTest.java}If
a client sends an HTTP request, `http://serverUri?one=hello`, the Jetty
component will copy the HTTP request parameter, *`one`* to the
exchange's *`in.header`*. We can then use the *`simple`* language to
route exchanges that contain this header to a specific endpoint and all
others to another. If we used a language more powerful than
link:simple.html[Simple,] e.g., link:el.html[EL] or
link:ognl.html[OGNL], then we can also test for the parameter value and
route based on the header value as well.

[[BookComponentAppendix-SessionSupport]]
Session Support
^^^^^^^^^^^^^^^

The session support option, *`sessionSupport`*, can be used to enable a
*`HttpSession`* object and access the session object while processing
the exchange.

For example, the following route enables sessions:

xml<route> <from
uri="jetty:http://0.0.0.0/myapp/myservice/?sessionSupport=true"/>
<processRef ref="myCode"/> <route>

The *`myCode`* link:processor.html[Processor] can be instantiated by a
Spring *`bean`* element:

xml<bean id="myCode"class="com.mycompany.MyCodeProcessor"/>

Where the processor implementation can access the *`HttpSession`* as
follows:

javapublic void process(Exchange exchange) throws Exception \{
HttpSession session =
exchange.getIn(HttpMessage.class).getRequest().getSession(); // ... }

[[BookComponentAppendix-SSLSupport(HTTPS)]]
SSL Support (HTTPS)
^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-UsingtheJSSEConfigurationUtility.3]]
Using the JSSE Configuration Utility

From *Camel 2.8*: the *`camel-jetty`* component supports SSL/TLS
configuration through the link:camel-configuration-utilities.html[Camel
JSSE Configuration Utility].  This utility greatly decreases the amount
of component specific code you need to write and is configurable at the
endpoint and component levels.  The following examples demonstrate how
to use the utility with the Jetty component.

[[BookComponentAppendix-Programmaticconfigurationofthecomponent.1]]
Programmatic configuration of the component

javaKeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("/users/home/server/keystore.jks");
ksp.setPassword("keystorePassword"); KeyManagersParameters kmp = new
KeyManagersParameters(); kmp.setKeyStore(ksp);
kmp.setKeyPassword("keyPassword"); SSLContextParameters scp = new
SSLContextParameters(); scp.setKeyManagers(kmp); JettyComponent
jettyComponent = getContext().getComponent("jetty",
JettyComponent.class); jettyComponent.setSslContextParameters(scp);

[[BookComponentAppendix-SpringDSLbasedconfigurationofendpoint.2]]
Spring DSL based configuration of endpoint

xml<camel:sslContextParameters id="sslContextParameters">
<camel:keyManagers keyPassword="keyPassword"> <camel:keyStore
resource="/users/home/server/keystore.jks" password="keystorePassword"/>
</camel:keyManagers> </camel:sslContextParameters> <to
uri="jetty:https://127.0.0.1/mail/?sslContextParametersRef=sslContextParameters"/>

[[BookComponentAppendix-ConfiguringJettyDirectly]]
Configuring Jetty Directly

Jetty provides SSL support out of the box. To enable Jetty to run in SSL
mode, simply format the URI using the *`https://`* prefix.

*Example*:

xml<from uri="jetty:https://0.0.0.0/myapp/myservice/"/>

Jetty also needs to know where to load your keystore from and what
passwords to use in order to load the correct SSL certificate. Set the
following JVM System Properties:

*Before Camel 2.3*:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Property |Description
|`jetty.ssl.keystore` |Specifies the location of the Java *`keystore`*
file, which contains the Jetty server's own *`X.509`* certificate in a
_key entry_. A key entry stores the *`X.509`* certificate (effectively,
the _public key_) and also its associated private key.

|`jetty.ssl.password` |The store password, which is required to access
the *`keystore`* file (this is the same password that is supplied to the
*`keystore`* command's *`-storepass`* option).

|`jetty.ssl.keypassword` |The key password, which is used to access the
certificate's key entry in the *`keystore`* (this is the same password
that is supplied to the *`keystore`* command's *`-keypass`* option).
|=======================================================================

 

*From Camel 2.3*:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Property |Description
|`org.eclipse.jetty.ssl.keystore` |Specifies the location of the
Java *`keystore`* file, which contains the Jetty server's own *`X.509`*
certificate in a _key entry_. A key entry stores the *`X.509`*
certificate (effectively, the _public key_) and also its associated
private key.

|`org.eclipse.jetty.ssl.password` |The store password, which is required
to access the *`keystore`* file (this is the same password that is
supplied to the *`keystore`* command's *`keystore`* option).

|`org.eclipse.jetty.ssl.keypassword` |The key password, which is used to
access the certificate's key entry in the *`keystore`* (this is the same
password that is supplied to the *`keystore`* command's *`keystore`*
option).
|=======================================================================

For details of how to configure SSL on a Jetty endpoint, read the
following
http://www.eclipse.org/jetty/documentation/current/configuring-ssl.html[Jetty
documentation]. Some SSL properties aren't exposed directly by Camel.
However, Camel does expose the underlying *`SslSocketConnector`*, which
will allow you to set properties like *`needClientAuth`* for mutual
authentication requiring a client certificate or *`wantClientAuth`* for
mutual authentication where a client doesn't need a certificate but can
have one.

There's a slight difference between the various Camel versions:

*Up to Camel 2.2*

xml<bean id="jetty"
class="org.apache.camel.component.jetty.JettyHttpComponent"> <property
name="sslSocketConnectors"> <map> <entry key="8043"> <bean
class="org.mortbay.jetty.security.SslSocketConnector"> <property
name="password"value="..."/> <property name="keyPassword"value="..."/>
<property name="keystore"value="..."/> <property
name="needClientAuth"value="..."/> <property
name="truststore"value="..."/> </bean> </entry> </map> </property>
</bean>

*Camel 2.3, 2.4*

xml<bean id="jetty"
class="org.apache.camel.component.jetty.JettyHttpComponent"> <property
name="sslSocketConnectors"> <map> <entry key="8043"> <bean
class="org.eclipse.jetty.server.ssl.SslSocketConnector"> <property
name="password"value="..."/> <property name="keyPassword"value="..."/>
<property name="keystore"value="..."/> <property
name="needClientAuth"value="..."/> <property
name="truststore"value="..."/> </bean> </entry> </map> </property>
</bean>

From *Camel 2.5*: we switch to use *`SslSelectChannelConnector *`*

xml<bean id="jetty"
class="org.apache.camel.component.jetty.JettyHttpComponent"> <property
name="sslSocketConnectors"> <map> <entry key="8043"> <bean
class="org.eclipse.jetty.server.ssl.SslSelectChannelConnector">
<property name="password"value="..."/> <property
name="keyPassword"value="..."/> <property name="keystore"value="..."/>
<property name="needClientAuth"value="..."/> <property
name="truststore"value="..."/> </bean> </entry> </map> </property>
</bean>

The value you use as keys in the above map is the port you configure
Jetty to listen on.

[[BookComponentAppendix-ConfiguringGeneralSSLProperties]]
Configuring General SSL Properties
++++++++++++++++++++++++++++++++++

From *Camel 2.5*: instead of a per port number specific SSL socket
connector (as shown above) you can now configure general properties
which applies for all SSL socket connectors (which is not explicit
configured as above with the port number as entry).

xml<bean id="jetty"
class="org.apache.camel.component.jetty.JettyHttpComponent"> <property
name="sslSocketConnectorProperties"> <map> <entry
key="password"value="..."/> <entry key="keyPassword"value="..."/> <entry
key="keystore"value="..."/> <entry key="needClientAuth"value="..."/>
<entry key="truststore"value="..."/> </map> </property> </bean>

[[BookComponentAppendix-HowtoObtainAReferencetotheX509Certificate]]
How to Obtain A Reference to the `X509Certificate`
++++++++++++++++++++++++++++++++++++++++++++++++++

Jetty stores a reference to the certificate in
the *`HttpServletRequest`* which you can access from code as follows:

javaHttpServletRequest req =
exchange.getIn().getBody(HttpServletRequest.class); X509Certificate cert
= (X509Certificate)
req.getAttribute("javax.servlet.request.X509Certificate")

[[BookComponentAppendix-ConfiguringGeneralHTTPProperties]]
Configuring General HTTP Properties
+++++++++++++++++++++++++++++++++++

From *Camel 2.5*: instead of a per port number specific HTTP socket
connector (as shown above) you can now configure general properties
which applies for all HTTP socket connectors (which is not explicit
configured as above with the port number as entry).

xml<bean id="jetty"
class="org.apache.camel.component.jetty.JettyHttpComponent"> <property
name="socketConnectorProperties"> <map> <entry key="acceptors"
value="4"/> <entry key="maxIdleTime" value="300000"/> </map> </property>
</bean>

[[BookComponentAppendix-HowtoGettheValueofTheX-Forwarded-ForHTTPHeaderUsingHttpServletRequest.getRemoteAddr()]]
How to Get the Value of The `X-Forwarded-For` HTTP Header Using
`HttpServletRequest.getRemoteAddr()`
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

If the HTTP requests are handled by an Apache server and forwarded to
Jetty with *`mod_proxy`*, the original client IP address is in
the *`X-Forwarded-For`* header and
the *`HttpServletRequest.getRemoteAddr()`* will return the address of
the Apache proxy.

Jetty has a forwarded property which takes the value
from *`X-Forwarded-For`* and places it in
the *`HttpServletRequest remoteAddr`* property.  This property is not
available directly through the endpoint configuration but it can be
easily added using the *`socketConnectors`* property:

xml<bean id="jetty"
class="org.apache.camel.component.jetty.JettyHttpComponent"> <property
name="socketConnectors"> <map> <entry key="8080"> <bean
class="org.eclipse.jetty.server.nio.SelectChannelConnector"> <property
name="forwarded" value="true"/> </bean> </entry> </map> </property>
</bean>

This is particularly useful when an existing Apache server handles TLS
connections for a domain and proxies them to application servers
internally.

[[BookComponentAppendix-DefaultBehaviorforReturningHTTPStatusCodes]]
Default Behavior for Returning HTTP Status Codes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default behavior of HTTP status codes is defined by the
*`org.apache.camel.component.http.DefaultHttpBinding`* class, which
handles how a response is written and also sets the HTTP status code. If
the exchange was processed successfully, the *`200`* HTTP status code is
returned. If the exchange failed with an exception, the *`500`* HTTP
status code is returned, and the stacktrace is returned in the body. If
you want to specify which HTTP status code to return, set the code in
the *`Exchange.HTTP_RESPONSE_CODE`* header of the *`OUT`* message.

[[BookComponentAppendix-CustomizingHttpBinding]]
Customizing `HttpBinding`
^^^^^^^^^^^^^^^^^^^^^^^^^

By default, Camel uses the
*`org.apache.camel.component.http.DefaultHttpBinding`* to handle how a
response is written. If you like, you can customize this behavior either
by implementing your own *`HttpBinding`* class or by extending
*`DefaultHttpBinding`* and overriding the appropriate methods.

The following example shows how to customize the *`DefaultHttpBinding`*
in order to change how exceptions are
returned:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jetty9/src/test/java/org/apache/camel/component/jetty/HttpBindingRefTest.java}We
can then create an instance of our binding and register it in the Spring
registry as follows:

xml<bean id="mybinding"class="com.mycompany.MyHttpBinding"/>

And then we can reference this binding when we define the route:

xml<route> <from
uri="jetty:http://0.0.0.0:8080/myapp/myservice?httpBindingRef=mybinding"/>
<to uri="bean:doSomething"/> </route>

[[BookComponentAppendix-JettyHandlersandSecurityConfiguration]]
Jetty Handlers and Security Configuration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can configure a list of Jetty handlers on the endpoint, which can be
useful for enabling advanced Jetty security features. These handlers are
configured in Spring XML as follows:

xml<-- Jetty Security handling --> <bean id="userRealm"
class="org.mortbay.jetty.plus.jaas.JAASUserRealm"> <property name="name"
value="tracker-users"/> <property name="loginModuleName"
value="ldaploginmodule"/> </bean> <bean id="constraint"
class="org.mortbay.jetty.security.Constraint"> <property name="name"
value="BASIC"/> <property name="roles" value="tracker-users"/> <property
name="authenticate" value="true"/> </bean> <bean id="constraintMapping"
class="org.mortbay.jetty.security.ConstraintMapping"> <property
name="constraint" ref="constraint"/> <property name="pathSpec"
value="/*"/> </bean> <bean id="securityHandler"
class="org.mortbay.jetty.security.SecurityHandler"> <property
name="userRealm" ref="userRealm"/> <property name="constraintMappings"
ref="constraintMapping"/> </bean>

From *Camel 2.3*: you can configure a list of Jetty handlers as follows:

xml<-- Jetty Security handling --> <bean id="constraint"
class="org.eclipse.jetty.http.security.Constraint"> <property
name="name" value="BASIC"/> <property name="roles"
value="tracker-users"/> <property name="authenticate" value="true"/>
</bean> <bean id="constraintMapping"
class="org.eclipse.jetty.security.ConstraintMapping"> <property
name="constraint" ref="constraint"/> <property name="pathSpec"
value="/*"/> </bean> <bean id="securityHandler"
class="org.eclipse.jetty.security.ConstraintSecurityHandler"> <property
name="authenticator"> <bean
class="org.eclipse.jetty.security.authentication.BasicAuthenticator"/>
</property> <property name="constraintMappings"> <list> <ref
bean="constraintMapping"/> </list> </property> </bean>

You can then define the endpoint as:

javafrom("jetty:http://0.0.0.0:9080/myservice?handlers=securityHandler")

If you need more handlers, set the *`handlers`* option equal to a
comma-separated list of bean IDs.

[[BookComponentAppendix-HowtoCustomizetheResponseonanHTTP500ServerError]]
How to Customize the Response on an `HTTP 500` Server Error
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You may want to return a custom reply message when something goes wrong,
instead of the default reply message Camel link:jetty.html[Jetty]
replies with. You could use a custom *`HttpBinding`* to be in control of
the message mapping, but often it may be easier to use Camel's
link:exception-clause.html[Exception Clause] to construct the custom
reply message.

Example: return the message: *`Dude something went wrong`* for the HTTP
error code
*`500`*:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jetty9/src/test/java/org/apache/camel/component/jetty/JettyOnExceptionHandledTest.java}

[[BookComponentAppendix-Multi-PartFormSupport]]
Multi-Part Form Support
^^^^^^^^^^^^^^^^^^^^^^^

From *Camel 2.3.0*: *`camel-jetty`* support to multi-part form post out
of box. The submitted form-data are mapped into the message
header. *`camel-jetty`* creates an attachment for each uploaded file.
The file name is mapped to the name of the attachment. The content type
is set as the content type of the attachment file name. You can find the
example
here.\{snippet:id=e1|lang=java|url=camel/components/camel-jetty9/src/test/java/org/apache/camel/component/jetty/MultiPartFormTest.java|title=Note:
getName() functions as shown below in versions 2.5 and higher. In
earlier versions you receive the temporary file name for the attachment
instead}

[[BookComponentAppendix-JettyJMXSupport]]
Jetty JMX Support
^^^^^^^^^^^^^^^^^

From *Camel 2.3.0*: *`camel-jetty`* supports the enabling of Jetty's JMX
capabilities at the component and endpoint level with the endpoint
configuration taking priority.

*Note*: JMX must be enabled within the Camel context in order to enable
JMX support in this component as the component provides Jetty with a
reference to the *`MBeanServer`* registered with the Camel context.

As the *`camel-jetty`* component caches and reuses Jetty resources for a
given protocol/host/port pairing, this configuration option will only be
evaluated during the creation of the first endpoint to use a
protocol/host/port pairing.

*Example*: given two routes created from the following XML fragments,
JMX support would remain enabled for all endpoints listening on:
*`https://0.0.0.0`*.

xml<from uri="jetty:https://0.0.0.0/myapp/myservice1/?enableJmx=true"/>
xml<from uri="jetty:https://0.0.0.0/myapp/myservice2/?enableJmx=false"/>

The *`camel-jetty`* component also provides for direct configuration of
the Jetty *`MBeanContainer`*. Jetty creates MBean names dynamically. If
you are running another instance of Jetty outside of the Camel context
and sharing the same *`MBeanContainer`* between the instances, you can
provide both instances with a reference to the same *`MBeanContainer`*
in order to avoid name collisions when registering Jetty MBeans.

link:endpoint-see-also.html[Endpoint See Also]

* link:http.html[HTTP]

[[BookComponentAppendix-JingComponent]]
Jing Component
~~~~~~~~~~~~~~

The Jing component uses the
http://www.thaiopensource.com/relaxng/jing.html[Jing Library] to perform
XML validation of the message body using either

* http://relaxng.org/[RelaxNG XML Syntax]
* http://relaxng.org/compact-tutorial-20030326.html[RelaxNG Compact
Syntax]

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-jing</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

Note that the link:msv.html[MSV] component can also support RelaxNG XML
syntax.

[[BookComponentAppendix-URIformatCamel2.15orolder]]
URI format Camel 2.15 or older
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
rng:someLocalOrRemoteResource
rnc:someLocalOrRemoteResource
----

Where *rng* means use the http://relaxng.org/[RelaxNG XML Syntax]
whereas *rnc* means use
http://relaxng.org/compact-tutorial-20030326.html[RelaxNG Compact
Syntax]. The following examples show possible URI values

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Example |Description
|rng:foo/bar.rng |References the XML file *foo/bar.rng* on the classpath
a|
rnc:

http://foo.com/bar.rnc

 a|
References the RelaxNG Compact Syntax file from the URL,

http://foo.com/bar.rnc

|=======================================================================

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-URIformatCamel2.16]]
URI format Camel 2.16
^^^^^^^^^^^^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
jing:someLocalOrRemoteResource
----

From Camel 2.16 the component use jing as name, and you can use the
option compactSyntax to turn on either RNG or RNC mode.

[[BookComponentAppendix-Options.27]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|compactSyntax |`false` |Whether to validate using RelaxNG compact
syntax or not.
|=======================================================================

[[BookComponentAppendix-Example.3]]
Example
^^^^^^^

The following
http://svn.apache.org/repos/asf/camel/trunk/components/camel-jing/src/test/resources/org/apache/camel/component/validator/jing/rnc-context.xml[example]
shows how to configure a route from the endpoint *direct:start* which
then goes to one of two endpoints, either *mock:valid* or *mock:invalid*
based on whether or not the XML matches the given
http://relaxng.org/compact-tutorial-20030326.html[RelaxNG Compact
Syntax] schema (which is supplied on the classpath).

[[BookComponentAppendix-SeeAlso.18]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-JMSComponent]]
JMS Component
~~~~~~~~~~~~~

Using ActiveMQ

If you are using http://activemq.apache.org/[Apache ActiveMQ], you
should prefer the link:activemq.html[ActiveMQ] component as it has been
optimized for link:activemq.html[ActiveMQ]. All of the options and
samples on this page are also valid for the link:activemq.html[ActiveMQ]
component.

Transacted and caching

See section _Transactions and Cache Levels_ below if you are using
transactions with link:jms.html[JMS] as it can impact performance.

Request/Reply over JMS

Make sure to read the section _Request-reply over JMS_ further below on
this page for important notes about request/reply, as Camel offers a
number of options to configure for performance, and clustered
environments.

This component allows messages to be sent to (or consumed from) a
http://java.sun.com/products/jms/[JMS] Queue or Topic. It uses Spring's
JMS support for declarative transactions, including Spring's
*`JmsTemplate`* for sending and a *`MessageListenerContainer`* for
consuming.

Maven users will need to add the following dependency to their
*`pom.xml`* for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jms</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIFormat.4]]
URI Format
^^^^^^^^^^

jms:[queue:|topic:]destinationName[?options]

Where *`destinationName`* is a JMS queue or topic name. By default, the
*`destinationName`* is interpreted as a queue name. For example, to
connect to the queue, *`FOO.BAR`* use:

jms:FOO.BAR

You can include the optional *`queue:`* prefix, if you prefer:

jms:queue:FOO.BAR

To connect to a topic, you _must_ include the *`topic:`* prefix. For
example, to connect to the topic, *`Stocks.Prices`*, use:

jms:topic:Stocks.Prices

You append query options to the URI using the following format:
*`?option=value&option=value&...`*

[[BookComponentAppendix-Notes]]
Notes
^^^^^

Using ActiveMQ

The JMS component reuses Spring 2's *`JmsTemplate`* for sending
messages. This is not ideal for use in a non-J2EE container and
typically requires some caching in the JMS provider to avoid
http://activemq.apache.org/jmstemplate-gotchas.html[poor performance].

If you intend to use http://activemq.apache.org/[Apache ActiveMQ] as
your Message Broker - which is a good choice as ActiveMQ rocks
image:https://cwiki.apache.org/confluence/s/en_GB/5997/6f42626d00e36f53fe51440403446ca61552e2a2.1/_/images/icons/emoticons/smile.png[(smile)]
, then we recommend that you either:

* Use the link:activemq.html[ActiveMQ] component, which is already
optimized to use ActiveMQ efficiently
* Use the *`PoolingConnectionFactory`* in ActiveMQ

[[BookComponentAppendix-TransactionsandCacheLevels]]
Transactions and Cache Levels
+++++++++++++++++++++++++++++

transactionCacheLevels +
If you are consuming messages and using transactions
(*`transacted=true`*) then the default cache level can negatively impact
performance. If you are using XA transactions then you cannot cache as
it can cause the XA transaction to not work properly.

If you are _not_ using XA, then you should consider caching as it speeds
up performance, such as setting *`cacheLevelName=CACHE_CONSUMER`*.
Through Camel 2.7.x, the default setting for *`cacheLevelName`* is
*`CACHE_CONSUMER`*. You will need to explicitly set
*`cacheLevelName=CACHE_NONE`*. In Camel 2.8 onward, the default setting
for *`cacheLevelName`* is *`CACHE_AUTO`*. This default auto detects the
mode and sets the cache level accordingly to:

* *`CACHE_CONSUMER`* when *`transacted=false`*
* *`CACHE_NONE`* when *`transacted=true`*

So you can say the default setting is conservative. Consider using
*`cacheLevelName=CACHE_CONSUMER`* if you are using non-XA transactions.

[[BookComponentAppendix-DurableSubscriptions]]
Durable Subscriptions
+++++++++++++++++++++

If you wish to use durable topic subscriptions, you need to specify
both *`clientId`*  and *`durableSubscriptionName`.* The value of the
*`clientId`* must be unique and can only be used by a single JMS
connection instance in your entire network. You may prefer to use
http://activemq.apache.org/virtual-destinations.html[Virtual Topics]
instead to avoid this limitation. More background on durable messaging
http://activemq.apache.org/how-do-durable-queues-and-topics-work.html[here].

[[BookComponentAppendix-MessageHeaderMapping]]
Message Header Mapping
++++++++++++++++++++++

When using message headers, the JMS specification states that header
names must be valid Java identifiers. So try to name your headers to be
valid Java identifiers. One benefit of doing this is that you can then
use your headers inside a JMS Selector (whose SQL92 syntax mandates Java
identifier syntax for headers).

A simple strategy for mapping header names is used by default. The
strategy is to replace any dots and hyphens in the header name as shown
below and to reverse the replacement when the header name is restored
from a JMS message sent over the wire. What does this mean? No more
losing method names to invoke on a bean component, no more losing the
filename header for the File Component, and so on.

The current header name strategy for accepting header names in Camel is:

* Dots are replaced by *`_DOT_`* and the replacement is reversed when
Camel consume the message
* Hyphen is replaced by *`_HYPHEN_`* and the replacement is reversed
when Camel consumes the message

[[BookComponentAppendix-ConfigurationOptions]]
Configuration Options
^^^^^^^^^^^^^^^^^^^^^

You can configure many different properties on the JMS endpoint which
map to properties on the
http://camel.apache.org/maven/current/camel-jms/apidocs/org/apache/camel/component/jms/JmsConfiguration.html[JMSConfiguration
POJO].

Mapping to Spring JMS

Many of these properties map to properties on Spring JMS, which Camel
uses for sending and receiving messages. Therefore for more information
about these properties consult the Spring documentation.

The options are divided into two tables, the first one contains the most
common options. The second table contains the less common and more
advanced options.

[[BookComponentAppendix-CommonOptions]]
Common Options
++++++++++++++

 

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default Value |Description
|`clientId` |`null` |Sets the JMS client ID to use. Note that this
value, if specified, must be unique and can only be used by a single JMS
connection instance. It is typically only required for durable topic
subscriptions. You may prefer to use
http://activemq.apache.org/virtual-destinations.html[Virtual Topics]
instead.

|`concurrentConsumers` |`1` a|
Specifies the default number of concurrent consumers.

From *Camel 2.10.3*: this option can also be used when doing
request/reply over JMS.

From *Camel 2.16*: there is a new *`replyToConcurrentConsumers`*.

See the *`maxMessagesPerTask`* option to control dynamic scaling up/down
of threads.

When using ActiveMQ beware that the default prefetch policy loads 1000
messages per consumer. See
http://activemq.apache.org/what-is-the-prefetch-limit-for.html[What is
the prefetch limit] on how to change this.

|`disableReplyTo` |`false` |When *`true`*, a producer will behave like
a *`InOnly`* exchange with the exception that *`JMSReplyTo`* header is
sent out and not be suppressed like in the case of *`InOnly`*. Like
*`InOnly`* the producer will not wait for a reply. A consumer with this
flag will behave like *`InOnly`*. This feature can be used to bridge
*`InOut`* requests to another queue so that a route on the other queue
will send it´s response directly back to the original *`JMSReplyTo`*.

|`durableSubscriptionName` |`null` |The durable subscriber name for
specifying durable topic subscriptions. The *`clientId`* option *must*
be configured as well.

|`maxConcurrentConsumers` |`1` a|
Specifies the maximum number of concurrent consumers.

From *Camel 2.10.3*: this option can also be used when doing
request/reply over JMS.  

From **Camel 2.16**: there is a new *`replyToMaxConcurrentConsumers`*.

See also the *`maxMessagesPerTask`* option to control dynamic scaling
up/down of threads.

The **`maxMessagesPerTask`** option _must_ be set to an integer greater
than *`0`* for threads to scale down. Otherwise, the number of threads
will remain at *`maxConcurrentConsumers`* until shutdown.

|`maxMessagesPerTask` |`-1` a|
The number of messages a task can receive after which it's terminated.
The default, *`-1`*, is unlimited.

If you use a range for concurrent consumers
e.g., *`concurrentConsumers`* `<` *`maxConcurrentConsumers`* then this
option can be used to set a value to e.g., *`100`* to control how fast
the consumers will shrink when less work is required.

|`preserveMessageQos` |`false` a|
Set to *`true`*, if you want to send message using the QoS settings
specified on the message, instead of the QoS settings on the JMS
endpoint. The following headers are considered:

* *`JMSPriority`*
* *`JMSDeliveryMode`*
* *`JMSExpiration`*.

You can provide some or all of them.

If not provided, Camel will fall back to use the values from the
endpoint instead. So, when using this option, the headers override the
values from the endpoint.

The *`explicitQosEnabled`* option, by contrast, will only use options
set on the endpoint, and not values from the message header.

|`replyTo` |`null` a|
Provides an explicit *`ReplyTo`* destination, which overrides any
incoming value of *`Message.getJMSReplyTo()`*.

If you do link:request-reply.html[Request Reply] over JMS then *make
sure* to read the section _Request-reply over JMS_ further below for
more details, and the *`replyToType`* option as well.

|`replyToConcurrentConsumers` |`1` |*Camel 2.16*: Specifies the default
number of concurrent consumers when doing request/reply over JMS.

|`replyToMaxConcurrentConsumers` |`1` a|
*Camel 2.16*: Specifies the maximum number of concurrent consumers when
doing request/reply over JMS.

See the *`maxMessagesPerTask`* option to control dynamic scaling up/down
of threads.

|`replyToOnTimeoutMaxConcurrentConsumers` |`1` |*Camel 2.17.2*:
Specifies the maximum number of concurrent consumers for continue
routing when timeout occurred when using request/reply over JMS.

|`replyToOverride` |`null` |*Camel 2.15:* Provides an
explicit *`ReplyTo`* destination in the JMS message, which overrides the
setting of *`ReplyTo`*. It is useful if you want to forward the message
to a remote Queue and receive the reply message from the *`ReplyTo`*
destination.

|`replyToType` |`null` a|
*Camel 2.9:* Allows for explicitly specifying which kind of strategy to
use for *`replyTo`* queues when doing request/reply over JMS. Possible
values are:

* *`Temporary`*
* *`Shared`*
* *`Exclusive`*

By default Camel will use *`Temporary`* queues.

However if *`replyTo`* has been configured, then *`Shared`* is used by
default. This option allows you to use exclusive queues instead of
shared queues.

For more details see below, and especially the notes about the
implications if running in a clustered environment, and the fact that
*`Shared`* reply queues has lower performance than its alternatives
*`Temporary`* and *`Exclusive`*.

|`requestTimeout` |`20000` a|
*Producer only:* The timeout for waiting for a reply when using
the *`InOut`* link:exchange-pattern.html[Exchange Pattern] (in
milliseconds).

From *Camel 2.13/2.12.3*: you can include the header
*`CamelJmsRequestTimeout`* to override this endpoint configured timeout
value, and thus have per message individual timeout values.

See below in section _About time to live_ for more details. See also
the *`requestTimeoutCheckerInterval`* option.

|`selector` |`null` a|
Sets the JMS Selector, which is an SQL 92 predicate that is used to
filter messages within the broker. You may have to encode special
characters like '*`='`* as *`%3D`*.

Before *Camel 2.3.0*: this option was not supported
in *`CamelConsumerTemplate`*.

|`timeToLive` |`null` a|
When sending messages, specifies the time-to-live of the message (in
milliseconds).

See below in section _About time to live_ for more details.

|`transacted` |`false` |Specifies whether to use transacted mode for
sending/receiving messages using the *`InOnly`*
link:exchange-pattern.html[Exchange Pattern].

|`testConnectionOnStartup` |`false` a|
*Camel 2.1:* Specifies whether to test the connection on startup. This
ensures that when Camel starts that all the JMS consumers have a valid
connection to the JMS broker. If a connection cannot be granted then
Camel throws an exception on startup. This ensures that Camel is not
started with failed connections.

From *Camel 2.8*: also the JMS producers is tested as well.

|=======================================================================

[[BookComponentAppendix-AdvancedOptions]]
Advanced Options
++++++++++++++++

confluenceTableSmall 

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default Value |Description
|`acceptMessagesWhileStopping` |`false` a|
Specifies whether the consumer accept messages while it is stopping.

You may consider enabling this option, if you start and stop
link:jms.html[JMS] routes at run-time, while there are still messages
enqueued on the queue. If this option is *`false`*, and you stop the
link:jms.html[JMS] route, then messages may be rejected, and the JMS
broker would have to attempt re-deliveries, which yet again may be
rejected, and eventually the message may be moved at a dead letter queue
on the JMS broker. To avoid this scenario it's recommended this option
be set to *`true`*.

|`acknowledgementModeName` |`AUTO_ACKNOWLEDGE` a|
The JMS acknowledgement name, which is one of:

* *`SESSION_TRANSACTED`*
* *`CLIENT_ACKNOWLEDGE`*
* *`AUTO_ACKNOWLEDGE`*
* *`DUPS_OK_ACKNOWLEDGE`*.

|`acknowledgementMode` |`-1` |The JMS acknowledgement mode defined as an
Integer. Allows you to set vendor-specific extensions to the
acknowledgment mode. For the regular modes, it is preferable to use the
*`acknowledgementModeName`* instead.

|`allowNullBody` |`true` |*Camel 2.9.3/2.10.1:* Whether to allow sending
messages with no body. If this option is `false` and the message body is
null, then an *`JMSException`* is thrown.

|`allowReplyManagerQuickStop` |`false` |Whether
the *`DefaultMessageListenerContainer`* used in the reply managers for
request-reply messaging allow
the *`DefaultMessageListenerContainer.runningAllowed`* flag to quick
stop in case link *`JmsConfigurationisAcceptMessagesWhileStopping()`* is
enabled and CamelContext is currently being stopped. This quick stop
ability is enabled by default in the regular JMS consumers but to enable
for reply managers you must enable this flag.

|`alwaysCopyMessage` |`false` a|
If *`true`*, Camel will always make a JMS message copy of the message
when it is passed to the producer for sending. Copying the message is
needed in some situations, such as when a
*`replyToDestinationSelectorName`* is set.

Camel will set the *`alwaysCopyMessage=true`*, if a
*`replyToDestinationSelectorName`* is set.

|`asyncConsumer` |`false` a|
*Camel 2.9:* Whether the *`JmsConsumer`* processes the
link:exchange.html[Exchange]
link:asynchronous-routing-engine.html[asynchronously]. If enabled then
the *`JmsConsumer`* may pickup the next message from the JMS queue,
while the previous message is being processed asynchronously (by the
link:asynchronous-routing-engine.html[Asynchronous Routing Engine]).
This means that messages may be processed not 100% strictly in order. If
disabled (as default) then the link:exchange.html[Exchange] is fully
processed before the *`JmsConsumer`* will pickup the next message from
the JMS queue.

*Note*: if *`transacted`* has been enabled, then *`asyncConsumer=true`*
does not run asynchronously, as transactions must be executed
synchronously (Camel 3.0 may support asynchronous transactions).

|`asyncStartListener` |`false` |*Camel 2.10:* Whether to startup the
*`JmsConsumer`* message listener asynchronously, when starting a route.
For example if a *`JmsConsumer`* cannot get a connection to a remote JMS
broker, then it may block while retrying and/or failover. This will
cause Camel to block while starting routes. By setting this option to
`true`, you will let routes startup, while the *`JmsConsumer`* connects
to the JMS broker using a dedicated thread in asynchronous mode. If this
option is used, then beware that if the connection could not be
established, then an exception is logged at `WARN` level, and the
consumer will not be able to receive messages. You can then restart the
route to retry.

|`asyncStopListener` |`false` |*Camel 2.10:* Whether to stop the
*`JmsConsumer`* message listener asynchronously, when stopping a route.

|`autoStartup` |`true` |Specifies whether the consumer container should
auto-startup.

|`cacheLevel` |  |Sets the cache level by ID for the underlying JMS
resources. See *`cacheLevelName`* option for more details.

|`cacheLevelName` a|
* `CACHE_AUTO` (Camel >= 2.8.0)` `
* `CACHE_CONSUMER `(Camel <= 2.7.1)

 a|
Sets the cache level by name for the underlying JMS resources. Valid
values are:

* *`CACHE_NONE`*
* *`CACHE_CONNECTION`*
* *`CACHE_SESSION`*
* *`CACHE_CONSUMER`*
* *`CACHE_AUTO`*

From *Camel 2.8*: the default is *`CACHE_AUTO`*.

For *Camel 2.7.1* and older the default is *`CACHE_CONSUMER`*.

See the
https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jms/listener/DefaultMessageListenerContainer.html[Spring
documentation] and link:jms.html[Transactions Cache Levels] for more
information.

|`connectionFactory` |`null` |The default JMS connection factory to use
for the *`listenerConnectionFactory`* and *`templateConnectionFactory`*,
if neither is specified.

|`consumerType` |`Default` a|
The Spring JMS listener type to use. A valid value is one of: *`Simple`,
`Default`* or *`Custom`*.

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|`consumerType` |Spring JMS Listener Type
|`Default`
|*`org.springframework.jms.listener.DefaultMessageListenerContainer`*

|`Simple`
|*`org.springframework.jms.listener.SimpleMessageListenerContainer`*

|`Custom` |From *Camel 2.10.2*: The *`MessageListenerContainerFactory`*
defined by the *`messageListenerContainerFactoryRef`* option which will
determine what
**`org.springframework.jms.listener.AbstractMessageListenerContainer `**to
use.
|=======================================================================

This option was temporarily removed in Camel 2.7 and 2.8 but was
re-added in Camel 2.9.

|`defaultTaskExecutorType` |`SimpleAsync` a|
*Camel 2.10.4:* Specifies what default *`TaskExecutor`* type to use in
the *`DefaultMessageListenerContainer`*, for both consumer endpoints and
the *`ReplyTo`* consumer of producer endpoints. Possible values:
*`SimpleAsync`* (uses Spring's
http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html[SimpleAsyncTaskExecutor])
or *`ThreadPool`* (uses Spring's
http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html[ThreadPoolTaskExecutor]
with optimal values - cached threadpool-like).

If not set, it defaults to the previous behavior, which uses a cached
thread pool for consumer endpoints and *`SimpleAsync`* for reply
consumers.

The use of *`ThreadPool`* is recommended to reduce "thread trash" in
elastic configurations with dynamically increasing and decreasing
concurrent consumers.

|`deliveryMode` |`null` |*Camel 2.12.2/2.13:* Specifies the delivery
mode to be used. Possibles values are those defined by
*`javax.jms.DeliveryMode`*.

|`deliveryPersistent` |`true` |Specifies whether persistent delivery is
used by default.

|`destination` |`null` |Specifies the JMS Destination object to use on
this endpoint.

|`destinationName` |`null` |Specifies the JMS destination name to use on
this endpoint.

|`destinationResolver` |`null` |A pluggable
*`org.springframework.jms.support.destination.DestinationResolver`* that
allows you to use your own resolver (for example, to lookup the real
destination in a JNDI registry).

|`disableTimeToLive` |`false` a|
*Camel 2.8:* Use this option to force disabling time to live. For
example when you do request/reply over JMS, then Camel will by default
use the *`requestTimeout`* value as time to live on the message being
sent. The problem is that the sender and receiver systems have to have
their clocks synchronized, so they are in sync. This is not always so
easy to archive. So you can use *`disableTimeToLive=true`* to *not* set
a time to live value on the sent message. Then the message will not
expire on the receiver system.

See below in section _About time to live_ for more details.

|`eagerLoadingOfProperties` |`false` |Enables eager loading of JMS
properties as soon as a message is received, which is generally
inefficient, because the JMS properties might not be required. But this
feature can sometimes catch early any issues with the underlying JMS
provider and the use of JMS properties. This feature can also be used
for testing purposes, to ensure JMS properties can be understood and
handled correctly.

|`errorHandler` |`null` a|
*Camel 2.8.2, 2.9:* Specifies a
*`org.springframework.util.ErrorHandler`* to be invoked in case of any
uncaught exceptions thrown while processing a *`Message`*.

By default these exceptions will be logged at the *`WARN`* level, if no
*`errorHandler`* has been configured.

From *Camel 2.9.1*: you can configure logging level and whether stack
traces should be logged using the below two options. This makes it much
easier to configure, than having to code a custom *`errorHandler`*.

|`errorHandlerLoggingLevel` |`WARN` |*Camel 2.9.1:* Configures the
logging level at which the *`errorHandler`* will log uncaught
exceptions.

|`errorHandlerLogStackTrace` |`true` |*Camel 2.9.1:* Controls whether a
stacktrace should be logged by the default *`errorHandler`*.

|`exceptionListener` |`null` |Specifies the JMS Exception Listener that
is to be notified of any underlying JMS exceptions.

|`explicitQosEnabled` |`false` |Set if the *`deliveryMode`, `priority`*
or *`timeToLive`* qualities of service should be used when sending
messages. This option is based on Spring's *`JmsTemplate`*. The
*`deliveryMode`, `priority`* and *`timeToLive`* options are applied to
the current endpoint. This contrasts with the *`preserveMessageQos`*
option, which operates at message granularity, reading QoS properties
exclusively from the Camel In message headers.

|`exposeListenerSession` |`true` |Specifies whether the listener session
should be exposed when consuming messages.

|`forceSendOriginalMessage` |`false` |*Camel 2.7:* When using
*`mapJmsMessage=false`* Camel will create a new JMS message to send to a
new JMS destination if you touch the headers (get or set) during the
route. Set this option to *`true`* to force Camel to send the original
JMS message that was received.

|`idleConsumerLimit` |`1` |*Camel 2.8.2*, *2.9*: Specify the limit for
the number of consumers that are allowed to be idle at any given time.

|`idleTaskExecutionLimit` |`1` |Specifies the limit for idle executions
of a receive task, not having received any message within its execution.
If this limit is reached, the task will shut down and leave receiving to
other executing tasks (in the case of dynamic scheduling; see the
*`maxConcurrentConsumers`* setting). There is additional doc available
from
https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jms/listener/DefaultMessageListenerContainer.html#setIdleTaskExecutionLimit-int-[Spring].

|`includeSentJMSMessageID` |`false` |*Camel 2.10.3:* Only applicable
when sending to JMS destination using *`InOnly`*, e.g., fire and forget.
Enabling this option will enrich the Camel link:exchange.html[Exchange]
with the actual *`JMSMessageID`* that was used by the JMS client when
the message was sent to the JMS destination.

|`includeAllJMSXProperties` |`false` a|
*Camel 2.11.2/2.12:* Whether to include all *`JMSXxxx`* properties when
mapping from JMS to Camel Message. When set to `true` properties such as
*`JMSXAppID`*, and *`JMSXUserID`* etc will be included.

*Note:* If you are using a custom *`headerFilterStrategy`* then this
option does not apply.

|`jmsKeyFormatStrategy` |`default` a|
Pluggable strategy for encoding and decoding JMS keys so they can be
compliant with the JMS specification.

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Strategy |Description
|`default` |Safely marshals dots and hyphens, `'.'` and `'-'`.

|`passthrough` |Leaves the key as is. Appropriate for use with any JMS
broker that tolerates JMS header keys containing illegal characters.
|=======================================================================

*Note*: optionally, a custom implementation can be provided of a
*`org.apache.camel.component.jms.JmsKeyFormatStrategy`* and referred to
using the *`#`* notation.

|`jmsMessageType` |`null` a|
Allows you to force the use of a specific *`javax.jms.Message`*
implementation for sending JMS messages. Possible values are:

* *`Bytes`*
* *`Map`*
* *`Object`*
* *`Stream`*
* *`Text`*

By default Camel determines which JMS message type to use for the *`In`*
body type. This option will override the default behavior.

|`jmsOperations` |`null` |Allows you to use your own implementation of
the *`org.springframework.jms.core.JmsOperations`* interface. Camel uses
*`JmsTemplate`* by default. Can be used for testing purpose, but not
used much as stated in the spring API docs.

|`lazyCreateTransactionManager` |`true` |If *`true`*, Camel will create
a *`JmsTransactionManager`*, if there is no *`transactionManager`*
injected when option *`transacted=true`*.

|`listenerConnectionFactory` |`null` |The JMS connection factory used
for consuming messages.

|`mapJmsMessage` |`true` |Specifies whether Camel should auto map the
received JMS message to an appropriate payload type, such as
*`javax.jms.TextMessage`* to a *`java.lang.``String`* etc. See below for
more details on how message type mapping works.

|`maximumBrowseSize` |`-1` |Limits the number of messages fetched at
most, when browsing endpoints using link:browse.html[Browse] or JMX API.

|`messageConverter` |`null` |To use a custom Spring
*`org.springframework.jms.support.converter.MessageConverter`* so you
can be 100% in control how to map to/from a *`javax.jms.Message`*.

|`messageIdEnabled` |`true` |When sending, specifies whether message IDs
should be added.

|`messageListenerContainerFactoryRef` |`null` a|
*Camel 2.10.2:* Registry ID of the *`MessageListenerContainerFactory`*
used to determine what
*`org.springframework.jms.listener.AbstractMessageListenerContainer`* to
use to consume messages.

Setting this will automatically set *`consumerType`* to *`Custom`*.

|`messageTimestampEnabled` |`true` |Specifies whether time-stamps should
be enabled by default on sending messages.

|`password` |`null` |The password for the connector factory.

|`priority` |`4` |Values greater than *`1`* specify the message priority
when sending (where *`0`* is the lowest priority and *`9`* is the
highest). The *`explicitQosEnabled`* option _must_ also be enabled in
order for this option to have any effect.

|`pubSubNoLocal` |`false` |Specifies whether to inhibit the delivery of
messages published by its own connection.

|`receiveTimeout` |`1000` |The timeout for receiving messages (in
milliseconds).

|`recoveryInterval` |`5000` |Specifies the interval between recovery
attempts, e.g., when a connection is being refreshed, in milliseconds.
The default is `5000 ms`.

|`replyToSameDestinationAllowed` |`false` |*Camel 2.16:* *Consumer
only:* Whether a JMS consumer is allowed to send a reply message to the
same destination that the consumer is using to consume from. This
prevents an endless loop by consuming and sending back the same message
to itself.

|`replyToCacheLevelName` |`CACHE_CONSUMER` a|
*Camel 2.9.1:* Sets the cache level by name for the reply consumer when
doing request/reply over JMS. This option only applies when using fixed
reply queues (not temporary). Camel will by default use:
*`CACHE_CONSUMER`* for exclusive or shared w/*`replyToSelectorName`* and
*`CACHE_SESSION`* for shared without *`replyToSelectorName`*. Some JMS
brokers such as IBM WebSphere may require this parameter to be set to
*`CACHE_NONE`* in order to work.

*Note:* The value *`CACHE_NONE`* cannot be used with temporary queues. A
higher value, such as *`CACHE_CONSUMER`* or *`CACHE_SESSION`*, must be
used.

|`replyToDestinationSelectorName` |`null` |Sets the JMS Selector using
the fixed name to be used so you can filter out your own replies from
the others when using a shared queue (that is, if you are not using a
temporary reply queue).

|`replyToDeliveryPersistent` |`true` |Specifies whether to use
persistent delivery by default for replies.

|`requestTimeoutCheckerInterval` |`1000` |*Camel 2.9.2:* Configures how
often Camel should check for timed out link:exchange.html[Exchange]s
when doing request/reply over JMS. By default Camel checks once per
second. But if you must react faster when a timeout occurs, then you can
lower this interval, to check more frequently. The timeout is determined
by the option *`requestTimeout`*.

|`subscriptionDurable` |`false` |*@deprecated:* Enabled by default, if
you specify a *`durableSubscriptionName`* and a *`clientId`*.

|`taskExecutor` |`null` |Allows you to specify a custom task executor
for consuming messages.

|`taskExecutorSpring2` |`null` |*Camel 2.6:* To use when using Spring
2.x with Camel. Allows you to specify a custom task executor for
consuming messages.

|`templateConnectionFactory` |`null` |The JMS connection factory used
for sending messages.

|`transactedInOut` |`false` |*@deprecated:* Specifies whether to use
transacted mode for sending messages using the *`InOut`*
link:exchange-pattern.html[Exchange Pattern]. Applies only to producer
endpoints. See section link:jms.html[Enabling Transacted Consumption]
for more details.

|`transactionManager` |`null` |The Spring transaction manager to use.

|`transactionName` |`"JmsConsumer[destinationName]"` |The name of the
transaction to use.

|`transactionTimeout` |`null` |The timeout value of the transaction (in
seconds), if using transacted mode.

|`transferException` |`false` |If enabled and you are using
link:request-reply.html[Request Reply] messaging (*`InOut`*) and an
link:exchange.html[Exchange] failed on the consumer side, then the
caused *`Exception`* will be send back in response as a
*`javax.jms.ObjectMessage`*. If the client is Camel, the returned
*`Exception`* is re-thrown. This allows you to use Camel
link:jms.html[JMS] as a bridge in your routing - for example, using
persistent queues to enable robust routing. Notice that if you also have
*`transferExchange`* enabled, this option takes precedence. The caught
exception is required to be serializable. The original *`Exception`* on
the consumer side can be wrapped in an outer exception such as
*`org.apache.camel.RuntimeCamelException`* when returned to the
producer.

|`transferExchange` |`false` a|
You can transfer the exchange over the wire instead of just the body and
headers. The following fields are transferred: In body, Out body, Fault
body, In headers, Out headers, Fault headers, exchange properties,
exchange exception. This requires that the objects are serializable.
Camel will exclude any non-serializable objects and log it at *`WARN`*
level.

You _must_ enable this option on _both_ the producer _and_ the consumer
side, so Camel will know that the payload is an Exchange and not a
regular payload.

|`transferFault` |`false` a|
*Camel 2.17:* If enabled and you are using Request Reply messaging
(*`InOut`*) and an Exchange failed with a SOAP fault (not exception) on
the consumer side, then the fault flag
on *`org.apache.camel.Message.isFault()`* will be send back in the
response as a JMS header with the key
*`JmsConstants.JMS_TRANSFER_FAULT`*. If the client is Camel, the
returned fault flag will be set on the
*`org.apache.camel.Message.setFault(boolean)`*.

You may want to enable this when using Camel components that support
faults such as SOAP based such as CXF or spring-ws.

|`username` |`null` |The username for the connector factory.

|`useMessageIDAsCorrelationID` |`false` |Specifies whether
*`JMSMessageID`* should always be used as *`JMSCorrelationID`*
for *`InOut`* messages.

|`useVersion102` |`false` |*@deprecated (removed from Camel 2.5 onward)*
Specifies whether the old JMS API should be used.
|=======================================================================

[[BookComponentAppendix-MessageMappingBetweenJMSandCamel]]
Message Mapping Between JMS and Camel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel automatically maps messages between *`javax.jms.Message`* and
*`org.apache.camel.Message`*. When sending a JMS message, Camel converts
the message body to the following JMS message types:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Body Type |JMS Message |Comment
|`byte[]` |`javax.jms.BytesMessage` | 

|`java.io.File` |`javax.jms.BytesMessage` | 

|`java.io.InputStream` |`javax.jms.BytesMessage` | 

|`java.io.Reader` |`javax.jms.BytesMessage` | 

|`java.io.Serializable` |`javax.jms.ObjectMessage` | 

|`java.nio.ByteBuffer` |`javax.jms.BytesMessage` | 

|`Map` |`javax.jms.MapMessage` | 

|`org.w3c.dom.Node` |`javax.jms.TextMessage` |The DOM will be converted
to *`String`*.

|`String` |`javax.jms.TextMessage` | 
|=======================================================================

When receiving a JMS message, Camel converts the JMS message to the
following body type:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=============================================
|JMS Message |Body Type
|`javax.jms.BytesMessage` |`byte[]`
|`javax.jms.MapMessage` |`Map<String, Object>`
|`javax.jms.ObjectMessage` |`Object`
|`javax.jms.TextMessage` |`String`
|=============================================

[[BookComponentAppendix-DisablingAuto-MappingofJMSMessages]]
Disabling Auto-Mapping of JMS Messages
++++++++++++++++++++++++++++++++++++++

You can use the *`mapJmsMessage`* option to disable the auto-mapping
above. If disabled, Camel will not try to map the received JMS message,
but instead uses it directly as the payload. This allows you to avoid
the overhead of mapping and let Camel just pass through the JMS message.
For instance, it even allows you to route *`javax.jms.ObjectMessage`*
JMS messages with classes you do *not* have on the classpath.

[[BookComponentAppendix-UsingacustomMessageConverter]]
Using a custom MessageConverter
+++++++++++++++++++++++++++++++

You can use the *`messageConverter`* option to do the mapping yourself
in a Spring
*`org.springframework.jms.support.converter.MessageConverter`* class.

For example, in the route below we use a custom message converter when
sending a message to the JMS order queue:

javafrom("file://inbox/order")
.to("jms:queue:order?messageConverter=#myMessageConverter");

You can also use a custom message converter when consuming from a JMS
destination.

[[BookComponentAppendix-ControllingtheMappingStrategySelected]]
Controlling the Mapping Strategy Selected
+++++++++++++++++++++++++++++++++++++++++

You can use the *`jmsMessageType`* option on the endpoint URL to force a
specific message type for all messages. In the route below, we poll
files from a folder and send them as *`javax.jms.TextMessage`* as we
have forced the JMS producer endpoint to use text messages:

javafrom("file://inbox/order")
.to("jms:queue:order?jmsMessageType=Text");

You can also specify the message type to use for each message by setting
the header with the key *`CamelJmsMessageType`*. For example:

javafrom("file://inbox/order") .setHeader("CamelJmsMessageType",
JmsMessageType.Text) .to("jms:queue:order");

The possible values are defined in the `enum` class
*`org.apache.camel.jms.JmsMessageType`*.

[[BookComponentAppendix-MessageFormatWhenSending]]
Message Format When Sending
^^^^^^^^^^^^^^^^^^^^^^^^^^^

An exchange sent via JMS must conform to the
http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html[JMS Message
spec]. Camel therefore applies various translation and validation rules
to both key names and key values of *`exchange.in.headers`*.

The following rules are applied to the _key names_
of *`exchange.in.headers`*:

* Keys starting with *`JMS`* or *`JMSX`* are reserved.
* Key names must be literals or valid Java identifiers.
* Dot and hyphen characters are replaced (and the reverse when
consuming) as follows:
** The character `'.'` is replaced with the sequence *`_DOT_`*. The
reverse replacement is applied when Camel consumes a message. 
** The character `'-'` is replaced with the sequence *`_HYPHEN_`*. The
reverse replacement is applied when Camel consumes a message.
* The option *`jmsKeyFormatStrategy`* can be used to specify a custom
key formatting strategy.

The following rules are applied to the _key values_ of
*`exchange.in.headers`*:

* Values must be either a primitive type or of its corresponding Java
object type, e.g., *`Integer`*, *`Long`* or *`Character`*.
* The types *`String`, `CharSequence`*, *`Date`, `BigDecimal`*
and *`BigInteger`* are all converted to their string representation.
* All other types will result in the key value being discarded.

If a header value is discarded Camel will log the incident using logging
category *`org.apache.camel.component.jms.JmsBinding`* at the *`DEBUG`*
logging level. For example:

text2008-07-09 06:43:04,046 [main ] DEBUG JmsBinding - Ignoring non
primitive header: order of class:
org.apache.camel.component.jms.issues.DummyOrder with value:
DummyOrder\{orderId=333, itemId=4444, quantity=2}

[[BookComponentAppendix-MessageFormatWhenReceiving]]
Message Format When Receiving
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel adds the following properties to the *`Exchange`* when it receives
a message:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Property |Type |Description
|`org.apache.camel.jms.replyDestination` |`javax.jms.Destination` |The
reply destination.
|=======================================================================

Camel adds the following JMS properties to the In message headers when
it receives a JMS message:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`JMSCorrelationID` |`String` |The JMS correlation ID.

|`JMSDeliveryMode` |`int` |The JMS delivery mode.

|`JMSDestination` |`javax.jms.Destination` |The JMS destination.

|`JMSExpiration` |`long` |The JMS expiration.

|`JMSMessageID` |`String` |The JMS unique message ID.

|`JMSPriority` |`int` |The JMS priority (with 0 as the lowest priority
and 9 as the highest).

|`JMSRedelivered` |`boolean` |Is the JMS message redelivered.

|`JMSReplyTo` |`javax.jms.Destination` |The JMS reply-to destination.

|`JMSTimestamp` |`long` |The JMS timestamp.

|`JMSType` |`String` |The JMS type.

|`JMSXGroupID` |`String` |The JMS group ID.
|=======================================================================

As all the above information is standard JMS you can check the
http://java.sun.com/javaee/5/docs/api/javax/jms/Message.html[JMS
documentation] for further details.

[[BookComponentAppendix-UsingCameltoSendandReceiveMessagesUsingJMSReplyTo]]
Using Camel to Send and Receive Messages Using `JMSReplyTo`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The JMS component is complex and you have to pay close attention to how
it works in some cases. So this is a short summary of some of the
areas/pitfalls to look for.

When Camel sends a message using its *`JMSProducer`* it checks the
following conditions:

* The message http://camel.apache.org/exchange-pattern.html[Exchange
Pattern] (MEP)
* Whether a *`JMSReplyTo`* was set in the endpoint or in the message
headers
* Whether any of the following options have been set on the JMS
endpoint: *`disableReplyTo`, `preserveMessageQos`* or
*`explicitQosEnabled`.*

All this can be a tad complex to understand and configure to support
your use case.

[[BookComponentAppendix-JmsProducer]]
JmsProducer
+++++++++++

The *`JmsProducer`* behaves as follows, depending on configuration:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Exchange Pattern |Other options |Description
|`InOut` |`-` |Camel will expect a reply, set a temporary
*`JMSReplyTo`*, and after sending the message, it will start to listen
for the reply message on the temporary queue.

|`InOut` |`JMSReplyTo` is set |Camel will expect a reply and, after
sending the message, it will start to listen for the reply message on
the specified *`JMSReplyTo`* queue.

|`InOnly` |`-` |Camel will send the message and *not* expect a reply.

|`InOnly` |`JMSReplyTo` is set a|
By default, Camel discards the *`JMSReplyTo`* destination and clears the
*`JMSReplyTo`* header before sending the message. Camel then sends the
message and does _not_ expect a reply. Camel logs this in the log at
*`WARN`* level (changed to *`DEBUG`* level from *Camel 2.6* on). You can
use *`preserveMessageQuo=true`* to instruct Camel to keep the
*`JMSReplyTo`*.

In all situations the *`JmsProducer`* does *not* expect any reply and
thus continue after sending the message.

|=======================================================================

[[BookComponentAppendix-JmsConsumer]]
JmsConsumer
+++++++++++

The `JmsConsumer` behaves as follows, depending on configuration:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Exchange Pattern |Other options |Description
|`InOut` |`-` |Camel will send the reply back to the *`JMSReplyTo`*
queue.

|`InOnly` |`-` |Camel will not send a reply back, as the pattern is
*`InOnly`*.

|`-` |`disableReplyTo=true` |This option suppresses replies.
|=======================================================================

So pay attention to the message exchange pattern set on your exchanges.

If you send a message to a JMS destination in the middle of your route
you can specify the exchange pattern to use, see more at
link:request-reply.html[Request Reply]. This is useful if you want to
send an *`InOnly`* message to a JMS topic:

javafrom("activemq:queue:in") .to("bean:validateOrder")
.to(ExchangePattern.InOnly, "activemq:topic:order")
.to("bean:handleOrder");

[[BookComponentAppendix-ComputingtheDestinationatRuntime]]
Computing the Destination at Runtime
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you need to send messages to a lot of different JMS destinations, it
makes sense to reuse a JMS endpoint and specify the real destination in
a message header. This allows Camel to reuse the same endpoint, but send
to different destinations. This greatly reduces the number of endpoints
created and economizes on memory and thread resources.

You can specify the destination in the following headers:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=====================================================================
|Header |Type |Description
|`CamelJmsDestination` |`javax.jms.Destination` |A destination object.
|`CamelJmsDestinationName` |`String` |The destination name.
|=====================================================================

For example, the following route shows how you can compute a destination
at run time and use it to override the destination appearing in the JMS
URL:

javafrom("file://inbox") .to("bean:computeDestination")
.to("activemq:queue:dummy");

The queue name, `dummy`, is just a placeholder. It must be provided as
part of the JMS endpoint URL, but it will be ignored in this example.

In the *`computeDestination`* bean, specify the real destination by
setting the *`CamelJmsDestinationName`* header as follows:

javapublic void setJmsHeader(Exchange exchange) \{ String id = ....
exchange.getIn().setHeader("CamelJmsDestinationName", "order:" + id"); }

Then Camel will read this header and use it as the destination instead
of the one configured on the endpoint. So, in this example Camel sends
the message to *`activemq:queue:order:2`*, assuming the *`id`* value was
*`2`*.

If both the `CamelJmsDestination` and the *`CamelJmsDestinationName`*
headers are set *`CamelJmsDestination`* will take priority. Note that
the JMS producer removes both *`CamelJmsDestination`* and
*`CamelJmsDestinationName`* headers from the exchange and does not
propagate them to the created JMS message. This prevents accidental
routing loops in scenarios where a message is forwarded to another JMS
endpoint.

[[BookComponentAppendix-ConfiguringDifferentJMSProviders]]
Configuring Different JMS Providers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A JMS provider can be configured in link:spring.html[Spring] XML as
follows:\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-jms/src/test/resources/org/apache/camel/component/jms/jmsRouteUsingSpring.xml} 

An unlimited number of JMS component instance can be created provided
each has a __unique value for its** **__**`id`** _attribute. The
preceding example configures an activemq component. You could do the
same to configure MQSeries, TibCo, BEA, Sonic etc._

Once named a JMS component can be referenced from an endpoint's URI. For
example, given the component name `activemq` a URI can reference the
component using the format *`activemq:[queue:|topic:]destinationName`*.
The same approach applies to all JMS providers. This is achieved by
the *`SpringCamelContext`* lazily fetching components from the spring
context for the scheme name referenced in the
link:endpoint.html[Endpoint] link:uris.html[URIs] then having the
link:component.html[Component] resolve the endpoint URI itself.

[[BookComponentAppendix-UsingJNDItoFindtheConnectionFactory]]
Using JNDI to Find the Connection Factory
+++++++++++++++++++++++++++++++++++++++++

If you are using a J2EE container, you might need to look up JNDI to
find the JMS *`connectionFactory`* rather than use the usual *`<bean>`*
mechanism in Spring. You can do this using Spring's factory bean or the
new Spring XML namespace. For example:

xml<bean id="weblogic"
class="org.apache.camel.component.jms.JmsComponent"> <property
name="connectionFactory" ref="myConnectionFactory"/> </bean>
<jee:jndi-lookup id="myConnectionFactory"
jndi-name="jms/connectionFactory"/>

See
http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/xsd-config.html#xsd-config-body-schemas-jee[The
jee schema] in the Spring reference documentation for more details about
JNDI lookup.

[[BookComponentAppendix-ConcurrentConsuming]]
Concurrent Consuming
^^^^^^^^^^^^^^^^^^^^

A common requirement with JMS is to consume messages concurrently in
multiple threads in order to make an application more responsive. You
can set the *`concurrentConsumers`* option to specify the number of
threads servicing the JMS endpoint, as follows:

javafrom("jms:SomeQueue?concurrentConsumers=20") .bean(MyClass.class);

You can configure this option in one of the following ways:

* On the *`JmsComponent`*
* On the endpoint URI
* By invoking *`setConcurrentConsumers()`* directly on the
*`JmsEndpoint`*.

[[BookComponentAppendix-ConcurrentConsumingwithasyncConsumer]]
Concurrent Consuming with `asyncConsumer`
+++++++++++++++++++++++++++++++++++++++++

Notice that each concurrent consumer will only pickup the next available
message from the JMS broker, when the current message has been fully
processed. You can set the option *`asyncConsumer=true`* to let the
consumer pickup the next message from the JMS queue, while the previous
message is being processed asynchronously (by the
link:asynchronous-routing-engine.html[Asynchronous Routing Engine]). See
more details in the table on top of the page about the *`asyncConsumer`*
option.

javafrom("jms:SomeQueue?concurrentConsumers=20&asyncConsumer=true")
.bean(MyClass.class);

[[BookComponentAppendix-Request-ReplyoverJMS]]
Request-Reply over JMS
^^^^^^^^^^^^^^^^^^^^^^

Camel supports link:request-reply.html[Request Reply] over JMS. In
essence the MEP of the Exchange should be *`InOut`* when you send a
message to a JMS queue.

Camel offers a number of options to configure request/reply over JMS
that influence performance and clustered environments. The table below
summaries the options.

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |Performance |Cluster |Description
|`Temporary` |Fast |Yes |A temporary queue is used as reply queue, and
automatic created by Camel. To use this do *not* specify a *`replyTo`*
queue name. And you can optionally configure *`replyToType=Temporary`*
to make it stand out that temporary queues are in use.

|`Shared` |Slow |Yes |A shared persistent queue is used as reply queue.
The queue must be created beforehand, although some brokers can create
them on the fly such as Apache ActiveMQ. To use this you must specify
the *`replyTo`* queue name. And you can optionally configure
*`replyToType=Shared`* to make it stand out that shared queues are in
use. A shared queue can be used in a clustered environment with multiple
nodes running this Camel application at the same time. All using the
same shared reply queue. This is possible because JMS Message selectors
are used to correlate expected reply messages; this impacts performance
though. JMS Message selectors is slower, and therefore not as fast as
*`Temporary`* or *`Exclusive`* queues. See further below how to tweak
this for better performance.

|`Exclusive` |Fast |No (*Yes) |An exclusive persistent queue is used as
reply queue. The queue must be created beforehand, although some brokers
can create them on the fly such as Apache ActiveMQ. To use this you must
specify the replyTo queue name. And you *must* configure
*`replyToType=Exclusive`* to instruct Camel to use exclusive queues, as
`Shared` is used by default, if a *`replyTo`* queue name was configured.
When using exclusive reply queues, then JMS Message selectors are *not*
in use, and therefore other applications must not use this queue as
well. An exclusive queue *cannot* be used in a clustered environment
with multiple nodes running this Camel application at the same time; as
we do not have control if the reply queue comes back to the same node
that sent the request message; that is why shared queues use JMS Message
selectors to make sure of this. *Though* if you configure each Exclusive
reply queue with an unique name per node, then you can run this in a
clustered environment. As then the reply message will be sent back to
that queue for the given node, that awaits the reply message.

|`concurrentConsumers` |Fast |Yes a|
*Camel 2.10.3:* Allows to process reply messages concurrently using
concurrent message listeners in use. You can specify a range using the
*`concurrentConsumers`* and *`maxConcurrentConsumers`* options.

*Note:* That using `Shared` reply queues may not work as well with
concurrent listeners, so use this option with care.

|`maxConcurrentConsumers` |Fast |Yes a|
*Camel 2.10.3:* Allows to process reply messages concurrently using
concurrent message listeners in use. You can specify a range using the
*`concurrentConsumers`* and *`maxConcurrentConsumers`* options.

*Note:* That using `Shared` reply queues may not work as well with
concurrent listeners, so use this option with care.

|=======================================================================

The *`JmsProducer`* detects the *`InOut`* and provides a *`JMSReplyTo`*
header with the reply destination to be used. By default Camel uses a
temporary queue, but you can use the *`replyTo`* option on the endpoint
to specify a fixed reply queue (see more below about fixed reply queue).

Camel will automatic setup a consumer which listen on the reply queue,
so you should *not* do anything. This consumer is a Spring
*`DefaultMessageListenerContainer`* which listen for replies. However
it's fixed to *`1`* concurrent consumer. That means replies will be
processed in sequence as there are only 1 thread to process the replies.
If you want to process replies faster, then we need to use concurrency.
But *not* using the *`concurrentConsumer`* option. We should use the
`threads` from the Camel DSL instead, as shown in the route below:

Instead of using threads, then use *`concurrentConsumers`* option if
using Camel 2.10.3 or greater. See below for details.

javafrom(xxx) .inOut().to("activemq:queue:foo") .threads(5) .to(yyy)
.to(zzz);

In this route we instruct Camel to route replies
link:async.html[asynchronously] using a thread pool with 5 threads.

From *Camel 2.10.3*: you can now configure the listener to use
concurrent threads using the *`concurrentConsumers`* and
*`maxConcurrentConsumers`* options. This allows you to easier configure
this in Camel as shown below:

javafrom(xxx) .inOut().to("activemq:queue:foo?concurrentConsumers=5")
.to(yyy) .to(zzz);

[[BookComponentAppendix-Request-ReplyoverJMSUsingaSharedFixedReplyQueue]]
Request-Reply over JMS Using a Shared Fixed Reply Queue
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

If you use a fixed reply queue when doing
link:request-reply.html[Request Reply] over JMS as shown in the example
below, then pay attention.

from(xxx) .inOut().to("activemq:queue:foo?replyTo=bar") .to(yyy);

In this example the fixed reply queue named "bar" is used. By default
Camel assumes the queue is shared when using fixed reply queues, and
therefore it uses a *`JMSSelector`* to only pickup the expected reply
messages (eg based on the *`JMSCorrelationID`*). See next section for
exclusive fixed reply queues. That means its not as fast as temporary
queues. You can speedup how often Camel will pull for reply messages
using the *`receiveTimeout`* option. By default its *`1000ms`*. So to
make it faster you can set it to *`250ms`* to pull *`4`* times per
second as shown:

javafrom(xxx)
.inOut().to("activemq:queue:foo?replyTo=bar&receiveTimeout=250")
.to(yyy);

Notice this will cause the Camel to send pull requests to the message
broker more frequent, and thus require more network traffic. It's
generally recommended that temporary queues be used where possible.

[[BookComponentAppendix-Request-ReplyoverJMSUsinganExclusiveFixedReplyQueue]]
Request-Reply over JMS Using an Exclusive Fixed Reply Queue
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.9*

In the previous example, Camel would anticipate the fixed reply queue
named `bar` was shared, and thus it uses a *`JMSSelector`* to only
consume reply messages which it expects. However there is a drawback
doing this as JMS selectos is slower. Also the consumer on the reply
queue is slower to update with new JMS selector ids. In fact it only
updates when the *`receiveTimeout`* option times out, which by default
is `1` second. So in theory the reply messages could take up till
about `1` sec to be detected. On the other hand if the fixed reply queue
is exclusive to the Camel reply consumer, then we can avoid using the
JMS selectors, and thus be more performant. In fact as fast as using
temporary queues. So in *Camel 2.9* onward we introduced the
*`ReplyToType`* option which you can configure to *`Exclusive`* to tell
Camel that the reply queue is exclusive as shown in the example below:

javafrom(xxx)
.inOut().to("activemq:queue:foo?replyTo=bar&replyToType=Exclusive")
.to(yyy);

Mind that the queue must be exclusive to each and every endpoint. So if
you have two routes, then they each need an unique reply queue as shown
in the next example:

javafrom(xxx)
.inOut().to("activemq:queue:foo?replyTo=bar&replyToType=Exclusive")
.to(yyy); from(aaa)
.inOut().to("activemq:queue:order?replyTo=order.reply&replyToType=Exclusive")
.to(bbb);

The same applies if you run in a clustered environment. Then each node
in the cluster must use an unique reply queue name. As otherwise each
node in the cluster may pickup messages which was intended as a reply on
another node. For clustered environments its recommended to use shared
reply queues instead.

[[BookComponentAppendix-SynchronizingClocksBetweenSendersandReceivers]]
Synchronizing Clocks Between Senders and Receivers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When doing messaging between systems, its desirable that the systems
have synchronized clocks. For example when sending a link:jms.html[JMS]
message, then you can set a time to live value on the message. Then the
receiver can inspect this value, and determine if the message is already
expired, and thus drop the message instead of consume and process it.
However this requires that both sender and receiver have synchronized
clocks. If you are using http://activemq.apache.org/[ActiveMQ] then you
can use the http://activemq.apache.org/timestampplugin.html[timestamp
plugin] to synchronize clocks.

[[BookComponentAppendix-AboutTimeToLive]]
About Time To Live
^^^^^^^^^^^^^^^^^^

Read first above about synchronized clocks.

When you do request/reply, *`InOut`*, over link:jms.html[JMS] Camel uses
a timeout on the sender side, which is default 20 seconds, taken from
the *`requestTimeout`* option. You can control this by setting a
higher/lower value. However, the time to live value is still set on the
link:jms.html[JMS] message being sent. This therefore requires that
system clocks be synchronized between the systems. If they are not, then
you may want to disable the time to live value being set. This is now
possible using the *`disableTimeToLive`* option from *Camel 2.8* onward.
So if you set this option to *`disableTimeToLive=true`*, then Camel does
*not* set any time to live value when sending link:jms.html[JMS]
messages. *But* the request timeout is still active. So for example if
you do request/reply over link:jms.html[JMS] and have disabled time to
live, then Camel will still use a timeout by 20 seconds (the
*`requestTimeout`* option). That option can of course also be
configured. So the two options *`requestTimeout`* and
*`disableTimeToLive`* gives you fine grained control when doing
request/reply.

From *Camel 2.13/2.12.3*: you can provide a header in the message to
override and use as the request timeout value instead of the endpoint
configured value. For example:

javafrom("direct:someWhere")
.to("jms:queue:foo?replyTo=bar&requestTimeout=30s")
.to("bean:processReply");

In the route above we have a endpoint configured *`requestTimeout`* of
30 seconds. So Camel will wait up till 30 seconds for that reply message
to come back on the bar queue. If no reply message is received then a
*`org.apache.camel.ExchangeTimedOutException`* is set on the
link:exchange.html[Exchange] and Camel continues routing the message,
which would then fail due the exception, and Camel's error handler
reacts.

If you want to use a per message timeout value, you can set the header
with key
*`org.apache.camel.component.jms.JmsConstants#JMS_REQUEST_TIMEOUT`*
which has constant value *`CamelJmsRequestTimeout`* with a timeout value
as long type.

For example we can use a bean to compute the timeout value per
individual message, such as calling the `"whatIsTheTimeout"` method on
the service bean as shown below:

javafrom("direct:someWhere") .setHeader("CamelJmsRequestTimeout",
method(ServiceBean.class, "whatIsTheTimeout"))
.to("jms:queue:foo?replyTo=bar&requestTimeout=30s")
.to("bean:processReply");

When you do fire and forget (*`InOut`*) over link:jms.html[JMS] Camel
will, by default, *not* set a time to live value on the message. The
value can be configured using the *`timeToLive`* option. For example to
indicate a 5 sec., you set *`timeToLive=5000`*. The option
*`disableTimeToLive`* can be used to force disabling the time to live,
also for *`InOnly`* messaging. The *`requestTimeout`* option is not
being used for *`InOnly`* messaging.

[[BookComponentAppendix-EnablingTransactedConsumption]]
Enabling Transacted Consumption
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

transactedConsumption

A common requirement is to consume from a queue in a transaction and
then process the message using the Camel route. To do this, just ensure
that you set the following properties on the component/endpoint:

* `transacted = true`
* `transactionManager =` _<SomeTransactionManager>_ (typically the
JmsTransactionManager)

See the link:transactional-client.html[Transactional Client] EIP pattern
for further details.

Transactions and [Request Reply] over JMS

When using link:request-reply.html[Request Reply] over JMS you cannot
use a single transaction; JMS will not send any messages until a commit
is performed, so the server side won't receive anything at all until the
transaction commits. Therefore to use link:request-reply.html[Request
Reply] you must commit a transaction after sending the request and then
use a separate transaction for receiving the response.

To address this issue the JMS component uses different properties to
specify transaction use for oneway messaging and request reply
messaging:

* The *`transacted`* property applies *only* to the *`InOnly`* message
link:exchange-pattern.html[Exchange Pattern] (MEP).
* The *`transactedInOut`* property applies to the *`InOut`*
(link:request-reply.html[Request Reply]) message
link:exchange-pattern.html[Exchange Pattern] (MEP). If you want to use
transactions with the *`InOut`* (link:request-reply.html[Request Reply])
message link:exchange-pattern.html[Exchange Pattern] (MEP), you _must_
set *`transactedInOut=true`*.

*Available as of Camel 2.10*

You can leverage the
http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jms/listener/AbstractPollingMessageListenerContainer.html#setSessionTransacted(boolean)[DMLC
transacted session API] using the following properties on
component/endpoint:

* `transacted = true`
* `lazyCreateTransactionManager = false`

The benefit of doing so is that the `cacheLevel` setting will be honored
when using local transactions without a configured TransactionManager.
When a TransactionManager is configured, no caching happens at DMLC
level and its necessary to rely on a pooled connection factory. For more
details about this kind of setup see
http://tmielke.blogspot.com/2012/03/camel-jms-with-transactions-lessons.html[here]
and
http://forum.springsource.org/showthread.php?123631-JMS-DMLC-not-caching%20connection-when-using-TX-despite-cacheLevel-CACHE_CONSUMER&p=403530&posted=1#post403530[here].

[[BookComponentAppendix-UsingJMSReplyToForLateReplies]]
Using `JMSReplyTo` For Late Replies
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When using Camel as a JMS listener, it sets an Exchange property with
the value of the ReplyTo *`javax.jms.Destination`* object, having the
key *`ReplyTo`*. You can obtain this *`Destination`* as follows:

javaDestination replyDestination =
exchange.getIn().getHeader(JmsConstants.JMS_REPLY_DESTINATION,
Destination.class);

And then later use it to send a reply using regular JMS or Camel.

java// We need to pass in the JMS component (this example uses
ActiveMQ): JmsEndpoint endpoint =
JmsEndpoint.newInstance(replyDestination, activeMQComponent); // Now
that we have the endpoint we can use regular Camel API to send a message
to it template.sendBody(endpoint, "Here is the late reply.");

A different solution to sending a reply is to provide the
*`replyDestination`* object in the same Exchange property when sending.
Camel will then pick up this property and use it for the real
destination. The endpoint URI must include a dummy destination, however.

Example:

java// we pretend to send it to some non existing dummy queue
template.send("activemq:queue:dummy, new Processor() \{ public void
process(Exchange exchange) throws Exception \{ // and here we override
the destination with the ReplyTo destination object so the message is
sent to there instead of dummy
exchange.getIn().setHeader(JmsConstants.JMS_DESTINATION,
replyDestination); exchange.getIn().setBody("Here is the late reply.");
} }

[[BookComponentAppendix-UsingaRequestTimeout]]
Using a Request Timeout
^^^^^^^^^^^^^^^^^^^^^^^

In the sample below we send a link:request-reply.html[Request Reply]
style message link:exchange.html[Exchange] (we use the *`requestBody`*
method = *`InOut`*) to the slow queue for further processing in Camel
and we wait for a return
reply:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsRouteTimeoutTest.java}

[[BookComponentAppendix-Examples.10]]
Examples
^^^^^^^^

JMS is used in many examples for other components as well. But we
provide a few samples below to get started.

[[BookComponentAppendix-ReceivingfromJMS]]
Receiving from JMS
++++++++++++++++++

In the following sample we configure a route that receives JMS messages
and routes the message to a POJO:

java from("jms:queue:foo") .to("bean:myBusinessLogic");

You can of course use any of the EIP patterns so the route can be
context based. For example, here's how to filter an order topic for the
big spenders:

javafrom("jms:topic:OrdersTopic") .filter().method("myBean",
"isGoldCustomer") .to("jms:queue:BigSpendersQueue");

[[BookComponentAppendix-SendingtoJMS]]
Sending to JMS
++++++++++++++

In the sample below we poll a file folder and send the file content to a
JMS topic. As we want the content of the file as a *`TextMessage`*
instead of a *`BytesMessage`*, we need to convert the body to a
*`String`*:

javafrom("file://orders") .convertBodyTo(String.class)
.to("jms:topic:OrdersTopic");

[[BookComponentAppendix-UsingAnnotations]]
Using link:bean-integration.html[Annotations]
+++++++++++++++++++++++++++++++++++++++++++++

Camel also has annotations so you can use link:pojo-consuming.html[POJO
Consuming] and link:pojo-producing.html[POJO Producing].

[[BookComponentAppendix-SpringDSLExample]]
Spring DSL Example
++++++++++++++++++

The preceding examples use the Java DSL. Camel also supports Spring XML
DSL. Here is the big spender sample using Spring DSL:

xml<route> <from uri="jms:topic:OrdersTopic"/> <filter> <method
bean="myBean" method="isGoldCustomer"/> <to
uri="jms:queue:BigSpendersQueue"/> </filter> </route>

[[BookComponentAppendix-OtherExamples]]
Other Examples
++++++++++++++

JMS appears in many of the examples for other components and EIP
patterns, as well in this Camel documentation. So feel free to browse
the documentation. If you have time, check out the this tutorial that
uses JMS but focuses on how well Spring Remoting and Camel works
together link:tutorial-jmsremoting.html[Tutorial-JmsRemoting].

[[BookComponentAppendix-UsingJMSasaDeadLetterQueueStoringExchange]]
Using JMS as a Dead Letter Queue Storing Exchange
+++++++++++++++++++++++++++++++++++++++++++++++++

Normally, when using link:jms.html[JMS] as the transport, it only
transfers the body and headers as the payload. If you want to use
link:jms.html[JMS] with a link:dead-letter-channel.html[Dead Letter
Channel], using a JMS queue as the Dead Letter Queue, then normally the
caused Exception is not stored in the JMS message. You can, however, use
the *`transferExchange`* option on the JMS dead letter queue to instruct
Camel to store the entire link:exchange.html[Exchange] in the queue as a
*`javax.jms.ObjectMessage`* that holds a
*`org.apache.camel.impl.DefaultExchangeHolder`*. This allows you to
consume from the Dead Letter Queue and retrieve the caused exception
from the Exchange property with the key *`Exchange.EXCEPTION_CAUGHT`*.

Example:

java// setup error handler to use JMS as queue and store the entire
Exchange
errorHandler(deadLetterChannel("jms:queue:dead?transferExchange=true"));

Then you can consume from the JMS queue and analyze the problem:

javafrom("jms:queue:dead") .to("bean:myErrorAnalyzer"); // and in our
bean String body = exchange.getIn().getBody(); Exception cause =
exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class); // The
cause message is String problem = cause.getMessage();

[[BookComponentAppendix-UsingJMSasaDeadLetterChannelforStoringErrorOnly]]
Using JMS as a Dead Letter Channel for Storing Error Only
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

You can use JMS to store the cause error message or to store a custom
body, which you can initialize yourself. The following example uses the
link:message-translator.html[Message Translator] EIP to do a
transformation on the failed exchange before it is moved to the
link:jms.html[JMS] dead letter queue:

java// We sent it to a seda dead queue first
errorHandler(deadLetterChannel("seda:dead")); // On the seda dead queue
we can do the custom transformation before its sent to the JMS queue
from("seda:dead") .transform(exceptionMessage()) .to("jms:queue:dead");

Here we only store the original cause error message in the transform.
You can, however, use any link:expression.html[Expression] to send
whatever you like. For example, you can invoke a method on a Bean or use
a custom processor.

[[BookComponentAppendix-SendinganInOnlyMessageandKeepingtheJMSReplyToHeader]]
Sending an `InOnly` Message and Keeping the `JMSReplyTo` Header
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When sending to a link:jms.html[JMS] destination using *camel-jms* the
producer will use the MEP to detect if it's *`InOnly`* or *`InOut`*
messaging. However, there can be times where you want to send
an *`InOnly`* message but keeping the *`JMSReplyTo`* header. To do so
you have to instruct Camel to keep it, otherwise the *`JMSReplyTo`*
header will be dropped.

For example to send an *`InOnly`* message to the *`foo`* queue, but with
a *`JMSReplyTo`* with bar queue you can do as follows:

javatemplate.send("activemq:queue:foo?preserveMessageQos=true", new
Processor() \{ public void process(Exchange exchange) throws Exception
\{ exchange.getIn().setBody("World");
exchange.getIn().setHeader("JMSReplyTo", "bar"); } });

*Note*: we use *`preserveMessageQos=true`* to instruct Camel to keep
the *`JMSReplyTo`* header.

[[BookComponentAppendix-SettingJMSProviderOptionsontheDestination]]
Setting JMS Provider Options on the Destination
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some JMS providers, like IBM's WebSphere MQ need options to be set on
the JMS destination. For example, you may need to specify
the *`targetClient`* option. Since targetClient is a WebSphere MQ option
and not a Camel URI option, you need to set that on the JMS destination
name like so:

java... .setHeader("CamelJmsDestinationName",
constant("queue:///MY_QUEUE?targetClient=1"))
.to("wmq:queue:MY_QUEUE?useMessageIDAsCorrelationID=true");

Some versions of Websphere MQ do not accept this option on the
destination name. The following exception is raised when this happens:

____________________________________________________________________________________________________________________________________________________
*`com.ibm.msg.client.jms.DetailedJMSException: JMSCC0005: The specified value 'MY_QUEUE?targetClient=1' is not allowed for 'XMSC_DESTINATION_NAME'`*
____________________________________________________________________________________________________________________________________________________

A workaround is to use a custom *`DestinationResolver`*:

javaJmsComponent wmq = new JmsComponent(connectionFactory);
wmq.setDestinationResolver(new DestinationResolver()\{ public
Destination resolveDestinationName(Session session, String
destinationName, boolean pubSubDomain) throws JMSException \{
MQQueueSession wmqSession = (MQQueueSession) session; return
wmqSession.createQueue("queue:///" + destinationName +
"?targetClient=1"); } });

link:endpoint-see-also.html[Endpoint See Also]

* link:transactional-client.html[Transactional Client]
* link:bean-integration.html[Bean Integration]
* link:tutorial-jmsremoting.html[Tutorial-JmsRemoting]
* http://activemq.apache.org/jmstemplate-gotchas.html[JMSTemplate
gotchas]

[[BookComponentAppendix-JMXComponent]]
JMX Component
~~~~~~~~~~~~~

*Available as of Camel 2.6*

[[BookComponentAppendix-StandardJMXConsumerConfiguration]]
Standard JMX Consumer Configuration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Component allows consumers to subscribe to an mbean's Notifications. The
component supports passing the Notification object directly through the
Exchange or serializing it to XML according to the schema provided
within this project. This is a consumer only component. Exceptions are
thrown if you attempt to create a producer for it.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml <dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jmx</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIFormat.5]]
URI Format
++++++++++

The component can connect to the local platform mbean server with the
following URI:

jmx://platform?options

A remote mbean server url can be provided following the initial JMX
scheme like so:

jmx:service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi?options

You can append query options to the URI in the following format,
?options=value&option2=value&...

[[BookComponentAppendix-URIOptions.6]]
URI Options
+++++++++++

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Property |Required |Default |Description
|format |  |xml |Format for the message body. Either "xml" or "raw". If
xml, the notification is serialized to xml. If raw, then the raw java
object is set as the body.

|user |  |  |Credentials for making a remote connection.

|password |  |  |Credentials for making a remote connection.

|objectDomain |yes |  |The domain for the mbean you're connecting to.

|objectName |  |  |The name key for the mbean you're connecting to. This
value is mutually exclusive with the object properties that get passed.
(see below)

|notificationFilter |  |  |Reference to a bean that implements the
`NotificationFilter`. The #ref syntax should be used to reference the
bean via the link:registry.html[Registry].

|handback |  |  |Value to handback to the listener when a notification
is received. This value will be put in the message header with the key
"jmx.handback"

|testConnectionOnStartup |  |true |*Camel 2.11* If true, the consumer
will throw an exception when unable to establish the JMX connection upon
startup. If false, the consumer will attempt to establish the JMX
connection every 'x' seconds until the connection is made – where 'x' is
the configured _reconnectDelay_.

|reconnectOnConnectionFailure |  |false |*Camel 2.11* If true, the
consumer will attempt to reconnect to the JMX server when any connection
failure occurs. The consumer will attempt to re-establish the JMX
connection every 'x' seconds until the connection is made-- where 'x' is
the configured _reconnectDelay_.

|reconnectDelay |  |10 seconds |*Camel 2.11* The number of seconds to
wait before retrying creation of the initial connection or before
reconnecting a lost connection.
|=======================================================================

[[BookComponentAppendix-ObjectNameConstruction]]
ObjectName Construction
+++++++++++++++++++++++

The URI must always have the objectDomain property. In addition, the URI
must contain either objectName or one or more properties that start with
"key."

[[BookComponentAppendix-DomainwithNameproperty]]
Domain with Name property
+++++++++++++++++++++++++

When the objectName property is provided, the following constructor is
used to build the ObjectName? for the mbean:

ObjectName(String domain, String key, String value)

The key value in the above will be "name" and the value will be the
value of the objectName property.

[[BookComponentAppendix-DomainwithHashtable]]
Domain with Hashtable
+++++++++++++++++++++

ObjectName(String domain, Hashtable<String,String> table)

The Hashtable is constructed by extracting properties that start with
"key." The properties will have the "key." prefixed stripped prior to
building the Hashtable. This allows the URI to contain a variable number
of properties to identify the mbean.

[[BookComponentAppendix-Example.4]]
Example
+++++++

\{snippet:id=e1|lang=java|url=camel/trunk/examples/camel-example-jmx/src/main/java/org/apache/camel/example/jmx/MyRouteBuilder.java}

http://camel.apache.org/jmx-component-example.html[Full example]

[[BookComponentAppendix-MonitorTypeConsumer]]
Monitor Type Consumer
^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.8* +
One popular use case for JMX is creating a monitor bean to monitor an
attribute on a deployed bean. This requires writing a few lines of Java
code to create the JMX monitor and deploy it. As shown below:

java CounterMonitor monitor = new CounterMonitor();
monitor.addObservedObject(makeObjectName("simpleBean"));
monitor.setObservedAttribute("MonitorNumber"); monitor.setNotify(true);
monitor.setInitThreshold(1); monitor.setGranularityPeriod(500);
registerBean(monitor, makeObjectName("counter")); monitor.start();

The 2.8 version introduces a new type of consumer that automatically
creates and registers a monitor bean for the specified objectName and
attribute. Additional endpoint attributes allow the user to specify the
attribute to monitor, type of monitor to create, and any other required
properties. The code snippet above is condensed into a set of endpoint
properties. The consumer uses these properties to create the
CounterMonitor, register it, and then subscribe to its changes. All of
the JMX monitor types are supported.

[[BookComponentAppendix-Example.5]]
Example
+++++++

java from("jmx:platform?objectDomain=myDomain&objectName=simpleBean&" +
"monitorType=counter&observedAttribute=MonitorNumber&initThreshold=1&" +
"granularityPeriod=500").to("mock:sink");

The example above will cause a new Monitor Bean to be created and
depoyed to the local mbean server that monitors the "MonitorNumber"
attribute on the "simpleBean." Additional types of monitor beans and
options are detailed below. The newly deployed monitor bean is
automatically undeployed when the consumer is stopped.

[[BookComponentAppendix-URIOptionsforMonitorType]]
URI Options for Monitor Type
++++++++++++++++++++++++++++

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|property |type |applies to |description
|monitorType |enum |all |one of counter, guage, string

|observedAttribute |string |all |the attribute being observed

|granualityPeriod |long |all |granularity period (in millis) for the
attribute being observed. As per JMX, default is 10 seconds

|initThreshold |number |counter |initial threshold value

|offset |number |counter |offset value

|modulus |number |counter |modulus value

|differenceMode |boolean |counter, gauge |true if difference should be
reported, false for actual value

|notifyHigh |boolean |gauge |high notification on/off switch

|notifyLow |boolean |gauge |low notification on/off switch

|highThreshold |number |gauge |threshold for reporting high notification

|lowThreshold |number |gauge |threshold for reporting low notificaton

|notifyDiffer |boolean |string |true to fire notification when string
differs

|notifyMatch |boolean |string |true to fire notification when string
matches

|stringToCompare |string |string |string to compare against the
attribute value
|=======================================================================

The monitor style consumer is only supported for the local mbean server.
JMX does not currently support remote deployment of mbeans without
either having the classes already remotely deployed or an adapter
library on both the client and server to facilitate a proxy deployment.

link:endpoint-see-also.html[Endpoint See Also]

* link:camel-jmx.html[Camel JMX]

[[BookComponentAppendix-JPAComponent]]
JPA Component
~~~~~~~~~~~~~

The *jpa* component enables you to store and retrieve Java objects from
persistent storage using EJB 3's Java Persistence Architecture (JPA),
which is a standard interface layer that wraps Object/Relational Mapping
(ORM) products such as OpenJPA, Hibernate, TopLink, and so on.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-jpa</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency>

Sending to the endpoint

You can store a Java entity bean in a database by sending it to a JPA
producer endpoint. The body of the _In_ message is assumed to be an
entity bean (that is, a POJO with an
http://java.sun.com/javaee/5/docs/api/javax/persistence/Entity.html[@Entity]
annotation on it) or a collection or array of entity beans.

If the body is a List of entities, make sure to use
*entityType=java.util.ArrayList* as a configuration passed to the
producer endpoint.

If the body does not contain one of the previous listed types, put a
link:message-translator.html[Message Translator] in front of the
endpoint to perform the necessary conversion first.

From *Camel 2.19* onwards you can use *query*, *namedQuery* and
**nativeQuery **option for the producer as well to retrieve a set of
entities or execute bulk update/delete.

[[BookComponentAppendix-Consumingfromtheendpoint.2]]
Consuming from the endpoint
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Consuming messages from a JPA consumer endpoint removes (or updates)
entity beans in the database. This allows you to use a database table as
a logical queue: consumers take messages from the queue and then
delete/update them to logically remove them from the queue.

If you do not wish to delete the entity bean when it has been processed
(and when routing is done), you can specify `consumeDelete=false` on the
URI. This will result in the entity being processed each poll.

If you would rather perform some update on the entity to mark it as
processed (such as to exclude it from a future query) then you can
annotate a method with
http://camel.apache.org/maven/current/camel-jpa/apidocs/org/apache/camel/component/jpa/Consumed.html[@Consumed]
which will be invoked on your entity bean when the entity bean when it
has been processed (and when routing is done).

From *Camel 2.13* onwards you can use
http://camel.apache.org/maven/current/camel-jpa/apidocs/org/apache/camel/component/jpa/PreConsumed.html[@PreConsumed]
which will be invoked on your entity bean before it has been processed
(before routing).

If you are consuming a lot (100K+) of rows and experience OutOfMemory
problems you should set the maximumResults to sensible value.

*Note:* Since *Camel 2.18*, JPA now includes a `JpaPollingConsumer`
implementation that better supports Content Enricher using
`pollEnrich()` to do an on-demand poll that returns either none, one or
a list of entities as the result.

 

[[BookComponentAppendix-URIformat.32]]
URI format
^^^^^^^^^^

jpa:entityClassName[?options]

For sending to the endpoint, the _entityClassName_ is optional. If
specified, it helps the link:type-converter.html[Type Converter] to
ensure the body is of the correct type.

For consuming, the _entityClassName_ is mandatory.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.28]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`entityType` |_entityClassName_ |Overrides the _entityClassName_ from
the URI.

|`persistenceUnit` |`camel` |The JPA persistence unit used by default.

|`consumeDelete` |`true` |*JPA consumer only:* If `true`, the entity is
deleted after it is consumed; if `false`, the entity is not deleted.

|`consumeLockEntity` |`true` |*JPA consumer only:* Specifies whether or
not to set an exclusive lock on each entity bean while processing the
results from polling.

|`flushOnSend` |`true` |*JPA producer only:* Flushes the
http://java.sun.com/javaee/5/docs/api/javax/persistence/EntityManager.html[EntityManager]
after the entity bean has been persisted.

|`maximumResults` |`-1` |*JPA consumer only:* Set the maximum number of
results to retrieve on the
http://java.sun.com/javaee/5/docs/api/javax/persistence/Query.html[Query].
**Camel 2.19:** it's also used for the producer when it executes a
query.

|`transactionManager` |`null` |This option is
link:registry.html[Registry] based which requires the `#` notation so
that the given `transactionManager` being specified can be looked up
properly, e.g. `transactionManager=#myTransactionManager`. It specifies
the transaction manager to use. If none provided, Camel will use a
`JpaTransactionManager` by default. Can be used to set a JTA transaction
manager (for integration with an EJB container).

|`consumer.delay` |`500` |*JPA consumer only:* Delay in milliseconds
between each poll.

|`consumer.initialDelay` |`1000` |*JPA consumer only:* Milliseconds
before polling starts.

|`consumer.useFixedDelay` |`false` |*JPA consumer only:* Set to `true`
to use fixed delay between polls, otherwise fixed rate is used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.

|`maxMessagesPerPoll` |`0` |*JPA consumer only:* An integer value to
define the maximum number of messages to gather per poll. By default, no
maximum is set. Can be used to avoid polling many thousands of messages
when starting up the server. Set a value of 0 or negative to disable.

|`consumer.query` |  |*JPA consumer only:* To use a custom query when
consuming data.

|`consumer.namedQuery` |  |*JPA consumer only:* To use a named query
when consuming data.

|`consumer.nativeQuery` |  |*JPA consumer only:* To use a custom native
query when consuming data. You may want to use the option
`consumer.resultClass` also when using native queries.

|`consumer.parameters` |  |*Camel 2.12: JPA consumer only:* This option
is link:registry.html[Registry] based which requires the `#` notation.
This key/value mapping is used for building the query parameters. It's
is expected to be of the generic type `java.util.Map<String, Object>`
where the keys are the named parameters of a given JPA query and the
values are their corresponding effective values you want to select for.

|`consumer.resultClass` |  |*Camel 2.7: JPA consumer only:* Defines the
type of the returned payload (we will call
`entityManager.createNativeQuery(nativeQuery, resultClass)` instead of
`entityManager.createNativeQuery(nativeQuery)`). Without this option, we
will return an object array. Only has an affect when using in
conjunction with native query when consuming data.

|`consumer.transacted` |`false` |*Camel 2.7.5/2.8.3/2.9: JPA consumer
only:* Whether to run the consumer in transacted mode, by which all
messages will either commit or rollback, when the entire batch has been
processed. The default behavior (false) is to commit all the previously
successfully processed messages, and only rollback the last failed
message.

|`consumer.lockModeType` |`WRITE` |*Camel 2.11.2/2.12:* To configure the
lock mode on the consumer. The possible values is defined in the enum
`javax.persistence.LockModeType`. The default value is changed to
`PESSIMISTIC_WRITE` since *Camel 2.13*.

|`consumer.SkipLockedEntity` |`false` |*Camel 2.13:* To configure
whether to use NOWAIT on lock and silently skip the entity.

|`usePersist` |`false` |*Camel 2.5: JPA producer only:* Indicates to use
`entityManager.persist(entity)` instead of
`entityManager.merge(entity)`. Note: `entityManager.persist(entity)`
doesn't work for detached entities (where the EntityManager has to
execute an UPDATE instead of an INSERT query)!

|`joinTransaction` |`true` |*Camel 2.12.3:* camel-jpa will join
transaction by default from Camel 2.12 onwards. You can use this option
to turn this off, for example if you use LOCAL_RESOURCE and join
transaction doesn't work with your JPA provider. This option can also be
set globally on the `JpaComponent`, instead of having to set it on all
endpoints.

|usePassedInEntityManager |false a|
*Camel 2.12.4/2.13.1 JPA producer only:* If set to true, then Camel will
use the EntityManager from the header

JpaConstants.ENTITYMANAGER instead of the configured entity manager on
the component/endpoint. This allows end users to control which entity
manager will be in use.

|sharedEntityManager |false |*Camel 2.16:* whether to use spring's
SharedEntityManager for the consumer/producer. A good idea may be to set
joinTransaction=false if this option is true, as sharing the entity
manager and mixing transactions is not a good idea. 

|query |  |To use a custom query. *Camel 2.19:* it can be used for
producer as well.

|namedQuery |  |To use a named query. *Camel 2.19:* it can be used for
producer as well.

|nativeQuery |  |To use a custom native query. You may want to use the
option `resultClass` also when using native queries. **Camel 2.19:** it
can be used for producer as well.

|parameters |  |This option is link:registry.html[Registry] based which
requires the `#` notation. This key/value mapping is used for building
the query parameters. It is expected to be of the generic type
`java.util.Map<String, Object>` where the keys are the named parameters
of a given JPA query and the values are their corresponding effective
values you want to select for. **Camel 2.19:** it can be used for
producer as well. When it's used for producer, link:simple.html[Simple]
expression can be used as a parameter value. It allows you to retrieve
parameter values from the message body header and etc.

|resultClass |  |Defines the type of the returned payload (we will call
`entityManager.createNativeQuery(nativeQuery, resultClass)` instead of
`entityManager.createNativeQuery(nativeQuery)`). Without this option, we
will return an object array. Only has an affect when using in
conjunction with native query. **Camel 2.19:** it can be used for
producer as well.

|useExecuteUpdate |  |**Camel 2.19: JPA producer only:** To configure
whether to use executeUpdate() when producer executes a query. When you
use INSERT, UPDATE or DELETE statement as a named query, you need to
specify this option to 'true'.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.10]]
Message Headers
^^^^^^^^^^^^^^^

Camel adds the following message headers to the exchange:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelJpaTemplate` |`JpaTemplate` |*Not supported anymore since Camel
2.12:* The `JpaTemplate` object that is used to access the entity bean.
You need this object in some situations, for instance in a type
converter or when you are doing some custom processing. See
https://issues.apache.org/jira/browse/CAMEL-5932[CAMEL-5932] for the
reason why the support for this header has been dropped.

|`CamelEntityManager` |`EntityManager` |*Camel 2.12: JPA consumer /
Camel 2.12.2: JPA producer:* The JPA `EntityManager` object being used
by `JpaConsumer` or `JpaProducer`.
|=======================================================================

[[BookComponentAppendix-ConfiguringEntityManagerFactory]]
Configuring EntityManagerFactory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Its strongly advised to configure the JPA component to use a specific
`EntityManagerFactory` instance. If failed to do so each `JpaEndpoint`
will auto create their own instance of `EntityManagerFactory` which most
often is not what you want.

For example, you can instantiate a JPA component that references the
`myEMFactory` entity manager factory, as follows:

xml<bean id="jpa" class="org.apache.camel.component.jpa.JpaComponent">
<property name="entityManagerFactory" ref="myEMFactory"/> </bean>

In *Camel 2.3* the `JpaComponent` will auto lookup the
`EntityManagerFactory` from the link:registry.html[Registry] which means
you do not need to configure this on the `JpaComponent` as shown above.
You only need to do so if there is ambiguity, in which case Camel will
log a WARN.

[[BookComponentAppendix-ConfiguringTransactionManager]]
Configuring TransactionManager
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since *Camel 2.3* the `JpaComponent` will auto lookup the
`TransactionManager` from the link:registry.html[Registry.] If Camel
won't find any `TransactionManager` instance registered, it will also
look up for the `TransactionTemplate` and try to
extract `TransactionManager` from it.

If none `TransactionTemplate` is available in the registry,
`JpaEndpoint` will auto create their own instance of
`TransactionManager` which most often is not what you want.

If more than single instance of the `TransactionManager` is found, Camel
will log a WARN. In such cases you might want to instantiate and
explicitly configure a JPA component that references the
`myTransactionManager` transaction manager, as follows:

xml<bean id="jpa" class="org.apache.camel.component.jpa.JpaComponent">
<property name="entityManagerFactory" ref="myEMFactory"/> <property
name="transactionManager" ref="myTransactionManager"/> </bean>

[[BookComponentAppendix-Usingaconsumerwithanamedquery]]
Using a consumer with a named query
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For consuming only selected entities, you can use the
`consumer.namedQuery` URI query option. First, you have to define the
named query in the JPA Entity class:

@Entity @NamedQuery(name = "step1", query = "select x from MultiSteps x
where x.step = 1") public class MultiSteps \{ ... }

After that you can define a consumer uri like this one:

from("jpa://org.apache.camel.examples.MultiSteps?consumer.namedQuery=step1")
.to("bean:myBusinessLogic");

[[BookComponentAppendix-Usingaconsumerwithaquery]]
Using a consumer with a query
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For consuming only selected entities, you can use the `consumer.query`
URI query option. You only have to define the query option:

from("jpa://org.apache.camel.examples.MultiSteps?consumer.query=select o
from org.apache.camel.examples.MultiSteps o where o.step = 1")
.to("bean:myBusinessLogic");

[[BookComponentAppendix-Usingaconsumerwithanativequery]]
Using a consumer with a native query
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For consuming only selected entities, you can use the
`consumer.nativeQuery` URI query option. You only have to define the
native query option:

from("jpa://org.apache.camel.examples.MultiSteps?consumer.nativeQuery=select
* from MultiSteps where step = 1") .to("bean:myBusinessLogic");

If you use the native query option, you will receive an object array in
the message body.

 

[[BookComponentAppendix-Usingaproducerwithanamedquery]]
Using a producer with a named query
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For retrieving selected entities or execute bulk update/delete, you can
use the `namedQuery` URI query option. First, you have to define the
named query in the JPA Entity class:

@Entity @NamedQuery(name = "step1", query = "select x from MultiSteps x
where x.step = 1") public class MultiSteps \{ ... }

After that you can define a producer uri like this one:

from("direct:namedQuery")
.to("jpa://org.apache.camel.examples.MultiSteps?namedQuery=step1");

[[BookComponentAppendix-Usingaproducerwithaquery]]
Using a producer with a query
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For retrieving selected entities or execute bulk update/delete, you can
use the `query` URI query option. You only have to define the query
option:

from("direct:query")
.to("jpa://org.apache.camel.examples.MultiSteps?query=select o from
org.apache.camel.examples.MultiSteps o where o.step = 1");

[[BookComponentAppendix-Usingaproducerwithanativequery]]
Using a producer with a native query
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For retrieving selected entities or execute bulk update/delete, you can
use the `nativeQuery` URI query option. You only have to define the
native query option:

from("direct:nativeQuery")
.to("jpa://org.apache.camel.examples.MultiSteps?resultClass=org.apache.camel.examples.MultiSteps&nativeQuery=select
* from MultiSteps where step = 1");

If you use the native query option without specifying _resultClass_, you
will receive an object array in the message body.

 

[[BookComponentAppendix-Example.6]]
Example
^^^^^^^

See link:tracer-example.html[Tracer Example] for an example using
link:jpa.html[JPA] to store traced messages into a database.

[[BookComponentAppendix-UsingtheJPAbasedidempotentrepository]]
Using the JPA based idempotent repository
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this section we will use the JPA based idempotent repository.

First we need to setup a `persistence-unit` in the persistence.xml
file:\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-jpa/src/test/resources/META-INF/persistence.xml}Second
we have to setup a `org.springframework.orm.jpa.JpaTemplate` which is
used by the
`org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository`:\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-jpa/src/test/resources/org/apache/camel/processor/jpa/spring.xml}Afterwards
we can configure our
`org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository`:\{snippet:id=jpaStore|lang=xml|url=camel/trunk/components/camel-jpa/src/test/resources/org/apache/camel/processor/jpa/fileConsumerJpaIdempotentTest-config.xml}And
finally we can create our JPA idempotent repository in the spring XML
file as well:

xml<camelContext xmlns="http://camel.apache.org/schema/spring"> <route
id="JpaMessageIdRepositoryTest"> <from uri="direct:start" />
<idempotentConsumer messageIdRepositoryRef="jpaStore">
<header>messageId</header> <to uri="mock:result" />
</idempotentConsumer> </route> </camelContext> When running this Camel
component tests inside your IDE

In case you run the
https://svn.apache.org/repos/asf/camel/trunk/components/camel-jpa/src/test[tests
of this component] directly inside your IDE (and not necessarily through
Maven itself) then you could spot exceptions like:

javaorg.springframework.transaction.CannotCreateTransactionException:
Could not open JPA EntityManager for transaction; nested exception is
<openjpa-2.2.1-r422266:1396819 nonfatal user error>
org.apache.openjpa.persistence.ArgumentException: This configuration
disallows runtime optimization, but the following listed types were not
enhanced at build time or at class load time with a javaagent:
"org.apache.camel.examples.SendEmail". at
org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:427)
at
org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:371)
at
org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:127)
at
org.apache.camel.processor.jpa.JpaRouteTest.cleanupRepository(JpaRouteTest.java:96)
at
org.apache.camel.processor.jpa.JpaRouteTest.createCamelContext(JpaRouteTest.java:67)
at
org.apache.camel.test.junit4.CamelTestSupport.doSetUp(CamelTestSupport.java:238)
at
org.apache.camel.test.junit4.CamelTestSupport.setUp(CamelTestSupport.java:208)

The problem here is that the source has been compiled/recompiled through
your IDE and not through Maven itself which would
https://svn.apache.org/repos/asf/camel/trunk/components/camel-jpa/pom.xml[enhance
the byte-code at build time]. To overcome this you would need to enable
http://openjpa.apache.org/entity-enhancement.html#dynamic-enhancement[dynamic
byte-code enhancement of OpenJPA]. As an example assuming the current
OpenJPA version being used in Camel itself is 2.2.1, then as running the
tests inside your favorite IDE you would need to pass the following
argument to the JVM:

-javaagent:<path_to_your_local_m2_cache>/org/apache/openjpa/openjpa/2.2.1/openjpa-2.2.1.jar

Then it will all become green again
image:https://cwiki.apache.org/confluence/s/en_GB/5997/6f42626d00e36f53fe51440403446ca61552e2a2.1/_/images/icons/emoticons/smile.png[(smile)]

link:endpoint-see-also.html[Endpoint See Also]

* link:tracer-example.html[Tracer Example]

[[BookComponentAppendix-JT/400Component]]
JT/400 Component
~~~~~~~~~~~~~~~~

The *`jt400`* component allows you to exchanges messages with an AS/400
system using data queues.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-jt400</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.33]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
jt400://user:password@system/QSYS.LIB/LIBRARY.LIB/QUEUE.DTAQ[?options]
----

To call remote program (*Camel 2.7*)

[source,brush:,java;,gutter:,false;,theme:,Default]
----
jt400://user:password@system/QSYS.LIB/LIBRARY.LIB/program.PGM[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-URIoptions.1]]
URI options
^^^^^^^^^^^

For the data queue message exchange:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default value |Description
|`ccsid` |default system CCSID |Specifies the CCSID to use for the
connection with the AS/400 system.

|`format` |`text` |Specifies the data format for sending messages +
valid options are: `text` (represented by `String`) and `binary`
(represented by `byte[]`)

|`consumer.delay` |`500` |Delay in milliseconds between each poll.

|`consumer.initialDelay` |`1000` |Milliseconds before polling starts.

|`consumer.userFixedDelay` |`false` |`true` to use fixed delay between
polls, otherwise fixed rate is used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.

|`guiAvailable` |`false` |*Camel 2.8:* Specifies whether AS/400
prompting is enabled in the environment running Camel.

|`keyed` |`false` |*Camel 2.10:* Whether to use keyed or non-keyed data
queues.

|`searchKey` |`null` |*Camel 2.10:* Search key for keyed data queues.

|`searchType` |`EQ` |*Camel 2.10:* Search type which can be a value of
`EQ`, `NE`, `LT`, `LE`, `GT`, or `GE`.

|`connectionPool` |`AS400ConnectionPool` instance |*Camel 2.10:*
Reference to an com.ibm.as400.access.AS400ConnectionPool instance in the
Registry. This is used for obtaining connections to the AS/400 system.
The look up notation ('#' character) should be used.

|`secured` |`false` |*Camel 2.16:* Whether to use SSL connections to the
AS/400
|=======================================================================

For the remote program call (*Camel 2.7*)

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default value |Description
|`outputFieldsIdx` |  |Specifies which fields (program parameters) are
output parameters.

|`fieldsLength` |  |Specifies the fields (program parameters) length as
in the AS/400 program definition.

|`format` |`text` |*Camel 2.10:* Specifies the data format for sending
messages +
valid options are: `text` (represented by `String`) and `binary`
(represented by `byte[]`)

|`guiAvailable` |`false` |*Camel 2.8:* Specifies whether AS/400
prompting is enabled in the environment running Camel.

|`connectionPool` |`AS400ConnectionPool` instance |*Camel 2.10:*
Reference to an com.ibm.as400.access.AS400ConnectionPool instance in the
Registry. This is used for obtaining connections to the AS/400 system.
The look up notation ('#' character) should be used.
|=======================================================================

[[BookComponentAppendix-Usage.5]]
Usage
^^^^^

When configured as a consumer endpoint, the endpoint will poll a data
queue on a remote system. For every entry on the data queue, a new
`Exchange` is sent with the entry's data in the _In_ message's body,
formatted either as a `String` or a `byte[]`, depending on the format.
For a provider endpoint, the _In_ message body contents will be put on
the data queue as either raw bytes or text.

[[BookComponentAppendix-Connectionpool]]
Connection pool
^^^^^^^^^^^^^^^

*Available as of Camel 2.10*

Connection pooling is in use from Camel 2.10 onwards. You can explicit
configure a connection pool on the Jt400Component, or as an uri option
on the endpoint.

[[BookComponentAppendix-Remoteprogramcall(Camel2.7)]]
Remote program call (*Camel 2.7*)
+++++++++++++++++++++++++++++++++

This endpoint expects the input to be either a String array or byte[]
array (depending on format) and handles all the CCSID handling through
the native jt400 library mechanisms. A parameter can be _omitted_ by
passing null as the value in its position (the remote program has to
support it). After the program execution the endpoint returns either a
String array or byte[] array with the values as they were returned by
the program (the input only parameters will contain the same data as the
beginning of the invocation) +
This endpoint does not implement a provider endpoint!

[[BookComponentAppendix-Example.7]]
Example
^^^^^^^

In the snippet below, the data for an exchange sent to the
`direct:george` endpoint will be put in the data queue `PENNYLANE` in
library `BEATLES` on a system named `LIVERPOOL`. +
Another user connects to the same data queue to receive the information
from the data queue and forward it to the `mock:ringo` endpoint.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
public class Jt400RouteBuilder extends RouteBuilder {
    @Override
    public void configure() throws Exception {
       from("direct:george").to("jt400://GEORGE:EGROEG@LIVERPOOL/QSYS.LIB/BEATLES.LIB/PENNYLANE.DTAQ");
       from("jt400://RINGO:OGNIR@LIVERPOOL/QSYS.LIB/BEATLES.LIB/PENNYLANE.DTAQ").to("mock:ringo");
    }
}
----

[[BookComponentAppendix-Remoteprogramcallexample(Camel2.7)]]
Remote program call example (*Camel 2.7*)
+++++++++++++++++++++++++++++++++++++++++

In the snippet below, the data Exchange sent to the direct:work endpoint
will contain three string that will be used as the arguments for the
program “compute” in the library “assets”. This program will write the
output values in the 2nd and 3rd parameters. All the parameters will be
sent to the direct:play endpoint.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
public class Jt400RouteBuilder extends RouteBuilder {
    @Override
    public void configure() throws Exception {
       from("direct:work").to("jt400://GRUPO:ATWORK@server/QSYS.LIB/assets.LIB/compute.PGM?fieldsLength=10,10,512&ouputFieldsIdx=2,3").to(“direct:play”);
    }
}
----

[[BookComponentAppendix-Writingtokeyeddataqueues]]
Writing to keyed data queues
++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("jms:queue:input")
.to("jt400://username:password@system/lib.lib/MSGINDQ.DTAQ?keyed=true");
----

[[BookComponentAppendix-Readingfromkeyeddataqueues]]
Reading from keyed data queues
++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("jt400://username:password@system/lib.lib/MSGOUTDQ.DTAQ?keyed=true&searchKey=MYKEY&searchType=GE")
.to("jms:queue:output");
----

[[BookComponentAppendix-SeeAlso.19]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-Language]]
Language
~~~~~~~~

*Available as of Camel 2.5*

The language component allows you to send link:exchange.html[Exchange]
to an endpoint which executes a script by any of the supported
link:languages.html[Languages] in Camel. +
By having a component to execute language scripts, it allows more
dynamic routing capabilities. For example by using the
link:routing-slip.html[Routing Slip] or link:dynamic-router.html[Dynamic
Router] EIPs you can send messages to `language` endpoints where the
script is dynamic defined as well.

This component is provided out of the box in `camel-core` and hence no
additional JARs is needed. You only have to include additional Camel
components if the language of choice mandates it, such as using
link:groovy.html[Groovy] or link:javascript.html[JavaScript] languages.

[[BookComponentAppendix-URIformat.34]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
language://languageName[:script][?options]
----

And from Camel 2.11 onwards you can refer to an external resource for
the script using same notation as supported by the other
link:language.html[Language]s in Camel

[source,brush:,java;,gutter:,false;,theme:,Default]
----
language://languageName:resource:scheme:location][?options]
----

[[BookComponentAppendix-URIOptions.7]]
URI Options
^^^^^^^^^^^

The component supports the following options.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Default Value |Type |Description
|`languageName` |`null` |`String` |The name of the
link:languages.html[Language] to use, such as `simple`, `groovy`,
`javascript` etc. This option is mandatory.

|`script` |`null` |`String` |The script to execute.

|`transform` |`true` |`boolean` |Whether or not the result of the script
should be used as the new message body. By setting to `false` the script
is executed but the result of the script is discarded.

|`contentCache` |`true` |`boolean` |*Camel 2.9:* Whether to cache the
script if loaded from a resource. +
Note: from *Camel 2.10.3* a cached script can be forced to reload at
runtime via JMX using the clearContentCache operation.

|`cacheScript` |`false` |`boolean` |*Camel 2.13/2.12.2/2.11.3:* Whether
to cache the compiled script. Turning this option on can gain
performance as the script is only compiled/created once, and reuse when
processing Camel messages. But this may cause side-effects with data
left from previous evaluation spills into the next, and concurrency
issues as well. If the script being evaluated is idempotent then this
option can be turned on.

|`binary` |`false` |`boolean` |*Camel 2.14.1:* Whether the script is
binary content. This is intended to be used for loading resources using
the Constant language, such as loading binary files.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.11]]
Message Headers
^^^^^^^^^^^^^^^

The following message headers can be used to affect the behavior of the
component

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelLanguageScript` |The script to execute provided in the header.
Takes precedence over script configured on the endpoint.
|=======================================================================

[[BookComponentAppendix-Examples.11]]
Examples
^^^^^^^^

For example you can use the link:simple.html[Simple] language to
link:message-translator.html[Message Translator] a message:

In case you want to convert the message body type you can do this as
well:

You can also use the link:groovy.html[Groovy] language, such as this
example where the input message will by multiplied with 2:

You can also provide the script as a header as shown below. Here we use
link:xpath.html[XPath] language to extract the text from the `<foo>`
tag.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
Object out = producer.requestBodyAndHeader("language:xpath", "<foo>Hello World</foo>", Exchange.LANGUAGE_SCRIPT, "/foo/text()");
assertEquals("Hello World", out);
----

[[BookComponentAppendix-Loadingscriptsfromresources]]
Loading scripts from resources
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.9*

You can specify a resource uri for a script to load in either the
endpoint uri, or in the `Exchange.LANGUAGE_SCRIPT` header. +
The uri must start with one of the following schemes: file:, classpath:,
or http:

For example to load a script from the classpath:

By default the script is loaded once and cached. However you can disable
the `contentCache` option and have the script loaded on each
evaluation. +
For example if the file myscript.txt is changed on disk, then the
updated script is used:

From *Camel 2.11* onwards you can refer to the resource similar to the
other link:language.html[Language]s in Camel by prefixing with
`"resource:"` as shown below:

[[BookComponentAppendix-SeeAlso.20]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:languages.html[Languages]
* link:routing-slip.html[Routing Slip]
* link:dynamic-router.html[Dynamic Router]
* link:script.html[Script]

[[BookComponentAppendix-LDAPComponent]]
LDAP Component
~~~~~~~~~~~~~~

The *ldap* component allows you to perform searches in LDAP servers
using filters as the message payload. +
This component uses standard JNDI (`javax.naming` package) to access the
server.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-ldap</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.35]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ldap:ldapServerBean[?options]
----

The _ldapServerBean_ portion of the URI refers to a
http://java.sun.com/j2se/1.4.2/docs/api/javax/naming/directory/DirContext.html[DirContext]
bean in the registry. The LDAP component only supports producer
endpoints, which means that an `ldap` URI cannot appear in the `from` at
the start of a route.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.29]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`base` |`ou=system` |The base DN for searches.

|`scope` |`subtree` |Specifies how deeply to search the tree of entries,
starting at the base DN. Value can be `object`, `onelevel`, or
`subtree`.

|pageSize |no paging used |*Camel 2.6:* When specified the ldap module
uses paging to retrieve all results (most LDAP Servers throw an
exception when trying to retrieve more than 1000 entries in one query).
To be able to use this a LdapContext (subclass of DirContext) has to be
passed in as ldapServerBean (otherwise an exception is thrown)

|returnedAttributes |depends on LDAP Server (could be all or none)
|*Camel 2.6:* Comma-separated list of attributes that should be set in
each entry of the result
|=======================================================================

[[BookComponentAppendix-Result.1]]
Result
^^^^^^

The result is returned in the Out body as a
`ArrayList<javax.naming.directory.SearchResult>` object.

[[BookComponentAppendix-DirContext]]
DirContext
^^^^^^^^^^

The URI, `ldap:ldapserver`, references a Spring bean with the ID,
`ldapserver`. The `ldapserver` bean may be defined as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="ldapserver" class="javax.naming.directory.InitialDirContext" scope="prototype">
  <constructor-arg>
    <props>
      <prop key="java.naming.factory.initial">com.sun.jndi.ldap.LdapCtxFactory</prop>
      <prop key="java.naming.provider.url">ldap://localhost:10389</prop>
      <prop key="java.naming.security.authentication">none</prop>
    </props>
  </constructor-arg>
</bean>
----

The preceding example declares a regular Sun based LDAP `DirContext`
that connects anonymously to a locally hosted LDAP server.

[Note]
====


`DirContext` objects are *not* required to support concurrency by
contract. It is therefore important that the directory context is
declared with the setting, `scope="prototype"`, in the `bean` definition
or that the context supports concurrency. In the Spring framework,
`prototype` scoped objects are instantiated each time they are looked
up.

====

[[BookComponentAppendix-Samples.6]]
Samples
^^^^^^^

Following on from the Spring configuration above, the code sample below
sends an LDAP request to filter search a group for a member. The Common
Name is then extracted from the response.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ProducerTemplate<Exchange> template = exchange
  .getContext().createProducerTemplate();

Collection<?> results = (Collection<?>) (template
  .sendBody(
    "ldap:ldapserver?base=ou=mygroup,ou=groups,ou=system",
    "(member=uid=huntc,ou=users,ou=system)"));

if (results.size() > 0) {
  // Extract what we need from the device's profile

  Iterator<?> resultIter = results.iterator();
  SearchResult searchResult = (SearchResult) resultIter
      .next();
  Attributes attributes = searchResult
      .getAttributes();
  Attribute deviceCNAttr = attributes.get("cn");
  String deviceCN = (String) deviceCNAttr.get();

  ...
----

If no specific filter is required - for example, you just need to look
up a single entry - specify a wildcard filter expression. For example,
if the LDAP entry has a Common Name, use a filter expression like:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
(cn=*)
----

[[BookComponentAppendix-Bindingusingcredentials]]
Binding using credentials
+++++++++++++++++++++++++

A Camel end user donated this sample code he used to bind to the ldap
server using credentials.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
Properties props = new Properties();
props.setProperty(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
props.setProperty(Context.PROVIDER_URL, "ldap://localhost:389");
props.setProperty(Context.URL_PKG_PREFIXES, "com.sun.jndi.url");
props.setProperty(Context.REFERRAL, "ignore");
props.setProperty(Context.SECURITY_AUTHENTICATION, "simple");
props.setProperty(Context.SECURITY_PRINCIPAL, "cn=Manager");
props.setProperty(Context.SECURITY_CREDENTIALS, "secret");

SimpleRegistry reg = new SimpleRegistry();
reg.put("myldap", new InitialLdapContext(props, null));

CamelContext context = new DefaultCamelContext(reg);
context.addRoutes(
    new RouteBuilder() {
        public void configure() throws Exception { 
            from("direct:start").to("ldap:myldap?base=ou=test");
        }
    }
);
context.start();

ProducerTemplate template = context.createProducerTemplate();

Endpoint endpoint = context.getEndpoint("direct:start");
Exchange exchange = endpoint.createExchange();
exchange.getIn().setBody("(uid=test)");
Exchange out = template.send(endpoint, exchange);

Collection<SearchResult> data = out.getOut().getBody(Collection.class);
assert data != null;
assert !data.isEmpty();

System.out.println(out.getOut().getBody());

context.stop();
----

[[BookComponentAppendix-ConfiguringSSL]]
Configuring SSL
^^^^^^^^^^^^^^^

All required is to create a custom socket factory and reference it in
the InitialDirContext bean - see below sample.

*SSL Configuration*

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<?xml version="1.0" encoding="UTF-8"?>
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
                 http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd">


    <sslContextParameters xmlns="http://camel.apache.org/schema/blueprint"
                          id="sslContextParameters">
        <keyManagers
                keyPassword="{{keystore.pwd}}">
            <keyStore
                    resource="{{keystore.url}}"
                    password="{{keystore.pwd}}"/>
        </keyManagers>
    </sslContextParameters>

    <bean id="customSocketFactory" class="zotix.co.util.CustomSocketFactory">
        <argument ref="sslContextParameters" />
    </bean>
    <bean id="ldapserver" class="javax.naming.directory.InitialDirContext" scope="prototype">
        <argument>
            <props>
                <prop key="java.naming.factory.initial" value="com.sun.jndi.ldap.LdapCtxFactory"/>
                <prop key="java.naming.provider.url" value="ldaps://lab.zotix.co:636"/>
                <prop key="java.naming.security.protocol" value="ssl"/>
                <prop key="java.naming.security.authentication" value="simple" />
                <prop key="java.naming.security.principal" value="cn=Manager,dc=example,dc=com"/>
                <prop key="java.naming.security.credentials" value="passw0rd"/>
                <prop key="java.naming.ldap.factory.socket"
                      value="zotix.co.util.CustomSocketFactory"/>
            </props>
        </argument>
    </bean>
</blueprint>
----

*Custom Socket Factory*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
import org.apache.camel.util.jsse.SSLContextParameters;

import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManagerFactory;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.security.KeyStore;

/**
 * The CustomSocketFactory. Loads the KeyStore and creates an instance of SSLSocketFactory
 */
public class CustomSocketFactory extends SSLSocketFactory {

    private static SSLSocketFactory socketFactory;

    /**
     * Called by the getDefault() method.
     */
    public CustomSocketFactory() {

    }

    /**
     * Called by Blueprint DI to initialise an instance of SocketFactory
     *
     * @param sslContextParameters
     */
    public CustomSocketFactory(SSLContextParameters sslContextParameters) {
        try {
            KeyStore keyStore = sslContextParameters.getKeyManagers().getKeyStore().createKeyStore();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
            tmf.init(keyStore);
            SSLContext ctx = SSLContext.getInstance("TLS");
            ctx.init(null, tmf.getTrustManagers(), null);
            socketFactory = ctx.getSocketFactory();
        } catch (Exception ex) {
            ex.printStackTrace(System.err);  /* handle exception */
        }
    }

    /**
     * Getter for the SocketFactory
     *
     * @return
     */
    public static SocketFactory getDefault() {
        return new CustomSocketFactory();
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return socketFactory.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return socketFactory.getSupportedCipherSuites();
    }

    @Override
    public Socket createSocket(Socket socket, String string, int i, boolean bln) throws IOException {
        return socketFactory.createSocket(socket, string, i, bln);
    }

    @Override
    public Socket createSocket(String string, int i) throws IOException {
        return socketFactory.createSocket(string, i);
    }

    @Override
    public Socket createSocket(String string, int i, InetAddress ia, int i1) throws IOException {
        return socketFactory.createSocket(string, i, ia, i1);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i) throws IOException {
        return socketFactory.createSocket(ia, i);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i, InetAddress ia1, int i1) throws IOException {
        return socketFactory.createSocket(ia, i, ia1, i1);
    }
}
----

 

[[BookComponentAppendix-SeeAlso.21]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-LogComponent]]
Log Component
~~~~~~~~~~~~~

The *`log:`* component logs message exchanges to the underlying logging
mechanism.

Camel uses http://www.slf4j.org/[sfl4j] which allows you to configure
logging via, among others:

* http://logging.apache.org/log4j/[Log4j]
* http://logback.qos.ch/[Logback]
* http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/package-summary.html[JDK
Util Logging logging]

[[BookComponentAppendix-URIformat.36]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
log:loggingCategory[?options]
----

Where *`loggingCategory`* is the name of the logging category to use.
You can append query options to the URI in the following format,
*`?option=value&option=value&...`*

[Info]
====
 **Using Logger instance from the the Registry**

As of *Camel 2.12.4/2.13.1*, if there's single instance
of *`org.slf4j.Logger`* found in the Registry, the *`loggingCategory`*
is no longer used to create logger instance. The registered instance is
used instead. Also it is possible to reference particular *`Logger`*
instance using *`?logger=#myLogger`* URI parameter. Eventually, if
there's no registered and URI *`logger`* parameter, the logger instance
is created using *`loggingCategory`*.

====

For example, a log endpoint typically specifies the logging level using
the *`level`* option, as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
log:org.apache.camel.example?level=DEBUG
----

The default logger logs every exchange (_regular logging_). But Camel
also ships with the *`Throughput`* logger, which is used whenever the
*`groupSize`* option is specified.

[Tip]
====
 **Also a log in the DSL**

There is also a *`log`* directly in the DSL, but it has a different
purpose. Its meant for lightweight and human logs. See more details at
link:logeip.html[LogEIP].

====

[[BookComponentAppendix-Options.30]]
Options
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |Default |Type |Description
|`groupActiveOnly` |`true` |`boolean` a|
If *`true`*, will hide stats when no new messages have been received for
a time interval.

If *`false`*, show stats regardless of message traffic

|`groupDelay` |`0` |`Integer` |Set the initial delay for stats (in
millis)

|`groupInterval` |`null` |`Integer` |If specified will group message
stats by this time interval (in millis)

|`groupSize` |`null` |`Integer` |An integer that specifies a group size
for throughput logging.

|`level` |`INFO` |`String` |Logging level to use. Possible values:
*`ERROR`, `WARN`*, *`INFO`*, *`DEBUG`, `TRACE`*, *`OFF`*

|`logger` |  |`Logger` |*Camel 2.12.4/2.13.1:* An optional reference to
*`org.slf4j.Logger`* from Registry to use.

|`marker` |`null` |`String` |*Camel 2.9:* An optional
http://www.slf4j.org/api/org/slf4j/Marker.html[Marker] name to use.
|=======================================================================

 

* +
*

[Tip]
====


*`groupDelay`* and *`groupActiveOnly`* are only applicable when using
*`groupInterval`*.

====

 

[[BookComponentAppendix-Formatting]]
Formatting
^^^^^^^^^^

The log formats the execution of exchanges to log lines. 

By default, the log uses *`LogFormatter`* to format the log output,
where *`LogFormatter`* has the following options:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`maxChars` |  |Limits the number of characters logged per line. The
default value, from *Camel 2.9* is *`10000`*.

|`multiline` |`false` |If *`true`*, each piece of information is logged
on a new line.

|`showAll` |`false` |Quick option for turning all options on.
(*`multiline`*, *`maxChars`* has to be manually set if to be used)

|`showBody` |`true` |Show the *`IN`* body.

|`showBodyType` |`true` |Show the *`IN`* body Java type.

|`showCaughtException` |`false` a|
If the exchange has a caught exception, show the exception message (no
stack trace).

A caught exception is stored as a property on the exchange (using the
key *`Exchange.EXCEPTION_CAUGHT`*) and for instance a *`doCatch`* can
catch exceptions.

See link:try-catch-finally.html[Try Catch Finally].

|`showException` |`false` |If the exchange has an exception, show the
exception message (no stack trace).

|`showExchangeId` |`false` |Show the unique exchange ID.

|`showExchangePattern` |`true` |Shows the Message Exchange Pattern (or
MEP for short).

|`showFiles` |`false` |*Camel 2.9:* Whether Camel should show file
bodies or not, e.g., such as *`java.io.File`*.

|`showFuture` |`false` |Whether Camel should show
*`java.util.concurrent.Future`* bodies or not. If enabled Camel could
potentially wait until the *`Future`* task is done. Will not wait, by
default.

|`showHeaders` |`false` |Show the *`IN`* message headers.

|`showOut` |`false` |If the exchange has an *`OUT`* message, show
the *`OUT`* message.

|`showProperties` |`false` |Show the exchange properties.

|`showStackTrace` |`false` |Show the stack trace, if an exchange has an
exception. Only effective if one of *`showAll`, `showException`* or
*`showCaughtException`* are enabled.

|`showStreams` |`false` a|
*Camel 2.8:* Whether Camel should show stream bodies or not, e.g., such
as *`java.io.InputStream`*.

[Tip]
====


If you enable this option then you may not be able later to access the
message body as the stream have already been read by this logger.

To remedy this you will have to use link:stream-caching.html[Stream
caching].

====

|`skipBodyLineSeparator` |`true` a|
*Camel 2.12.2:* Whether to skip line separators when logging the message
body. This will log the message body on a single line.

Set to *`false`* to preserve any line separators present in the body,
therefore logging the body _as is_.

|=======================================================================

**Logging stream bodies**

For older versions of Camel that do not support the *`showFiles`*
or *`showStreams`* properties above, you can set the following property
instead on the link:camelcontext.html[CamelContext] to log both stream
and file bodies:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
camelContext.getProperties().put(Exchange.LOG_DEBUG_BODY_STREAMS, true);
----

[[BookComponentAppendix-RegularLoggerExample]]
Regular Logger Example
^^^^^^^^^^^^^^^^^^^^^^

In the route below we log the incoming orders at *`DEBUG`* level before
the order is processed:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:orders")
  .to("log:com.mycompany.order?level=DEBUG")
  .to("bean:processOrder");
----

Or using Spring XML:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <route>
    <from uri="activemq:orders"/>
    <to uri="log:com.mycompany.order?level=DEBUG"/>
    <to uri="bean:processOrder"/>
  </route> 
----

[[BookComponentAppendix-RegularLoggerwithFormatter]]
Regular Logger with Formatter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the route below we log the incoming orders at *`INFO`* level before
the order is processed.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:orders")
  .to("log:com.mycompany.order?showAll=true&multiline=true")
  .to("bean:processOrder");
----

[[BookComponentAppendix-ThroughputLoggerWithgroupSize]]
Throughput Logger With *`groupSize`*
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the route below we log the throughput of the incoming orders at
*`DEBUG`* level grouped by 10 messages.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:orders")
  .to("log:com.mycompany.order?level=DEBUG&groupSize=10")
  .to("bean:processOrder");
----

[[BookComponentAppendix-ThroughputLoggerWithgroupInterval]]
Throughput Logger With `groupInterval`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This route will result in message stats logged every *`10s`*, with an
initial *`60s`* delay and stats should be displayed even if there isn't
any message traffic.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:orders")
  .to("log:com.mycompany.order?level=DEBUG&groupInterval=10000&groupDelay=60000&groupActiveOnly=false")
  .to("bean:processOrder");
----

The following will be logged:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
"Received: 1000 new messages, with total 2000 so far. Last group took: 10000 millis which is: 100 messages per second. average: 100"
----

[[BookComponentAppendix-FullCustomizationoftheLoggedOutput]]
Full Customization of the Logged Output
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.11*

With the options outlined in the link:log.html[#Formatting] section, you
can control much of the output of the logger. However, log lines will
always follow this structure:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
Exchange[Id:ID-machine-local-50656-1234567901234-1-2, ExchangePattern:InOut, 
Properties:{CamelToEndpoint=log://org.apache.camel.component.log.TEST?showAll=true, 
CamelCreatedTimestamp=Thu Mar 28 00:00:00 WET 2013}, 
Headers:{breadcrumbId=ID-machine-local-50656-1234567901234-1-1}, BodyType:String, Body:Hello World, Out: null]
----

This format is unsuitable in some cases, perhaps because you need to:

* Filter the headers and properties that are printed, to strike a
balance between insight and verbosity.
* Adjust the log message to whatever you deem most readable.
* Tailor log messages for digestion by log mining systems, e.g. Splunk.
* Print specific body types differently.
* Etc.

Whenever you require absolute customization, you can create a class that
implements the
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/spi/ExchangeFormatter.html[`ExchangeFormatter`]
interface. Within the *`format(Exchange)`* method you have access to the
full Exchange, so you can select and extract the precise information you
need, format it in a custom manner and return it. The return value will
become the final log message.

You can have the Log component pick up your custom *`ExchangeFormatter`*
in one of two ways:

*Explicitly instantiating the `LogComponent` in your Registry*

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<bean name="log" class="org.apache.camel.component.log.LogComponent">
   <property name="exchangeFormatter" ref="myCustomFormatter"/>
</bean>
----

*Convention Over Configuration*

Simply by registering a bean with the name *`logFormatter`*; the Log
Component is intelligent enough to pick it up automatically.

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<bean name="logFormatter" class="com.xyz.MyCustomExchangeFormatter"/>
----

[Tip]
====


The *`ExchangeFormatter`* gets applied to *all Log endpoints within that
Camel Context*. If you need a different *`ExchangeFormatter`* for each
endpoint, just instantiate the *`LogComponent`* as many times as needed,
and use the relevant bean name as the endpoint prefix. ====

From *Camel 2.11.2/2.12*: when using a custom log formatter, you can
specify parameters in the log URI, which gets configured on the custom
log formatter. Though when you do that you should define
the *`logFormatter`* as prototype scoped so its not shared if you have
different parameters.

Example:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<bean name="logFormatter" class="com.xyz.MyCustomExchangeFormatter" scope="prototype"/>
----

And then we can have Camel routes using the log URI with different
options:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<to uri="log:foo?param1=foo&amp;param2=100"/>
<!-- ... -->
<to uri="log:bar?param1=bar&amp;param2=200"/>
----

[[BookComponentAppendix-UsingLogComponentinOSGi]]
Using Log Component in OSGi
+++++++++++++++++++++++++++

*Improvements from Camel 2.12.4/2.13.1*

When using *`Log`* component inside OSGi (e.g., in Karaf), the
underlying logging mechanisms are provided by PAX logging. It searches
for a bundle which invokes *`org.slf4j.LoggerFactory.getLogger()`*
method and associates the bundle with the logger instance. Without
specifying custom *`org.sfl4j.Logger`* instance, the logger created by
Log component is associated with *`camel-core`* bundle.

In some scenarios it is required that the bundle associated with logger
should be the bundle which contains route definition. To do this, either
register a single instance of *`org.slf4j.Logger`* in the Registry or
reference it using *`logger`* URI parameter.

[[BookComponentAppendix-SeeAlso.22]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:tracer.html[Tracer]
* link:how-do-i-use-log4j.html[How do I use log4j]
* link:how-do-i-use-java-14-logging.html[How do I use Java 1.4 logging]
* link:logeip.html[LogEIP] for using `log` directly in the DSL for human
logs.

[[BookComponentAppendix-Lucene(IndexerandSearch)Component]]
Lucene (Indexer and Search) Component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.2*

The *lucene* component is based on the Apache Lucene project. Apache
Lucene is a powerful high-performance, full-featured text search engine
library written entirely in Java. For more details about Lucene, please
see the following links

* http://lucene.apache.org/java/docs/
* http://lucene.apache.org/java/docs/features.html

The lucene component in camel facilitates integration and utilization of
Lucene endpoints in enterprise integration patterns and scenarios. The
lucene component does the following

* builds a searchable index of documents when payloads are sent to the
Lucene Endpoint
* facilitates performing of indexed searches in Camel

This component only supports producer endpoints.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-lucene</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.37]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
lucene:searcherName:insert[?options]
lucene:searcherName:query[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-InsertOptions]]
Insert Options
^^^^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`analyzer` |`StandardAnalyzer` |An Analyzer builds TokenStreams, which
analyze text. It thus represents a policy for extracting index terms
from text. The value for analyzer can be any class that extends the
abstract class org.apache.lucene.analysis.Analyzer. Lucene also offers a
rich set of analyzers out of the box

|`indexDir` |`./indexDirectory` |A file system directory in which index
files are created upon analysis of the document by the specified
analyzer

|`srcDir` |`null` |An optional directory containing files to be used to
be analyzed and added to the index at producer startup.
|=======================================================================

[[BookComponentAppendix-QueryOptions]]
Query Options
^^^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`analyzer` |`StandardAnalyzer` |An Analyzer builds TokenStreams, which
analyze text. It thus represents a policy for extracting index terms
from text. The value for analyzer can be any class that extends the
abstract class org.apache.lucene.analysis.Analyzer. Lucene also offers a
rich set of analyzers out of the box

|`indexDir` |`./indexDirectory` |A file system directory in which index
files are created upon analysis of the document by the specified
analyzer

|`maxHits` |`10` |An integer value that limits the result set of the
search operation
|=======================================================================

[[BookComponentAppendix-Sending/ReceivingMessagesto/fromthecache.1]]
Sending/Receiving Messages to/from the cache
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-MessageHeaders.12]]
Message Headers
+++++++++++++++

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`QUERY` |The Lucene Query to performed on the index. The query may
include wildcards and phrases

|RETURN_LUCENE_DOCS |*Camel 2.15:* Set this header to true to include
the actual Lucene documentation when returning hit information.
|=======================================================================

[[BookComponentAppendix-LuceneProducers]]
Lucene Producers
++++++++++++++++

This component supports 2 producer endpoints.

* *insert* - The insert producer builds a searchable index by analyzing
the body in incoming exchanges and associating it with a token
("content").
* *query* - The query producer performs searches on a pre-created index.
The query uses the searchable index to perform score & relevance based
searches. Queries are sent via the incoming exchange contains a header
property name called 'QUERY'. The value of the header property 'QUERY'
is a Lucene Query. For more details on how to create Lucene Queries
check out http://lucene.apache.org/java/3_0_0/queryparsersyntax.html

[[BookComponentAppendix-LuceneProcessor]]
Lucene Processor
++++++++++++++++

There is a processor called LuceneQueryProcessor available to perform
queries against lucene without the need to create a producer.

[[BookComponentAppendix-LuceneUsageSamples]]
Lucene Usage Samples
^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-Example1:CreatingaLuceneindex]]
Example 1: Creating a Lucene index
++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
       from("direct:start").
           to("lucene:whitespaceQuotesIndex:insert?
               analyzer=#whitespaceAnalyzer&indexDir=#whitespace&srcDir=#load_dir").
           to("mock:result");
    }
};
----

[[BookComponentAppendix-Example2:LoadingpropertiesintotheJNDIregistryintheCamelContext]]
Example 2: Loading properties into the JNDI registry in the Camel
Context
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Override
protected JndiRegistry createRegistry() throws Exception {
  JndiRegistry registry =
         new JndiRegistry(createJndiContext());
  registry.bind("whitespace", new File("./whitespaceIndexDir"));
  registry.bind("load_dir",
        new File("src/test/resources/sources"));
  registry.bind("whitespaceAnalyzer",
        new WhitespaceAnalyzer());
  return registry;
}
...
CamelContext context = new DefaultCamelContext(createRegistry());
----

[[BookComponentAppendix-Example2:PerformingsearchesusingaQueryProducer]]
Example 2: Performing searches using a Query Producer
+++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
       from("direct:start").
          setHeader("QUERY", constant("Seinfeld")).
          to("lucene:searchIndex:query?
             analyzer=#whitespaceAnalyzer&indexDir=#whitespace&maxHits=20").
          to("direct:next");
                
       from("direct:next").process(new Processor() {
          public void process(Exchange exchange) throws Exception {
             Hits hits = exchange.getIn().getBody(Hits.class);
             printResults(hits);
          }

          private void printResults(Hits hits) {
              LOG.debug("Number of hits: " + hits.getNumberOfHits());
              for (int i = 0; i < hits.getNumberOfHits(); i++) {
                 LOG.debug("Hit " + i + " Index Location:" + hits.getHit().get(i).getHitLocation());
                 LOG.debug("Hit " + i + " Score:" + hits.getHit().get(i).getScore());
                 LOG.debug("Hit " + i + " Data:" + hits.getHit().get(i).getData());
              }
           }
       }).to("mock:searchResult");
   }
};
----

[[BookComponentAppendix-Example3:PerformingsearchesusingaQueryProcessor]]
Example 3: Performing searches using a Query Processor
++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {            
        try {
            from("direct:start").
                setHeader("QUERY", constant("Rodney Dangerfield")).
                process(new LuceneQueryProcessor("target/stdindexDir", analyzer, null, 20)).
                to("direct:next");
        } catch (Exception e) {
            e.printStackTrace();
        }
                
        from("direct:next").process(new Processor() {
            public void process(Exchange exchange) throws Exception {
                Hits hits = exchange.getIn().getBody(Hits.class);
                printResults(hits);
            }
                    
            private void printResults(Hits hits) {
                LOG.debug("Number of hits: " + hits.getNumberOfHits());
                for (int i = 0; i < hits.getNumberOfHits(); i++) {
                    LOG.debug("Hit " + i + " Index Location:" + hits.getHit().get(i).getHitLocation());
                    LOG.debug("Hit " + i + " Score:" + hits.getHit().get(i).getScore());
                    LOG.debug("Hit " + i + " Data:" + hits.getHit().get(i).getData());
                }
            }
       }).to("mock:searchResult");
   }
};
----

[[BookComponentAppendix-MailComponent]]
Mail Component
~~~~~~~~~~~~~~

The mail component provides access to Email via Spring's Mail support
and the underlying JavaMail system.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-mail</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency> Geronimo
mail .jar

We have discovered that the geronimo mail `.jar` (v1.6) has a bug when
polling mails with attachments. It cannot correctly identify the
`Content-Type`. So, if you attach a `.jpeg` file to a mail and you poll
it, the `Content-Type` is resolved as `text/plain` and not as
`image/jpeg`. For that reason, we have added an
`org.apache.camel.component.ContentTypeResolver` SPI interface which
enables you to provide your own implementation and fix this bug by
returning the correct Mime type based on the file name. So if the file
name ends with `jpeg/jpg`, you can return `image/jpeg`.

You can set your custom resolver on the `MailComponent` instance or on
the `MailEndpoint` instance.

POP3 or IMAP

POP3 has some limitations and end users are encouraged to use IMAP if
possible.

Using mock-mail for testing

You can use a mock framework for unit testing, which allows you to test
without the need for a real mail server. However you should remember to
not include the mock-mail when you go into production or other
environments where you need to send mails to a real mail server. Just
the presence of the mock-javamail.jar on the classpath means that it
will kick in and avoid sending the mails.

[[BookComponentAppendix-URIformat.38]]
URI format
^^^^^^^^^^

Mail endpoints can have one of the following URI formats (for the
protocols, SMTP, POP3, or IMAP, respectively):

smtp://[username@]host[:port][?options]
pop3://[username@]host[:port][?options]
imap://[username@]host[:port][?options]

The mail component also supports secure variants of these protocols
(layered over SSL). You can enable the secure protocols by adding `s` to
the scheme:

smtps://[username@]host[:port][?options]
pop3s://[username@]host[:port][?options]
imaps://[username@]host[:port][?options]

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Sampleendpoints]]
Sample endpoints
++++++++++++++++

Typically, you specify a URI with login credentials as follows (taking
SMTP as an example):

smtp://[username@]host[:port][?password=somepwd]

Alternatively, it is possible to specify both the user name and the
password as query options:

smtp://host[:port]?password=somepwd&username=someuser

For example:

smtp://mycompany.mailserver:30?password=tiger&username=scott

[[BookComponentAppendix-DefaultPortsDefaultports]]
DefaultPortsDefault ports
+++++++++++++++++++++++++

Default port numbers are supported. If the port number is omitted, Camel
determines the port number to use based on the protocol.

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=============================
|Protocol |Default Port Number
|`SMTP` |`25`
|`SMTPS` |`465`
|`POP3` |`110`
|`POP3S` |`995`
|`IMAP` |`143`
|`IMAPS` |`993`
|=============================

[[BookComponentAppendix-Options.31]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Property |Default |Description
|`host` |  |The host name or IP address to connect to.

|`port` |See link:mail.html[#DefaultPorts] |The TCP port number to
connect on.

|`username` |  |The user name on the email server.

|`password` |`null` |The password on the email server.

|`ignoreUriScheme` |`false` |If `false`, Camel uses the scheme to
determine the transport protocol (POP, IMAP, SMTP etc.)

|`contentType` |`text/plain` |The mail message content type. Use
`text/html` for HTML mails.

|`folderName` |`INBOX` |The folder to poll.

|`destination` |`username@host` |*@deprecated* Use the `to` option
instead. The `TO` recipients (receivers of the email).

|`to` |`username@host` |The TO recipients (the receivers of the mail).
Separate multiple email addresses with a comma. Email addresses
containing special characters such as "&" will need to be handled
differently - see
link:how-do-i-configure-password-options-on-camel-endpoints-without-the-value-being-encoded.html[How
do I configure password options on Camel endpoints without the value
being encoded].

|`replyTo` |`alias@host` |As of *Camel 2.8.4, 2.9.1+*, the Reply-To
recipients (the receivers of the response mail). Separate multiple email
addresses with a comma.

|`cc` |`null` |The CC recipients (the receivers of the mail). Separate
multiple email addresses with a comma.

|`bcc` |`null` |The BCC recipients (the receivers of the mail). Separate
multiple email addresses with a comma.

|`from` |`camel@localhost` |The FROM email address.

|`subject` |  |As of *Camel 2.3*, the Subject of the message being sent.
Note: Setting the subject in the header takes precedence over this
option.

|`peek` |`true` |*Camel 2.11.3/2.12.2:* Consumer only. Will mark the
`javax.mail.Message` as peeked before processing the mail message. This
applies to `IMAPMessage` messages types only. By using peek the mail
will not be eager marked as `SEEN` on the mail server, which allows us
to rollback the mail message if there is an error processing in Camel.

|`delete` |`false` |Deletes the messages after they have been processed.
This is done by setting the `DELETED` flag on the mail message. If
`false`, the `SEEN` flag is set instead. As of *Camel 2.10* you can
override this configuration option by setting a header with the key
`delete` to determine if the mail should be deleted or not.

|`unseen` |`true` |It is possible to configure a consumer endpoint so
that it processes only unseen messages (that is, new messages) or all
messages. Note that Camel always skips deleted messages. The default
option of `true` will filter to only unseen messages. POP3 does not
support the `SEEN` flag, so this option is not supported in POP3; use
IMAP instead. *Important:* This option is *not* in use if you also use
`searchTerm` options. Instead if you want to disable unseen when using
`searchTerm`'s then add `searchTerm.unseen=false` as a term.

|`copyTo` |`null` |*Camel 2.10:* Consumer only. After processing a mail
message, it can be copied to a mail folder with the given name. You can
override this configuration value, with a header with the key `copyTo`,
allowing you to copy messages to folder names configured at runtime.

|`fetchSize` |`-1` |Sets the maximum number of messages to consume
during a poll. This can be used to avoid overloading a mail server, if a
mailbox folder contains a lot of messages. Default value of `-1` means
no fetch size and all messages will be consumed. Setting the value to 0
is a special corner case, where Camel will not consume any messages at
all.

|`alternativeBodyHeader` |`CamelMailAlternativeBody` |Specifies the key
to an IN message header that contains an alternative email body. For
example, if you send emails in `text/html` format and want to provide an
alternative mail body for non-HTML email clients, set the alternative
mail body with this key as a header.

|`debugMode` |`false` |Enable debug mode on the underlying mail
framework. The SUN Mail framework logs the debug messages to
`System.out` by default.

|`connectionTimeout` |`30000` |The connection timeout in milliseconds.
Default is 30 seconds.

|`consumer.initialDelay` |`1000` |Milliseconds before the polling
starts.

|`consumer.delay` |`60000` |Camel will poll the mailbox only once a
minute by default to avoid overloading the mail server.

|`consumer.useFixedDelay` |`false` |Set to `true` to use a fixed delay
between polls, otherwise fixed rate is used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.

|`disconnect` |`false` |*Camel 2.8.3/2.9:* Whether the consumer should
disconnect after polling. If enabled this forces Camel to connect on
each poll.

|`closeFolder` |`true` |*Camel 2.10.4:* Whether the consumer should
close the folder after polling. Setting this option to `false` and
having `disconnect=false` as well, then the consumer keep the folder
open between polls.

|`mail.XXX` |`null` |Set any
http://java.sun.com/products/javamail/javadocs/index.html[additional
java mail properties]. For instance if you want to set a special
property when using POP3 you can now provide the option directly in the
URI such as: `mail.pop3.forgettopheaders=true`. You can set multiple
such options, for example:
`mail.pop3.forgettopheaders=true&mail.mime.encodefilename=true`.

|`mapMailMessage` |`true` |*Camel 2.8:* Specifies whether Camel should
map the received mail message to Camel body/headers. If set to true, the
body of the mail message is mapped to the body of the Camel IN message
and the mail headers are mapped to IN headers. If this option is set to
false then the IN message contains a raw `javax.mail.Message`. You can
retrieve this raw message by calling
`exchange.getIn().getBody(javax.mail.Message.class)`.

|`maxMessagesPerPoll` |`0` |Specifies the maximum number of messages to
gather per poll. By default, no maximum is set. Can be used to set a
limit of e.g. 1000 to avoid downloading thousands of files when the
server starts up. Set a value of 0 or negative to disable this option.

|`javaMailSender` |`null` |Specifies a pluggable
org.apache.camel.component.mail.JavaMailSender instance in order to use
a custom email implementation.

|`ignoreUnsupportedCharset` |`false` |Option to let Camel ignore
unsupported charset in the local JVM when sending mails. If the charset
is unsupported then `charset=XXX` (where `XXX` represents the
unsupported charset) is removed from the `content-type` and it relies on
the platform default instead.

|`sslContextParameters` |`null` |*Camel 2.10:* Reference to a
`org.apache.camel.util.jsse.SSLContextParameters` in the
http://camel.apache.org/registry.html[Registry].  This reference
overrides any configured SSLContextParameters at the component level. 
See
http://camel.apache.org/http4.html#HTTP4-UsingtheJSSEConfigurationUtility[Using
the JSSE Configuration Utility].

|`searchTerm` |`null` |*Camel 2.11:* Refers to a
`javax.mail.search.SearchTerm` which allows to filter mails based on
search criteria such as subject, body, from, sent after a certain date
etc. See further below for examples.

|`searchTerm.xxx` |`null` |*Camel 2.11:* To configure search terms
directly from the endpoint uri, which supports a limited number of terms
defined by the `org.apache.camel.component.mail.SimpleSearchTerm` class.
See further below for examples.

|`sortTerm` |`null` a|
*Camel 2.15:* To configure the sortTerms that IMAP supports to sort the
searched mails***.*** You may need to define an array of

`com.sun.mail.imap.sortTerm` in the registry first and #name to
reference it in this URI option.

*Camel 2.16:* You can also specify a comma separated list of sort terms
on the URI that Camel will convert internally. For example, to sort
descending by date you would use `sortTerm=reverse,date`. You can use
any of the sort terms defined in
https://javamail.java.net/nonav/docs/api/com/sun/mail/imap/SortTerm.html[com.sun.mail.imap.SortTerm].

|`postProcessAction` |`null` |*Camel 2.15:* Refers to
a`org.apache.camel.component.mail.``MailBoxPostProcessAction` for doing
post processing tasks on the mailbox once the normal processing ended.

|`skipFailedMessage` |`false` |*Camel 2.15.1:* If the mail consumer
cannot retrieve a given mail message, then this option allows to skip
the message and move on to retrieve the next mail message. The default
behavior would be the consumer throws an exception and no mails from the
batch would be able to be routed by Camel.

|`handleFailedMessage` |`false` |*Camel 2.15.1:* If the mail consumer
cannot retrieve a given mail message, then this option allows to handle
the caused exception by the consumer's error handler. By enable the
bridge error handler on the consumer, then the Camel routing error
handler can handle the exception instead. The default behavior would be
the consumer throws an exception and no mails from the batch would be
able to be routed by Camel.

a|
....
dummyTrustManager
....

 |`false` |**Camel 2.17:**To use a dummy security setting for trusting
all certificates. Should only be used for development mode, and not
production.

|`idempotentRepository` |`null` |*Camel 2.17:* A pluggable repository
org.apache.camel.spi.IdempotentRepository which allows to cluster
consuming from the same mailbox, and let the repository coordinate
whether a mail message is valid for the consumer to process.

|`idempotentRepositoryRemoveOnCommit` |`true` |*Camel 2.17:* When using
idempotent repository, then when the mail message has been successfully
processed and is committed, should the message id be removed from the
idempotent repository (default) or be kept in the repository. By default
its assumed the message id is unique and has no value to be kept in the
repository, because the mail message will be marked as seen/moved or
deleted to prevent it from being consumed again. And therefore having
the message id stored in the idempotent repository has little value.
However this option allows to store the message id, for whatever reason
you may have.

|`mailUidGenerator` |  |*Camel 2.17:* A pluggable MailUidGenerator that
allows to use custom logic to generate UUID of the mail message.
|=======================================================================

[[BookComponentAppendix-SSLsupport]]
SSL support
^^^^^^^^^^^

The underlying mail framework is responsible for providing SSL support.
 You may either configure SSL/TLS support by completely specifying the
necessary Java Mail API configuration options, or you may provide a
configured SSLContextParameters through the component or endpoint
configuration.

[[BookComponentAppendix-UsingtheJSSEConfigurationUtility.4]]
Using the JSSE Configuration Utility
++++++++++++++++++++++++++++++++++++

As of *Camel 2.10*, the mail component supports SSL/TLS configuration
through the link:camel-configuration-utilities.html[Camel JSSE
Configuration Utility].  This utility greatly decreases the amount of
component specific code you need to write and is configurable at the
endpoint and component levels.  The following examples demonstrate how
to use the utility with the mail component.

[[BookComponentAppendix-Programmaticconfigurationoftheendpoint.1]]
Programmatic configuration of the endpoint

KeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("/users/home/server/truststore.jks");
ksp.setPassword("keystorePassword"); TrustManagersParameters tmp = new
TrustManagersParameters(); tmp.setKeyStore(ksp); SSLContextParameters
scp = new SSLContextParameters(); scp.setTrustManagers(tmp); Registry
registry = ... registry.bind("sslContextParameters", scp); ... from(...)
&nbsp; &nbsp;
.to("smtps://smtp.google.com?username=user@gmail.com&password=password&sslContextParameters=#sslContextParameters");

[[BookComponentAppendix-SpringDSLbasedconfigurationofendpoint.3]]
Spring DSL based configuration of endpoint

xml... <camel:sslContextParameters id="sslContextParameters">
<camel:trustManagers> <camel:keyStore
resource="/users/home/server/truststore.jks"
password="keystorePassword"/> </camel:trustManagers>
</camel:sslContextParameters>... ... <to
uri="smtps://smtp.google.com?username=user@gmail.com&password=password&sslContextParameters=#sslContextParameters"/>...

[[BookComponentAppendix-ConfiguringJavaMailDirectly]]
Configuring JavaMail Directly
+++++++++++++++++++++++++++++

Camel uses SUN JavaMail, which only trusts certificates issued by well
known Certificate Authorities (the default JVM trust configuration). If
you issue your own certificates, you have to import the CA certificates
into the JVM's Java trust/key store files, override the default JVM
trust/key store files (see `SSLNOTES.txt` in JavaMail for details).

[[BookComponentAppendix-MailMessageContent]]
Mail Message Content
^^^^^^^^^^^^^^^^^^^^

Camel uses the message exchange's IN body as the
http://java.sun.com/javaee/5/docs/api/javax/mail/internet/MimeMessage.html[MimeMessage]
text content. The body is converted to `String.class`.

Camel copies all of the exchange's IN headers to the
http://java.sun.com/javaee/5/docs/api/javax/mail/internet/MimeMessage.html[MimeMessage]
headers. You may wish to
read link:how-to-avoid-sending-some-or-all-message-headers.html[How to
avoid sending some or all message headers] to prevent inadvertent data
"leaks" from your application.

The subject of the
http://java.sun.com/javaee/5/docs/api/javax/mail/internet/MimeMessage.html[MimeMessage]
can be configured using a header property on the IN message. The code
below demonstrates
this:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mail/src/test/java/org/apache/camel/component/mail/MailSubjectTest.java}The
same applies for other MimeMessage headers such as recipients, so you
can use a header property as
`To`:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mail/src/test/java/org/apache/camel/component/mail/MailUsingHeadersTest.java}*Since
Camel 2.11* When using the MailProducer the send the mail to server, you
should be able to get the message id of the
http://java.sun.com/javaee/5/docs/api/javax/mail/internet/MimeMessage.html[MimeMessage]
with the key `CamelMailMessageId` from the Camel message header.

[[BookComponentAppendix-Headerstakeprecedenceoverpre-configuredrecipients]]
Headers take precedence over pre-configured recipients
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The recipients specified in the message headers always take precedence
over recipients pre-configured in the endpoint URI. The idea is that if
you provide any recipients in the message headers, that is what you get.
The recipients pre-configured in the endpoint URI are treated as a
fallback.

In the sample code below, the email message is sent to
`davsclaus@apache.org`, because it takes precedence over the
pre-configured recipient, `info@mycompany.com`. Any `cc` and `bcc`
settings in the endpoint URI are also ignored and those recipients will
not receive any mail. The choice between headers and pre-configured
settings is all or nothing: the mail component _either_ takes the
recipients exclusively from the headers or exclusively from the
pre-configured settings. It is not possible to mix and match headers and
pre-configured settings.

java Map<String, Object> headers = new HashMap<String, Object>();
headers.put("to", "davsclaus@apache.org");
template.sendBodyAndHeaders("smtp://admin@localhost?to=info@mycompany.com",
"Hello World", headers);

[[BookComponentAppendix-Multiplerecipientsforeasierconfiguration]]
Multiple recipients for easier configuration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is possible to set multiple recipients using a comma-separated or a
semicolon-separated list. This applies both to header settings and to
settings in an endpoint URI. For example:

java Map<String, Object> headers = new HashMap<String, Object>();
headers.put("to", "davsclaus@apache.org ; jstrachan@apache.org ;
ningjiang@apache.org");

The preceding example uses a semicolon, `;`, as the separator character.

[[BookComponentAppendix-Settingsendernameandemail]]
Setting sender name and email
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can specify recipients in the format, `name <email>`, to include
both the name and the email address of the recipient.

For example, you define the following headers on the a
link:message.html[Message]:

Map headers = new HashMap(); map.put("To", "Claus Ibsen
<davsclaus@apache.org>"); map.put("From", "James Strachan
<jstrachan@apache.org>"); map.put("Subject", "Camel is cool");

[[BookComponentAppendix-JavaMailAPI(exSUNJavaMail)]]
JavaMail API (ex SUN JavaMail)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

https://java.net/projects/javamail/pages/Home[JavaMail API] is used
under the hood for consuming and producing mails. +
We encourage end-users to consult these references when using either
POP3 or IMAP protocol. Note particularly that POP3 has a much more
limited set of features than IMAP.

* https://javamail.java.net/nonav/docs/api/com/sun/mail/pop3/package-summary.html[JavaMail
POP3 API]
* https://javamail.java.net/nonav/docs/api/com/sun/mail/imap/package-summary.html[JavaMail
IMAP API]
* And generally about the
https://javamail.java.net/nonav/docs/api/javax/mail/Flags.html[MAIL
Flags]

[[BookComponentAppendix-Samples.7]]
Samples
^^^^^^^

We start with a simple route that sends the messages received from a JMS
queue as emails. The email account is the `admin` account on
`mymailserver.com`.

from("jms://queue:subscription").to("smtp://admin@mymailserver.com?password=secret");

In the next sample, we poll a mailbox for new emails once every minute.
Notice that we use the special `consumer` option for setting the poll
interval, `consumer.delay`, as 60000 milliseconds = 60 seconds.

from("imap://admin@mymailserver.com
password=secret&unseen=true&consumer.delay=60000") .to("seda://mails");

In this sample we want to send a mail to multiple
recipients:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mail/src/test/java/org/apache/camel/component/mail/MailRecipientsTest.java}

[[BookComponentAppendix-Sendingmailwithattachmentsample]]
Sending mail with attachment sample
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Attachments are not support by all Camel components

The _Attachments API_ is based on the Java Activation Framework and is
generally only used by the Mail API. Since many of the other Camel
components do not support attachments, the attachments could potentially
be lost as they propagate along the route. The rule of thumb, therefore,
is to add attachments just before sending a message to the mail
endpoint.

The mail component supports attachments. In the sample below, we send a
mail message containing a plain text message with a logo file
attachment.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mail/src/test/java/org/apache/camel/component/mail/MailAttachmentTest.java}

[[BookComponentAppendix-SSLsample]]
SSL sample
^^^^^^^^^^

In this sample, we want to poll our Google mail inbox for mails. To
download mail onto a local mail client, Google mail requires you to
enable and configure SSL. This is done by logging into your Google mail
account and changing your settings to allow IMAP access. Google have
extensive documentation on how to do this.

from("imaps://imap.gmail.com?username=YOUR_USERNAME@gmail.com&password=YOUR_PASSWORD"
+ "&delete=false&unseen=true&consumer.delay=60000").to("log:newmail");

The preceding route polls the Google mail inbox for new mails once every
minute and logs the received messages to the `newmail` logger
category. +
Running the sample with `DEBUG` logging enabled, we can monitor the
progress in the logs:

2008-05-08 06:32:09,640 DEBUG MailConsumer - Connecting to MailStore
imaps//imap.gmail.com:993 (SSL enabled), folder=INBOX 2008-05-08
06:32:11,203 DEBUG MailConsumer - Polling mailfolder:
imaps//imap.gmail.com:993 (SSL enabled), folder=INBOX 2008-05-08
06:32:11,640 DEBUG MailConsumer - Fetching 1 messages. Total 1 messages.
2008-05-08 06:32:12,171 DEBUG MailConsumer - Processing message:
messageNumber=[332], from=[James Bond <007@mi5.co.uk>],
to=YOUR_USERNAME@gmail.com], subject=[... 2008-05-08 06:32:12,187 INFO
newmail - Exchange[MailMessage: messageNumber=[332], from=[James Bond
<007@mi5.co.uk>], to=YOUR_USERNAME@gmail.com], subject=[...

[[BookComponentAppendix-Consumingmailswithattachmentsample]]
Consuming mails with attachment sample
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this sample we poll a mailbox and store all attachments from the
mails as files. First, we define a route to poll the mailbox. As this
sample is based on google mail, it uses the same route as shown in the
SSL sample:

from("imaps://imap.gmail.com?username=YOUR_USERNAME@gmail.com&password=YOUR_PASSWORD"
+ "&delete=false&unseen=true&consumer.delay=60000").process(new
MyMailProcessor());

Instead of logging the mail we use a processor where we can process the
mail from java code:

public void process(Exchange exchange) throws Exception \{ // the API is
a bit clunky so we need to loop Map<String, DataHandler> attachments =
exchange.getIn().getAttachments(); if (attachments.size() > 0) \{ for
(String name : attachments.keySet()) \{ DataHandler dh =
attachments.get(name); // get the file name String filename =
dh.getName(); // get the content and convert it to byte[] byte[] data =
exchange.getContext().getTypeConverter() .convertTo(byte[].class,
dh.getInputStream()); // write the data to a file FileOutputStream out =
new FileOutputStream(filename); out.write(data); out.flush();
out.close(); } } }

As you can see the API to handle attachments is a bit clunky but it's
there so you can get the `javax.activation.DataHandler` so you can
handle the attachments using standard API.

[[BookComponentAppendix-Howtosplitamailmessagewithattachments]]
How to split a mail message with attachments
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this example we consume mail messages which may have a number of
attachments. What we want to do is to use the
link:splitter.html[Splitter] EIP per individual attachment, to process
the attachments separately. For example if the mail message has 5
attachments, we want the link:splitter.html[Splitter] to process five
messages, each having a single attachment. To do this we need to provide
a custom link:expression.html[Expression] to the
link:splitter.html[Splitter] where we provide a List<Message> that
contains the five messages with the single attachment.

The code is provided out of the box in Camel 2.10 onwards in the
`camel-mail` component. The code is in the class:
`org.apache.camel.component.mail.SplitAttachmentsExpression`, which you
can find the source code
https://svn.apache.org/repos/asf/camel/trunk/components/camel-mail/src/main/java/org/apache/camel/component/mail/SplitAttachmentsExpression.java[here]

In the Camel route you then need to use this
link:expression.html[Expression] in the route as shown
below:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mail/src/test/java/org/apache/camel/component/mail/MailSplitAttachmentsTest.java}If
you use XML DSL then you need to declare a method call expression in the
link:splitter.html[Splitter] as shown below

xml<split> <method
beanType="org.apache.camel.component.mail.SplitAttachmentsExpression"/>
<to uri="mock:split"/> </split>

 

From Camel 2.16 onwards you can also split the attachments as byte[] to
be stored as the message body. This is done by creating the expression
with boolean true

SplitAttachmentsExpression split = SplitAttachmentsExpression(true);

And then use the expression with the splitter eip.

[[BookComponentAppendix-UsingcustomSearchTerm]]
Using custom SearchTerm
^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.11*

You can configure a `searchTerm` on the `MailEndpoint` which allows you
to filter out unwanted mails.

For example to filter mails to contain Camel in either Subject or Text
you can do as follows:

xml<route> <from
uri="imaps://mymailseerver?username=foo&password=secret&searchTerm.subjectOrBody=Camel"/>
<to uri="bean:myBean"/> </route>

Notice we use the `"searchTerm.subjectOrBody"` as parameter key to
indicate that we want to search on mail subject or body, to contain the
word "Camel". +
The class `org.apache.camel.component.mail.SimpleSearchTerm` has a
number of options you can configure:

Or to get the new unseen emails going 24 hours back in time you can do.
Notice the "now-24h" syntax. See the table below for more details.

xml<route> <from
uri="imaps://mymailseerver?username=foo&password=secret&searchTerm.fromSentDate=now-24h"/>
<to uri="bean:myBean"/> </route>

You can have multiple searchTerm in the endpoint uri configuration. They
would then be combined together using AND operator, eg so both
conditions must match. For example to get the last unseen emails going
back 24 hours which has Camel in the mail subject you can do:

xml<route> <from
uri="imaps://mymailseerver?username=foo&password=secret&searchTerm.subject=Camel&searchTerm.fromSentDate=now-24h"/>
<to uri="bean:myBean"/> </route> confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|unseen |`true` |Whether to limit by unseen mails only.

|subjectOrBody |`null` |To limit by subject or body to contain the word.

|subject |`null` |The subject must contain the word.

|body |`null` |The body must contain the word.

|from |`null` |The mail must be from a given email pattern.

|to |`null` |The mail must be to a given email pattern.

|fromSentDate |`null` |The mail must be sent after or equals (GE) a
given date. The date pattern is `yyyy-MM-dd HH:mm:SS`, eg use
`"2012-01-01 00:00:00"` to be from the year 2012 onwards. You can use
`"now"` for current timestamp. The "now" syntax supports an optional
offset, that can be specified as either + or - with a numeric value. For
example for last 24 hours, you can use `"now - 24h"` or without spaces
`"now-24h"`. Notice that Camel supports shorthands for hours, minutes,
and seconds.

|toSentDate |`null` |The mail must be sent before or equals (BE) a given
date. The date pattern is `yyyy-MM-dd HH:mm:SS`, eg use
`"2012-01-01 00:00:00"` to be before the year 2012. You can use `"now"`
for current timestamp. The "now" syntax supports an optional offset,
that can be specified as either + or - with a numeric value. For example
for last 24 hours, you can use `"now - 24h"` or without spaces
`"now-24h"`. Notice that Camel supports shorthands for hours, minutes,
and seconds.
|=======================================================================

The `SimpleSearchTerm` is designed to be easily configurable from a
POJO, so you can also configure it using a <bean> style in XML

<bean id="mySearchTerm"
class="org.apache.camel.component.mail.SimpleSearchTerm"> <property
name="subject" value="Order"/> <property name="to"
value="acme-order@acme.com"/> <property name="fromSentDate"
value="now"/> </bean>

You can then refer to this bean, using #beanId in your Camel route as
shown:

xml<route> <from
uri="imaps://mymailseerver?username=foo&password=secret&searchTerm=#mySearchTerm"/>
<to uri="bean:myBean"/> </route>

In Java there is a builder class to build compound
`SearchTerm}}s using the {{org.apache.camel.component.mail.SearchTermBuilder`
class. +
This allows you to build complex terms such as:

// we just want the unseen mails which is not spam SearchTermBuilder
builder = new SearchTermBuilder(); builder.unseen().body(Op.not,
"Spam").subject(Op.not, "Spam") // which was sent from either foo or bar
.from("foo@somewhere.com").from(Op.or, "bar@somewhere.com"); // .. and
we could continue building the terms SearchTerm term = builder.build();

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-MINAComponent]]
MINA Component
~~~~~~~~~~~~~~

*Deprecated*

Deprecated

This component is deprecated as the Apache Mina 1.x project is EOL.
Instead use link:mina2.html[MINA2] or link:netty.html[Netty] instead.

The *mina:* component is a transport for working with
http://mina.apache.org/[Apache MINA]

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-mina</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.39]]
URI format
^^^^^^^^^^

mina:tcp://hostname[:port][?options]
mina:udp://hostname[:port][?options] mina:vm://hostname[:port][?options]

You can specify a codec in the link:registry.html[Registry] using the
*codec* option. If you are using TCP and no codec is specified then the
`textline` flag is used to determine if text line based codec or object
serialization should be used instead. By default the object
serialization is used.

For UDP if no codec is specified the default uses a basic `ByteBuffer`
based codec.

The VM protocol is used as a direct forwarding mechanism in the same
JVM. See the
http://mina.apache.org/report/1.1/apidocs/org/apache/mina/transport/vmpipe/package-summary.html[MINA
VM-Pipe API documentation] for details.

A Mina producer has a default timeout value of 30 seconds, while it
waits for a response from the remote server.

In normal use, `camel-mina` only supports marshalling the body
content—message headers and exchange properties are not sent. +
However, the option, *transferExchange*, does allow you to transfer the
exchange itself over the wire. See options below.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.32]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default Value |Description
|`codec` |`null` |You can refer to a named `ProtocolCodecFactory`
instance in your link:registry.html[Registry] such as your Spring
`ApplicationContext`, which is then used for the marshalling.

|`codec` |`null` |You must use the `#` notation to look up your codec in
the link:registry.html[Registry]. For example, use `#myCodec` to look up
a bean with the `id` value, `myCodec`.

|`disconnect` |`false` |*Camel 2.3:* Whether or not to disconnect(close)
from Mina session right after use. Can be used for both consumer and
producer.

|`textline` |`false` |Only used for TCP. If no codec is specified, you
can use this flag to indicate a text line based codec; if not specified
or the value is `false`, then Object Serialization is assumed over TCP.

|`textlineDelimiter` |`DEFAULT` |Only used for TCP and if
*textline=true*. Sets the text line delimiter to use. Possible values
are: `DEFAULT`, `AUTO`, `WINDOWS`, `UNIX` or `MAC`. If none provided,
Camel will use `DEFAULT`. This delimiter is used to mark the end of
text.

|`sync` |`true` |Setting to set endpoint as one-way or request-response.

|`lazySessionCreation` |`true` |Sessions can be lazily created to avoid
exceptions, if the remote server is not up and running when the Camel
producer is started.

|`timeout` |`30000` |You can configure the timeout that specifies how
long to wait for a response from a remote server. The timeout unit is in
milliseconds, so 60000 is 60 seconds. The timeout is only used for Mina
producer.

|`encoding` |_JVM Default_ |You can configure the encoding (a
http://java.sun.com/j2se/1.5.0/docs/api/java/nio/charset/Charset.html[charset
name]) to use for the TCP textline codec and the UDP protocol. If not
provided, Camel will use the
http://java.sun.com/j2se/1.5.0/docs/api/java/nio/charset/Charset.html#defaultCharset()[JVM
default Charset].

|`transferExchange` |`false` |Only used for TCP. You can transfer the
exchange over the wire instead of just the body. The following fields
are transferred: In body, Out body, fault body, In headers, Out headers,
fault headers, exchange properties, exchange exception. This requires
that the objects are _serializable_. Camel will exclude any
non-serializable objects and log it at `WARN` level.

|`minaLogger` |`false` |You can enable the Apache MINA logging filter.
Apache MINA uses `slf4j` logging at `INFO` level to log all input and
output.

|`filters` |`null` a|
You can set a list of http://mina.apache.org/iofilter.html[Mina
IoFilters] to register. The `filters` value must be one of the
following:

* *Camel 2.2:* comma-separated list of bean references (e.g.
`#filterBean1,#filterBean2`) where each bean must be of type
`org.apache.mina.common.IoFilter`.
* *before Camel 2.2:* a reference to a bean of type
`List<org.apache.mina.common.IoFilter>`.

|`encoderMaxLineLength` |`-1` |As of 2.1, you can set the textline
protocol encoder max line length. By default the default value of Mina
itself is used which are `Integer.MAX_VALUE`.

|`decoderMaxLineLength` |`-1` |As of 2.1, you can set the textline
protocol decoder max line length. By default the default value of Mina
itself is used which are 1024.

|`producerPoolSize` |16 |The TCP producer is thread safe and supports
concurrency much better. This option allows you to configure the number
of threads in its thread pool for concurrent producers. *Note:* Camel
has a pooled service which ensured it was already thread safe and
supported concurrency already.

|`allowDefaultCodec` |`true` |The mina component installs a default
codec if both, `codec` is `null` and `textline` is `false`. Setting
`allowDefaultCodec` to `false` prevents the mina component from
installing a default codec as the first element in the filter chain.
This is useful in scenarios where another filter must be the first in
the filter chain, like the SSL filter.

|`disconnectOnNoReply` |`true` |*Camel 2.3:* If sync is enabled then
this option dictates MinaConsumer if it should disconnect where there is
no reply to send back.

|`noReplyLogLevel` |`WARN` |*Camel 2.3:* If sync is enabled this option
dictates MinaConsumer which logging level to use when logging a there is
no reply to send back. Values are: `FATAL, ERROR, INFO, DEBUG, OFF`.

|`clientMode` |`false` |*Camel 2.15:* Consumer only. If the `clientMode`
is true, mina consumer will connect the address as a TCP client.
|=======================================================================

[[BookComponentAppendix-Usingacustomcodec]]
Using a custom codec
^^^^^^^^^^^^^^^^^^^^

See the http://mina.apache.org/tutorial-on-protocolcodecfilter.html[Mina
documentation] how to write your own codec. To use your custom codec
with `camel-mina`, you should register your codec in the
link:registry.html[Registry]; for example, by creating a bean in the
Spring XML file. Then use the `codec` option to specify the bean ID of
your codec. See link:hl7.html[HL7] that has a custom codec.

[[BookComponentAppendix-Samplewithsync=false]]
Sample with sync=false
^^^^^^^^^^^^^^^^^^^^^^

In this sample, Camel exposes a service that listens for TCP connections
on port 6200. We use the *textline* codec. In our route, we create a
Mina consumer endpoint that listens on port 6200:

\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mina/src/test/java/org/apache/camel/component/mina/MinaConsumerTest.java}

As the sample is part of a unit test, we test it by sending some data to
it on port 6200.

\{snippet:id=e2|lang=java|url=camel/trunk/components/camel-mina/src/test/java/org/apache/camel/component/mina/MinaConsumerTest.java}

[[BookComponentAppendix-Samplewithsync=true]]
Sample with sync=true
^^^^^^^^^^^^^^^^^^^^^

In the next sample, we have a more common use case where we expose a TCP
service on port 6201 also use the textline codec. However, this time we
want to return a response, so we set the `sync` option to `true` on the
consumer.

\{snippet:id=e3|lang=java|url=camel/trunk/components/camel-mina/src/test/java/org/apache/camel/component/mina/MinaConsumerTest.java}

Then we test the sample by sending some data and retrieving the response
using the `template.requestBody()` method. As we know the response is a
`String`, we cast it to `String` and can assert that the response is, in
fact, something we have dynamically set in our processor code logic.

\{snippet:id=e4|lang=java|url=camel/trunk/components/camel-mina/src/test/java/org/apache/camel/component/mina/MinaConsumerTest.java}

[[BookComponentAppendix-SamplewithSpringDSL]]
Sample with Spring DSL
^^^^^^^^^^^^^^^^^^^^^^

Spring DSL can, of course, also be used for link:mina.html[MINA]. In the
sample below we expose a TCP server on port 5555:

xml <route> <from uri="mina:tcp://localhost:5555?textline=true"/> <to
uri="bean:myTCPOrderHandler"/> </route>

In the route above, we expose a TCP server on port 5555 using the
textline codec. We let the Spring bean with ID, `myTCPOrderHandler`,
handle the request and return a reply. For instance, the handler bean
could be implemented as follows:

java public String handleOrder(String payload) \{ ... return "Order: OK"
}

[[BookComponentAppendix-ConfiguringMinaendpointsusingSpringbeanstyle]]
Configuring Mina endpoints using Spring bean style
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Configuration of Mina endpoints is possible using regular Spring bean
style configuration in the Spring DSL.

However, in the underlying Apache Mina toolkit, it is relatively
difficult to set up the acceptor and the connector, because you can
_not_ use simple setters. To resolve this difficulty, we leverage the
`MinaComponent` as a Spring factory bean to configure this for us. If
you really need to configure this yourself, there are setters on the
`MinaEndpoint` to set these when needed.

The sample below shows the factory approach:

\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-mina/src/test/resources/org/apache/camel/component/mina/SpringMinaEndpointTest-context.xml}

And then we can refer to our endpoint directly in the route, as follows:

\{snippet:id=e2|lang=xml|url=camel/trunk/components/camel-mina/src/test/resources/org/apache/camel/component/mina/SpringMinaEndpointTest-context.xml}

[[BookComponentAppendix-ClosingSessionWhenComplete]]
Closing Session When Complete
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When acting as a server you sometimes want to close the session when,
for example, a client conversion is finished. To instruct Camel to close
the session, you should add a header with the key
`CamelMinaCloseSessionWhenComplete` set to a boolean `true` value.

For instance, the example below will close the session after it has
written the `bye` message back to the client:

java
from("mina:tcp://localhost:8080?sync=true&textline=true").process(new
Processor() \{ public void process(Exchange exchange) throws Exception
\{ String body = exchange.getIn().getBody(String.class);
exchange.getOut().setBody("Bye " + body);
exchange.getOut().setHeader(MinaConstants.MINA_CLOSE_SESSION_WHEN_COMPLETE,
true); } });

[[BookComponentAppendix-GettheIoSessionformessage]]
Get the IoSession for message
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available since Camel 2.1* +
You can get the IoSession from the message header with this key
MinaEndpoint.HEADER_MINA_IOSESSION, and also get the local host address
with the key MinaEndpoint.HEADER_LOCAL_ADDRESS and remote host address
with the key MinaEndpoint.HEADER_REMOTE_ADDRESS.

[[BookComponentAppendix-ConfiguringMinafilters]]
Configuring Mina filters
^^^^^^^^^^^^^^^^^^^^^^^^

Filters permit you to use some Mina Filters, such as `SslFilter`. You
can also implement some customized filters. Please note that `codec` and
`logger` are also implemented as Mina filters of type, `IoFilter`. Any
filters you may define are appended to the end of the filter chain; that
is, after `codec` and `logger`.

If using the `SslFilter` you need to add the `mina-filter-ssl` JAR to
the classpath.

For instance, the example below will send a keep-alive message after 10
seconds of inactivity:

javapublic class KeepAliveFilter extends IoFilterAdapter \{ @Override
public void sessionCreated(NextFilter nextFilter, IoSession session)
throws Exception \{ session.setIdleTime(IdleStatus.BOTH_IDLE, 10);
nextFilter.sessionCreated(session); } @Override public void
sessionIdle(NextFilter nextFilter, IoSession session, IdleStatus status)
throws Exception \{ session.write("NOOP"); // NOOP is a FTP command for
keep alive nextFilter.sessionIdle(session, status); } }

As Camel Mina may use a request-reply scheme, the endpoint as a client
would like to drop some message, such as greeting when the connection is
established. For example, when you connect to an FTP server, you will
get a `220` message with a greeting (`220 Welcome to Pure-FTPd`). If you
don't drop the message, your request-reply scheme will be broken.

javapublic class DropGreetingFilter extends IoFilterAdapter \{ @Override
public void messageReceived(NextFilter nextFilter, IoSession session,
Object message) throws Exception \{ if (message instanceof String) \{
String ftpMessage = (String) message; // "220" is given as greeting.
"200 Zzz" is given as a response to "NOOP" (keep alive) if
(ftpMessage.startsWith("220") || or ftpMessage.startsWith("200 Zzz")) \{
// Dropping greeting return; } } nextFilter.messageReceived(session,
message); } }

Then, you can configure your endpoint using Spring DSL:

xml<bean id="myMinaFactory"
class="org.apache.camel.component.mina.MinaComponent"> <constructor-arg
index="0" ref="camelContext" /> </bean> <bean id="myMinaEndpoint"
factory-bean="myMinaFactory" factory-method="createEndpoint">
<constructor-arg index="0" ref="myMinaConfig"/> </bean> <bean
id="myMinaConfig"
class="org.apache.camel.component.mina.MinaConfiguration"> <property
name="protocol" value="tcp" /> <property name="host" value="localhost"
/> <property name="port" value="2121" /> <property name="sync"
value="true" /> <property name="minaLogger" value="true" /> <property
name="filters" ref="listFilters"/> </bean> <bean id="listFilters"
class="java.util.ArrayList" > <constructor-arg> <list
value-type="org.apache.mina.common.IoFilter"> <bean
class="com.example.KeepAliveFilter"/> <bean
class="com.example.DropGreetingFilter"/> </list> </constructor-arg>
</bean>

link:endpoint-see-also.html[Endpoint See Also]

* link:mina2.html[MINA2]
* link:netty.html[Netty]

[[BookComponentAppendix-MockComponent]]
Mock Component
~~~~~~~~~~~~~~

link:testing-summary-include.html[Testing Summary Include]

The Mock component provides a powerful declarative testing mechanism,
which is similar to http://www.jmock.org[jMock]http://jmock.org[] in
that it allows declarative expectations to be created on any Mock
endpoint before a test begins. Then the test is run, which typically
fires messages to one or more endpoints, and finally the expectations
can be asserted in a test case to ensure the system worked as expected.

This allows you to test various things like:

* The correct number of messages are received on each endpoint,
* The correct payloads are received, in the right order,
* Messages arrive on an endpoint in order, using some
link:expression.html[Expression] to create an order testing function,
* Messages arrive match some kind of link:predicate.html[Predicate] such
as that specific headers have certain values, or that parts of the
messages match some predicate, such as by evaluating an
link:xpath.html[XPath] or link:xquery.html[XQuery]
link:expression.html[Expression].

*Note* that there is also the link:test.html[Test endpoint] which is a
Mock endpoint, but which uses a second endpoint to provide the list of
expected message bodies and automatically sets up the Mock endpoint
assertions. In other words, it's a Mock endpoint that automatically sets
up its assertions from some sample messages in a link:file2.html[File]
or link:jpa.html[database], for example.

Mock endpoints keep received Exchanges in memory indefinitely

Remember that Mock is designed for testing. When you add Mock endpoints
to a route, each link:exchange.html[Exchange] sent to the endpoint will
be stored (to allow for later validation) in memory until explicitly
reset or the JVM is restarted. If you are sending high volume and/or
large messages, this may cause excessive memory use. If your goal is to
test deployable routes inline, consider using
link:notifybuilder.html[NotifyBuilder] or
link:advicewith.html[AdviceWith] in your tests instead of adding Mock
endpoints to routes directly.

From Camel 2.10 onwards there are two new options `retainFirst`, and
`retainLast` that can be used to limit the number of messages the Mock
endpoints keep in memory.

[[BookComponentAppendix-URIformat.40]]
URI format
^^^^^^^^^^

mock:someName[?options]

Where *someName* can be any string that uniquely identifies the
endpoint.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.33]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`reportGroup` |`null` |A size to use a link:log.html[throughput logger]
for reporting

|`retainFirst` |  |*Camel 2.10:* To only keep first X number of messages
in memory.

|`retainLast` |  |*Camel 2.10:* To only keep last X number of messages
in memory.
|=======================================================================

[[BookComponentAppendix-SimpleExample]]
Simple Example
^^^^^^^^^^^^^^

Here's a simple example of Mock endpoint in use. First, the endpoint is
resolved on the context. Then we set an expectation, and then, after the
test has run, we assert that our expectations have been met.

MockEndpoint resultEndpoint = context.resolveEndpoint("mock:foo",
MockEndpoint.class); resultEndpoint.expectedMessageCount(2); // send
some messages ... // now lets assert that the mock:foo endpoint received
2 messages resultEndpoint.assertIsSatisfied();

You typically always call the
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#assertIsSatisfied()[assertIsSatisfied()
method] to test that the expectations were met after running a test.

Camel will by default wait 10 seconds when the `assertIsSatisfied()` is
invoked. This can be configured by setting the
`setResultWaitTime(millis)` method.

[[BookComponentAppendix-UsingassertPeriod]]
Using assertPeriod
++++++++++++++++++

*Available as of Camel 2.7* +
When the assertion is satisfied then Camel will stop waiting and
continue from the `assertIsSatisfied` method. That means if a new
message arrives on the mock endpoint, just a bit later, that arrival
will not affect the outcome of the assertion. Suppose you do want to
test that no new messages arrives after a period thereafter, then you
can do that by setting the `setAssertPeriod` method, for example:

MockEndpoint resultEndpoint = context.resolveEndpoint("mock:foo",
MockEndpoint.class); resultEndpoint.setAssertPeriod(5000);
resultEndpoint.expectedMessageCount(2); // send some messages ... // now
lets assert that the mock:foo endpoint received 2 messages
resultEndpoint.assertIsSatisfied();

[[BookComponentAppendix-Settingexpectations]]
Setting expectations
^^^^^^^^^^^^^^^^^^^^

You can see from the javadoc of
httphttp://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html[MockEndpoint]
the various helper methods you can use to set expectations. The main
methods are as follows:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Method |Description
|http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedMessageCount(int)[expectedMessageCount(int)]
|To define the expected message count on the endpoint.

|http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedMinimumMessageCount(int)[expectedMinimumMessageCount(int)]
|To define the minimum number of expected messages on the endpoint.

|http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedBodiesReceived(java.lang.Object...)[expectedBodiesReceived(...)]
|To define the expected bodies that should be received (in order).

|http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedHeaderReceived(java.lang.String,%20java.lang.String)[expectedHeaderReceived(...)]
|To define the expected header that should be received

|http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectsAscending(org.apache.camel.Expression)[expectsAscending(Expression)]
|To add an expectation that messages are received in order, using the
given link:expression.html[Expression] to compare messages.

|http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectsDescending(org.apache.camel.Expression)[expectsDescending(Expression)]
|To add an expectation that messages are received in order, using the
given link:expression.html[Expression] to compare messages.

|http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectsNoDuplicates(org.apache.camel.Expression)[expectsNoDuplicates(Expression)]
|To add an expectation that no duplicate messages are received; using an
link:expression.html[Expression] to calculate a unique identifier for
each message. This could be something like the `JMSMessageID` if using
JMS, or some unique reference number within the message.
|=======================================================================

Here's another example:

resultEndpoint.expectedBodiesReceived("firstMessageBody",
"secondMessageBody", "thirdMessageBody");

[[BookComponentAppendix-Addingexpectationstospecificmessages]]
Adding expectations to specific messages
++++++++++++++++++++++++++++++++++++++++

In addition, you can use the
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#message(int)[message(int
messageIndex)] method to add assertions about a specific message that is
received.

For example, to add expectations of the headers or body of the first
message (using zero-based indexing like `java.util.List`), you can use
the following code:

resultEndpoint.message(0).header("foo").isEqualTo("bar");

There are some examples of the Mock endpoint in use in the
http://svn.apache.org/viewvc/camel/trunk/camel-core/src/test/java/org/apache/camel/processor/[camel-core
processor tests].

[[BookComponentAppendix-Mockingexistingendpoints]]
Mocking existing endpoints
^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.7*

Camel now allows you to automatically mock existing endpoints in your
Camel routes.

How it works

*Important:* The endpoints are still in action. What happens differently
is that a link:mock.html[Mock] endpoint is injected and receives the
message first and then delegates the message to the target endpoint. You
can view this as a kind of intercept and delegate or endpoint listener.

Suppose you have the given route below:

\{snippet:id=route|title=Route|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/processor/interceptor/AdviceWithMockEndpointsTest.java}

You can then use the `adviceWith` feature in Camel to mock all the
endpoints in a given route from your unit test, as shown below:

\{snippet:id=e1|title=adviceWith mocking all
endpoints|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/processor/interceptor/AdviceWithMockEndpointsTest.java}

Notice that the mock endpoints is given the uri `mock:<endpoint>`, for
example `mock:direct:foo`. Camel logs at `INFO` level the endpoints
being mocked:

INFO Adviced endpoint [direct://foo] with mock endpoint
[mock:direct:foo] Mocked endpoints are without parameters

Endpoints which are mocked will have their parameters stripped off. For
example the endpoint "log:foo?showAll=true" will be mocked to the
following endpoint "mock:log:foo". Notice the parameters have been
removed.

Its also possible to only mock certain endpoints using a pattern. For
example to mock all `log` endpoints you do as shown:

\{snippet:id=e2|lang=java|title=adviceWith mocking only log endpoints
using a
pattern|url=camel/trunk/camel-core/src/test/java/org/apache/camel/processor/interceptor/AdviceWithMockEndpointsTest.java}

The pattern supported can be a wildcard or a regular expression. See
more details about this at link:intercept.html[Intercept] as its the
same matching function used by Camel.

Mind that mocking endpoints causes the messages to be copied when they
arrive on the mock. +
That means Camel will use more memory. This may not be suitable when you
send in a lot of messages.

[[BookComponentAppendix-Mockingexistingendpointsusingthecamel-testcomponent]]
Mocking existing endpoints using the `camel-test` component
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Instead of using the `adviceWith` to instruct Camel to mock endpoints,
you can easily enable this behavior when using the `camel-test` Test
Kit. +
The same route can be tested as follows. Notice that we return `"*"`
from the `isMockEndpoints` method, which tells Camel to mock all
endpoints. +
If you only want to mock all `log` endpoints you can return `"log*"`
instead.

\{snippet:id=e1|lang=java|title=isMockEndpoints using camel-test
kit|url=camel/trunk/components/camel-test/src/test/java/org/apache/camel/test/patterns/IsMockEndpointsJUnit4Test.java}

[[BookComponentAppendix-MockingexistingendpointswithXMLDSL]]
Mocking existing endpoints with XML DSL
+++++++++++++++++++++++++++++++++++++++

If you do not use the `camel-test` component for unit testing (as shown
above) you can use a different approach when using XML files for
routes. +
The solution is to create a new XML file used by the unit test and then
include the intended XML file which has the route you want to test.

Suppose we have the route in the `camel-route.xml` file:

\{snippet:id=e1|lang=xml|title=camel-route.xml|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/spring/mock/camel-route.xml}

Then we create a new XML file as follows, where we include the
`camel-route.xml` file and define a spring bean with the class
`org.apache.camel.impl.InterceptSendToMockEndpointStrategy` which tells
Camel to mock all endpoints:

\{snippet:id=e1|lang=xml|title=test-camel-route.xml|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/spring/mock/InterceptSendToMockEndpointStrategyTest.xml}

Then in your unit test you load the new XML file
(`test-camel-route.xml`) instead of `camel-route.xml`.

To only mock all link:log.html[Log] endpoints you can define the pattern
in the constructor for the bean:

xml<bean id="mockAllEndpoints"
class="org.apache.camel.impl.InterceptSendToMockEndpointStrategy">
<constructor-arg index="0" value="log*"/> </bean>

[[BookComponentAppendix-Mockingendpointsandskipsendingtooriginalendpoint]]
Mocking endpoints and skip sending to original endpoint
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.10*

Sometimes you want to easily mock and skip sending to a certain
endpoints. So the message is detoured and send to the mock endpoint
only. From Camel 2.10 onwards you can now use the `mockEndpointsAndSkip`
method using link:advicewith.html[AdviceWith] or the
https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=Test+Kit&linkCreation=true&fromPageId=52081[Test
Kit]. The example below will skip sending to the two endpoints
`"direct:foo"`, and `"direct:bar"`.

\{snippet:id=e1|lang=java|title=adviceWith mock and skip sending to
endpoints|url=camel/trunk/camel-core/src/test/java/org/apache/camel/processor/interceptor/AdviceWithMockMultipleEndpointsWithSkipTest.java}

The same example using the link:testing.html[Test Kit]

\{snippet:id=e1|lang=java|title=isMockEndpointsAndSkip using camel-test
kit|url=camel/trunk/components/camel-test/src/test/java/org/apache/camel/test/patterns/IsMockEndpointsAndSkipJUnit4Test.java}

[[BookComponentAppendix-Limitingthenumberofmessagestokeep]]
Limiting the number of messages to keep
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.10*

The link:mock.html[Mock] endpoints will by default keep a copy of every
link:exchange.html[Exchange] that it received. So if you test with a lot
of messages, then it will consume memory. +
From Camel 2.10 onwards we have introduced two options `retainFirst` and
`retainLast` that can be used to specify to only keep N'th of the first
and/or last link:exchange.html[Exchange]s.

For example in the code below, we only want to retain a copy of the
first 5 and last 5 link:exchange.html[Exchange]s the mock receives.

MockEndpoint mock = getMockEndpoint("mock:data");
mock.setRetainFirst(5); mock.setRetainLast(5);
mock.expectedMessageCount(2000); ... mock.assertIsSatisfied();

Using this has some limitations. The `getExchanges()` and
`getReceivedExchanges()` methods on the `MockEndpoint` will return only
the retained copies of the link:exchange.html[Exchange]s. So in the
example above, the list will contain 10 link:exchange.html[Exchange]s;
the first five, and the last five. +
The `retainFirst` and `retainLast` options also have limitations on
which expectation methods you can use. For example the expectedXXX
methods that work on message bodies, headers, etc. will only operate on
the retained messages. In the example above they can test only the
expectations on the 10 retained messages.

[[BookComponentAppendix-Testingwitharrivaltimes]]
Testing with arrival times
^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.7*

The link:mock.html[Mock] endpoint stores the arrival time of the message
as a property on the link:exchange.html[Exchange].

Date time = exchange.getProperty(Exchange.RECEIVED_TIMESTAMP,
Date.class);

You can use this information to know when the message arrived on the
mock. But it also provides foundation to know the time interval between
the previous and next message arrived on the mock. You can use this to
set expectations using the `arrives` DSL on the link:mock.html[Mock]
endpoint.

For example to say that the first message should arrive between 0-2
seconds before the next you can do:

mock.message(0).arrives().noLaterThan(2).seconds().beforeNext();

You can also define this as that 2nd message (0 index based) should
arrive no later than 0-2 seconds after the previous:

mock.message(1).arrives().noLaterThan(2).seconds().afterPrevious();

You can also use between to set a lower bound. For example suppose that
it should be between 1-4 seconds:

mock.message(1).arrives().between(1, 4).seconds().afterPrevious();

You can also set the expectation on all messages, for example to say
that the gap between them should be at most 1 second:

mock.allMessages().arrives().noLaterThan(1).seconds().beforeNext(); time
units

In the example above we use `seconds` as the time unit, but Camel offers
`milliseconds`, and `minutes` as well.

link:endpoint-see-also.html[Endpoint See Also]

* link:spring-testing.html[Spring Testing]
* link:testing.html[Testing]

[[BookComponentAppendix-MSVComponent]]
MSV Component
~~~~~~~~~~~~~

The MSV component performs XML validation of the message body using the
https://msv.dev.java.net/[MSV Library] and any of the supported XML
schema languages, such as http://www.w3.org/XML/Schema[XML Schema] or
http://relaxng.org/[RelaxNG XML Syntax].

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-msv</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

Note that the link:jing.html[Jing] component also supports
http://relaxng.org/compact-tutorial-20030326.html[RelaxNG Compact
Syntax]

[[BookComponentAppendix-URIformat.41]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
msv:someLocalOrRemoteResource[?options]
----

Where *someLocalOrRemoteResource* is some URL to a local resource on the
classpath or a full URL to a remote resource or resource on the file
system. For example

[source,brush:,java;,gutter:,false;,theme:,Default]
----
msv:org/foo/bar.rng
msv:file:../foo/bar.rng
msv:http://acme.com/cheese.rng
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.34]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`useDom` |`true` |Whether DOMSource/DOMResult or SaxSource/SaxResult
should be used by the validator. *Note:* DOM must be used by the
link:msv.html[MSV] component.
|=======================================================================

[[BookComponentAppendix-Example.8]]
Example
^^^^^^^

The following
http://svn.apache.org/repos/asf/camel/trunk/components/camel-msv/src/test/resources/org/apache/camel/component/validator/msv/camelContext.xml[example]
shows how to configure a route from endpoint *direct:start* which then
goes to one of two endpoints, either *mock:valid* or *mock:invalid*
based on whether or not the XML matches the given
http://relaxng.org/[RelaxNG XML Schema] (which is supplied on the
classpath).

[[BookComponentAppendix-SeeAlso.23]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-MyBatis]]
MyBatis
~~~~~~~

*Available as of Camel 2.7*

The *mybatis:* component allows you to query, poll, insert, update and
delete data in a relational database using http://mybatis.org/[MyBatis].

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-mybatis</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.42]]
URI format
^^^^^^^^^^

mybatis:statementName[?options]

Where *statementName* is the statement name in the MyBatis XML mapping
file which maps to the query, insert, update or delete operation you
wish to evaluate.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

This component will by default load the MyBatis SqlMapConfig file from
the root of the classpath with the expected name of
`SqlMapConfig.xml`. +
If the file is located in another location, you will need to configure
the `configurationUri` option on the `MyBatisComponent` component.

[[BookComponentAppendix-Options.35]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |Type |Default |Description
|`consumer.onConsume` |`String` |`null` |Statements to run after
consuming. Can be used, for example, to update rows after they have been
consumed and processed in Camel. See sample later. Multiple statements
can be separated with commas.

|`consumer.useIterator` |`boolean` |`true` |If `true` each row returned
when polling will be processed individually. If `false` the entire
`List` of data is set as the IN body.

|`consumer.routeEmptyResultSet` |`boolean` |`false` |Sets whether empty
result sets should be routed.

|`statementType` |`StatementType` |`null` |Mandatory to specify for the
producer to control which kind of operation to invoke. The enum values
are: `SelectOne`, `SelectList`, `Insert`, `InsertList`, `Update`,
`UpdateList`, `Delete`, and `DeleteList`. *Notice:* `InsertList` is
available as of Camel 2.10, and `UpdateList`, `DeleteList` is available
as of Camel 2.11.

|`maxMessagesPerPoll` |`int` |`0` |This option is intended to split
results returned by the database pool into the batches and deliver them
in multiple exchanges. This integer defines the maximum messages to
deliver in single exchange. By default, no maximum is set. Can be used
to set a limit of e.g. 1000 to avoid when starting up the server that
there are thousands of files. Set a value of 0 or negative to disable
it.

|`executorType` |`String` |`null` |*Camel 2.11:* The executor type to be
used while executing statements. The supported values are: simple,
reuse, batch. By default, the value is not specified and is equal to
what MyBatis uses, i.e. *simple*. +
*simple* executor does nothing special. +
*reuse* executor reuses prepared statements. +
*batch* executor reuses statements and batches updates.

|`outputHeader` |`String` |`null` |**Camel 2.15:** To store the result
as a header instead of the message body. This allows to preserve the
existing message body as-is.

|`inputHeader` |`String` |`null` |*Camel 2.15:  *"inputHeader" parameter
to use a header value as input to the component instead of the body.

|`transacted` |`boolean` |`false` |**Camel 2.16.2:** **SQL consumer
only:**Enables or disables transaction. If enabled then if processing an
exchange failed then the consumer break out processing any further
exchanges to cause a rollback eager
|=======================================================================

[[BookComponentAppendix-MessageHeaders.13]]
Message Headers
^^^^^^^^^^^^^^^

Camel will populate the result message, either IN or OUT with a header
with the statement used:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelMyBatisStatementName` |`String` |The *statementName* used (for
example: insertAccount).

|`CamelMyBatisResult` |`Object` |The *response* returned from MtBatis in
any of the operations. For instance an `INSERT` could return the
auto-generated key, or number of rows etc.
|=======================================================================

[[BookComponentAppendix-MessageBody.3]]
Message Body
^^^^^^^^^^^^

The response from MyBatis will only be set as the body if it's a
`SELECT` statement. That means, for example, for `INSERT` statements
Camel will not replace the body. This allows you to continue routing and
keep the original body. The response from MyBatis is always stored in
the header with the key `CamelMyBatisResult`.

[[BookComponentAppendix-Samples.8]]
Samples
^^^^^^^

For example if you wish to consume beans from a JMS queue and insert
them into a database you could do the following:

from("activemq:queue:newAccount").
to("mybatis:insertAccount?statementType=Insert");

Notice we have to specify the `statementType`, as we need to instruct
Camel which kind of operation to invoke.

Where *insertAccount* is the MyBatis ID in the SQL mapping file:

xml <!-- Insert example, using the Account parameter class --> <insert
id="insertAccount" parameterType="Account"> insert into ACCOUNT (
ACC_ID, ACC_FIRST_NAME, ACC_LAST_NAME, ACC_EMAIL ) values ( #\{id},
#\{firstName}, #\{lastName}, #\{emailAddress} ) </insert>

[[BookComponentAppendix-UsingStatementTypeforbettercontrolofMyBatis]]
Using StatementType for better control of MyBatis
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When routing to an MyBatis endpoint you will want more fine grained
control so you can control whether the SQL statement to be executed is a
`SELECT`, `UPDATE`, `DELETE` or `INSERT` etc. So for instance if we want
to route to an MyBatis endpoint in which the IN body contains parameters
to a `SELECT` statement we can
do:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mybatis/src/test/java/org/apache/camel/component/mybatis/MyBatisSelectOneTest.java}In
the code above we can invoke the MyBatis statement `selectAccountById`
and the IN body should contain the account id we want to retrieve, such
as an `Integer` type.

We can do the same for some of the other operations, such as
`SelectList`:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mybatis/src/test/java/org/apache/camel/component/mybatis/MyBatisSelectListTest.java}And
the same for `UPDATE`, where we can send an `Account` object as the IN
body to
MyBatis:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mybatis/src/test/java/org/apache/camel/component/mybatis/MyBatisUpdateTest.java}

[[BookComponentAppendix-UsingInsertListStatementType]]
Using InsertList StatementType
++++++++++++++++++++++++++++++

*Available as of Camel 2.10*

MyBatis allows you to insert multiple rows using its for-each batch
driver. To use this, you need to use the <foreach> in the mapper XML
file. For example as shown
below:\{snippet:id=insertList|lang=xml|url=camel/trunk/components/camel-mybatis/src/test/resources/org/apache/camel/component/mybatis/Account.xml}Then
you can insert multiple rows, by sending a Camel message to the
`mybatis` endpoint which uses the `InsertList` statement type, as shown
below:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mybatis/src/test/java/org/apache/camel/component/mybatis/MyBatisInsertListTest.java}

[[BookComponentAppendix-UsingUpdateListStatementType]]
Using UpdateList StatementType
++++++++++++++++++++++++++++++

*Available as of Camel 2.11*

MyBatis allows you to update multiple rows using its for-each batch
driver. To use this, you need to use the <foreach> in the mapper XML
file. For example as shown below:

xml<update id="batchUpdateAccount" parameterType="java.util.Map"> update
ACCOUNT set ACC_EMAIL = #\{emailAddress} where ACC_ID in <foreach
item="Account" collection="list" open="(" close=")" separator=",">
#\{Account.id} </foreach> </update>

Then you can update multiple rows, by sending a Camel message to the
mybatis endpoint which uses the UpdateList statement type, as shown
below:

from("direct:start")
.to("mybatis:batchUpdateAccount?statementType=UpdateList")
.to("mock:result");

[[BookComponentAppendix-UsingDeleteListStatementType]]
Using DeleteList StatementType
++++++++++++++++++++++++++++++

*Available as of Camel 2.11*

MyBatis allows you to delete multiple rows using its for-each batch
driver. To use this, you need to use the <foreach> in the mapper XML
file. For example as shown below:

xml<delete id="batchDeleteAccountById" parameterType="java.util.List">
delete from ACCOUNT where ACC_ID in <foreach item="AccountID"
collection="list" open="(" close=")" separator=","> #\{AccountID}
</foreach> </delete>

Then you can delete multiple rows, by sending a Camel message to the
mybatis endpoint which uses the DeleteList statement type, as shown
below:

from("direct:start")
.to("mybatis:batchDeleteAccount?statementType=DeleteList")
.to("mock:result");

[[BookComponentAppendix-NoticeonInsertList,UpdateListandDeleteListStatementTypes]]
Notice on InsertList, UpdateList and DeleteList StatementTypes
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Parameter of any type (List, Map, etc.) can be passed to mybatis and an
end user is responsible for handling it as required +
with the help of http://www.mybatis.org/core/dynamic-sql.html[mybatis
dynamic queries] capabilities.

[[BookComponentAppendix-Scheduledpollingexample.1]]
Scheduled polling example
+++++++++++++++++++++++++

This component supports scheduled polling and can therefore be used as
a link:polling-consumer.html[Polling Consumer]. For example to poll the
database every minute:

from("mybatis:selectAllAccounts?delay=60000").to("activemq:queue:allAccounts");

See "ScheduledPollConsumer Options"
on link:polling-consumer.html[Polling Consumer] for more options.

Alternatively you can use another mechanism for triggering the scheduled
polls, such as the link:timer.html[Timer] or link:quartz.html[Quartz]
components. In the sample below we poll the database, every 30 seconds
using the link:timer.html[Timer] component and send the data to the JMS
queue:

javafrom("timer://pollTheDatabase?delay=30000").to("mybatis:selectAllAccounts").to("activemq:queue:allAccounts");

And the MyBatis SQL mapping file used:

xml <!-- Select with no parameters using the result map for Account
class. --> <select id="selectAllAccounts" resultMap="AccountResult">
select * from ACCOUNT </select>

[[BookComponentAppendix-UsingonConsume.1]]
Using onConsume
+++++++++++++++

This component supports executing statements *after* data have been
consumed and processed by Camel. This allows you to do post updates in
the database. Notice all statements must be `UPDATE` statements. Camel
supports executing multiple statements whose names should be separated
by commas.

The route below illustrates we execute the *consumeAccount* statement
data is processed. This allows us to change the status of the row in the
database to processed, so we avoid consuming it twice or
more.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-mybatis/src/test/java/org/apache/camel/component/mybatis/MyBatisQueueTest.java}And
the statements in the sqlmap
file:\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-mybatis/src/test/resources/org/apache/camel/component/mybatis/Account.xml}\{snippet:id=e2|lang=xml|url=camel/trunk/components/camel-mybatis/src/test/resources/org/apache/camel/component/mybatis/Account.xml}

[[BookComponentAppendix-Participatingintransactions]]
Participating in transactions
+++++++++++++++++++++++++++++

Setting up a transaction manager under camel-mybatis can be a little bit
fiddly, as it involves externalising the database configuration outside
the standard MyBatis `SqlMapConfig.xml` file.

The first part requires the setup of a `DataSource`. This is typically a
pool (either DBCP, or c3p0), which needs to be wrapped in a Spring
proxy. This proxy enables non-Spring use of the `DataSource` to
participate in Spring transactions (the MyBatis `SqlSessionFactory` does
just this).

xml <bean id="dataSource"
class="org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy">
<constructor-arg> <bean
class="com.mchange.v2.c3p0.ComboPooledDataSource"> <property
name="driverClass" value="org.postgresql.Driver"/> <property
name="jdbcUrl" value="jdbc:postgresql://localhost:5432/myDatabase"/>
<property name="user" value="myUser"/> <property name="password"
value="myPassword"/> </bean> </constructor-arg> </bean>

This has the additional benefit of enabling the database configuration
to be externalised using property placeholders.

A transaction manager is then configured to manage the outermost
`DataSource`:

xml <bean id="txManager"
class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
<property name="dataSource" ref="dataSource"/> </bean>

A http://www.mybatis.org/spring/index.html[mybatis-spring]
http://www.mybatis.org/spring/factorybean.html[`SqlSessionFactoryBean`]
then wraps that same `DataSource`:

xml <bean id="sqlSessionFactory"
class="org.mybatis.spring.SqlSessionFactoryBean"> <property
name="dataSource" ref="dataSource"/> <!-- standard mybatis config file
--> <property name="configLocation" value="/META-INF/SqlMapConfig.xml"/>
<!-- externalised mappers --> <property name="mapperLocations"
value="classpath*:META-INF/mappers/**/*.xml"/> </bean>

The camel-mybatis component is then configured with that factory:

xml <bean id="mybatis"
class="org.apache.camel.component.mybatis.MyBatisComponent"> <property
name="sqlSessionFactory" ref="sqlSessionFactory"/> </bean>

Finally, a link:transactional-client.html[transaction policy] is defined
over the top of the transaction manager, which can then be used as
usual:

xml <bean id="PROPAGATION_REQUIRED"
class="org.apache.camel.spring.spi.SpringTransactionPolicy"> <property
name="transactionManager" ref="txManager"/> <property
name="propagationBehaviorName" value="PROPAGATION_REQUIRED"/> </bean>
<camelContext id="my-model-context"
xmlns="http://camel.apache.org/schema/spring"> <route id="insertModel">
<from uri="direct:insert"/> <transacted ref="PROPAGATION_REQUIRED"/> <to
uri="mybatis:myModel.insert?statementType=Insert"/> </route>
</camelContext>

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-Nagios]]
Nagios
~~~~~~

*Available as of Camel 2.3*

The link:nagios.html[Nagios] component allows you to send passive checks
to http://nagios.org[Nagios].

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-nagios</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.43]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
nagios://host[:port][?Options]
----

Camel provides two abilities with the link:nagios.html[Nagios]
component. You can send passive check messages by sending a message to
its endpoint. +
Camel also provides a link:camel-jmx.html[EventNotifer] which allows you
to send notifications to Nagios.

[[BookComponentAppendix-Options.36]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`host` |none |This is the address of the link:nagios.html[Nagios] host
where checks should be send.

|`port` |  |The port number of the host.

|`password` |  |Password to be authenticated when sending checks to
Nagios.

|`connectionTimeout` |5000 |Connection timeout in millis.

|`timeout` |5000 |Sending timeout in millis.

|`nagiosSettings` |  |To use an already configured
`com.googlecode.jsendnsca.core.NagiosSettings` object. Then any of the
other options are not in use, if using this.

|`sendSync` |`true` |Whether or not to use synchronous when sending a
passive check. Setting it to `false` will allow Camel to continue
routing the message and the passive check message will be send
asynchronously.

|`encryptionMethod` |`No` |*Camel 2.9:* To specify an encryption method.
Possible values: `No`, `Xor`, or `TripleDes`.
|=======================================================================

[[BookComponentAppendix-Headers.3]]
Headers
^^^^^^^

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Name |Description
|`CamelNagiosHostName` |This is the address of the
link:nagios.html[Nagios] host where checks should be send. This header
will override any existing hostname configured on the endpoint.

|`CamelNagiosLevel` |This is the severity level. You can use values
`CRITICAL, WARNING, OK`. Camel will by default use `OK`.

|`CamelNagiosServiceName` |The servie name. Will default use the
link:camelcontext.html[CamelContext] name.
|=======================================================================

[[BookComponentAppendix-Sendingmessageexamples]]
Sending message examples
^^^^^^^^^^^^^^^^^^^^^^^^

You can send a message to Nagios where the message payload contains the
message. By default it will be `OK` level and use the
link:camelcontext.html[CamelContext] name as the service name. You can
overrule these values using headers as shown above.

For example we send the `Hello Nagios` message to Nagios as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    template.sendBody("direct:start", "Hello Nagios");

    from("direct:start").to("nagios:127.0.0.1:5667?password=secret").to("mock:result");
----

To send a `CRITICAL` message you can send the headers such as:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        Map headers = new HashMap();
        headers.put(NagiosConstants.LEVEL, "CRITICAL");
        headers.put(NagiosConstants.HOST_NAME, "myHost");
        headers.put(NagiosConstants.SERVICE_NAME, "myService");
        template.sendBodyAndHeaders("direct:start", "Hello Nagios", headers);
----

[[BookComponentAppendix-UsingNagiosEventNotifer]]
Using `NagiosEventNotifer`
^^^^^^^^^^^^^^^^^^^^^^^^^^

The link:nagios.html[Nagios] component also provides an
link:camel-jmx.html[EventNotifer] which you can use to send events to
Nagios. For example we can enable this from Java as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        NagiosEventNotifier notifier = new NagiosEventNotifier();
        notifier.getConfiguration().setHost("localhost");
        notifier.getConfiguration().setPort(5667);
        notifier.getConfiguration().setPassword("password");

        CamelContext context = ... 
        context.getManagementStrategy().addEventNotifier(notifier);
        return context;
----

In Spring XML its just a matter of defining a Spring bean with the type
`EventNotifier` and Camel will pick it up as documented here:
link:advanced-configuration-of-camelcontext-using-spring.html[Advanced
configuration of CamelContext using Spring].

[[BookComponentAppendix-SeeAlso.24]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-NettyComponent]]
Netty Component
~~~~~~~~~~~~~~~

*Available as of Camel 2.3*

This component is deprecated. You should use link:netty4.html[Netty4].

The *netty* component in Camel is a socket communication component,
based on the http://netty.io/[Netty] project.

Netty is a NIO client server framework which enables quick and easy
development of network applications such as protocol servers and
clients. +
Netty greatly simplifies and streamlines network programming such as TCP
and UDP socket server.

This camel component supports both producer and consumer endpoints.

The Netty component has several options and allows fine-grained control
of a number of TCP/UDP communication parameters (buffer sizes,
keepAlives, tcpNoDelay etc) and facilitates both In-Only and In-Out
communication on a Camel route.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-netty</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.44]]
URI format
^^^^^^^^^^

The URI scheme for a netty component is as follows

netty:tcp://localhost:99999[?options]
netty:udp://remotehost:99999/[?options]

This component supports producer and consumer endpoints for both TCP and
UDP.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.37]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`keepAlive` |`true` |Setting to ensure socket is not closed due to
inactivity

|`tcpNoDelay` |`true` |Setting to improve TCP protocol performance

|`backlog` |  |*Camel 2.9.6/2.10.4/2.11:* Allows to configure a backlog
for netty consumer (server). Note the backlog is just a best effort
depending on the OS. Setting this option to a value such as `200`, `500`
or `1000`, tells the TCP stack how long the "accept" queue can be. If
this option is not configured, then the backlog depends on OS setting.

|`broadcast` |`false` |Setting to choose Multicast over UDP

|`connectTimeout` |`10000` |Time to wait for a socket connection to be
available. Value is in millis.

|`reuseAddress` |`true` |Setting to facilitate socket multiplexing

|`sync` |`true` |Setting to set endpoint as one-way or request-response

|`synchronous` |`false` |*Camel 2.10:* Whether
link:asynchronous-routing-engine.html[Asynchronous Routing Engine] is
not in use. `false` then the
link:asynchronous-routing-engine.html[Asynchronous Routing Engine] is
used, `true` to force processing synchronous.

|`ssl` |`false` |Setting to specify whether SSL encryption is applied to
this endpoint

|`sslClientCertHeaders` |`false` |*Camel 2.12:* When enabled and in SSL
mode, then the Netty consumer will enrich the Camel
link:message.html[Message] with headers having information about the
client certificate such as subject name, issuer name, serial number, and
the valid date range.

|`sendBufferSize` |`65536 bytes` |The TCP/UDP buffer sizes to be used
during outbound communication. Size is bytes.

|`receiveBufferSize` |`65536 bytes` |The TCP/UDP buffer sizes to be used
during inbound communication. Size is bytes.

|`option.XXX` |`null` |*Camel 2.11/2.10.4:* Allows to configure
additional netty options using "option." as prefix. For example
"option.child.keepAlive=false" to set the netty option
"child.keepAlive=false". See the Netty documentation for possible
options that can be used.

|`corePoolSize` |`10` |The number of allocated threads at component
startup. Defaults to 10. *Note:* This option is removed from Camel 2.9.2
onwards. As we rely on Nettys default settings.

|`maxPoolSize` |`100` |The maximum number of threads that may be
allocated to this endpoint. Defaults to 100. *Note:* This option is
removed from Camel 2.9.2 onwards. As we rely on Nettys default settings.

|`disconnect` |`false` |Whether or not to disconnect(close) from Netty
Channel right after use. Can be used for both consumer and producer.

|`lazyChannelCreation` |`true` |Channels can be lazily created to avoid
exceptions, if the remote server is not up and running when the Camel
producer is started.

|`transferExchange` |`false` |Only used for TCP. You can transfer the
exchange over the wire instead of just the body. The following fields
are transferred: In body, Out body, fault body, In headers, Out headers,
fault headers, exchange properties, exchange exception. This requires
that the objects are serializable. Camel will exclude any
non-serializable objects and log it at WARN level.

|`disconnectOnNoReply` |`true` |If sync is enabled then this option
dictates NettyConsumer if it should disconnect where there is no reply
to send back.

|`noReplyLogLevel` |`WARN` |If sync is enabled this option dictates
NettyConsumer which logging level to use when logging a there is no
reply to send back. Values are: `FATAL, ERROR, INFO, DEBUG, OFF`.

|`serverExceptionCaughtLogLevel` |`WARN` |*Camel 2.11.1:* If the server
(NettyConsumer) catches an exception then its logged using this logging
level.

|`serverClosedChannelExceptionCaughtLogLevel` |`DEBUG` |*Camel 2.11.1:*
If the server (NettyConsumer) catches an
`java.nio.channels.ClosedChannelException` then its logged using this
logging level. This is used to avoid logging the closed channel
exceptions, as clients can disconnect abruptly and then cause a flod of
closed exceptions in the Netty server.

|`allowDefaultCodec` |`true` |*Camel 2.4:* The netty component installs
a default codec if both, encoder/deocder is null and textline is false.
Setting allowDefaultCodec to false prevents the netty component from
installing a default codec as the first element in the filter chain.

|`textline` |`false` |*Camel 2.4:* Only used for TCP. If no codec is
specified, you can use this flag to indicate a text line based codec; if
not specified or the value is false, then Object Serialization is
assumed over TCP.

|`delimiter` |`LINE` |*Camel 2.4:* The delimiter to use for the textline
codec. Possible values are `LINE` and `NULL`.

|`decoderMaxLineLength` |`1024` |*Camel 2.4:* The max line length to use
for the textline codec.

|`autoAppendDelimiter` |`true` |*Camel 2.4:* Whether or not to auto
append missing end delimiter when sending using the textline codec.

|`encoding` |`null` |*Camel 2.4:* The encoding (a charset name) to use
for the textline codec. If not provided, Camel will use the JVM default
Charset.

|`workerCount` |`null` |*Camel 2.9:* When netty works on nio mode, it
uses default workerCount parameter from Netty, which is
cpu_core_threads*2. User can use this operation to override the default
workerCount from Netty

|`sslContextParameters` |`null` |*Camel 2.9:* SSL configuration using an
`org.apache.camel.util.jsse.SSLContextParameters` instance. See
link:netty.html[Using the JSSE Configuration Utility].

|`receiveBufferSizePredictor` |`null` |*Camel 2.9:* Configures the
buffer size predictor. See details at Jetty documentation and this
http://lists.jboss.org/pipermail/netty-users/2010-January/001958.html[mail
thread].

|`requestTimeout` |`0` |*Camel 2.11.1:* Allows to use a timeout for the
Netty producer when calling a remote server. By default no timeout is in
use. The value is in milli seconds, so eg `30000` is 30 seconds. The
requestTimeout is using Netty's ReadTimeoutHandler to trigger the
timeout. *Camel 2.16, 2.15.3* you can also override this setting by
setting the CamelNettyRequestTimeout header.

|`needClientAuth` |`false` |*Camel 2.11:* Configures whether the server
needs client authentication when using SSL.

|`orderedThreadPoolExecutor` |`true` |*Camel 2.10.2:* Whether to use
ordered thread pool, to ensure events are processed orderly on the same
channel. See details at the netty javadoc of
`org.jboss.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor`
for more details.

|`maximumPoolSize` |`16` a|
*Camel 2.10.2:* The core pool size for the ordered thread pool, if its
in use.

*Since Camel 2.14.1*: This option is move the NettyComponent.

|`producerPoolEnabled` |`true` |*Camel 2.10.4/Camel 2.11:* Producer
only. Whether producer pool is enabled or not. *Important:* Do not turn
this off, as the pooling is needed for handling concurrency and reliable
request/reply.

|`producerPoolMaxActive` |`-1` |*Camel 2.10.3:* Producer only. Sets the
cap on the number of objects that can be allocated by the pool (checked
out to clients, or idle awaiting checkout) at a given time. Use a
negative value for no limit.

|`producerPoolMinIdle` |`0` |*Camel 2.10.3:* Producer only. Sets the
minimum number of instances allowed in the producer pool before the
evictor thread (if active) spawns new objects.

|`producerPoolMaxIdle` |`100` |*Camel 2.10.3:* Producer only. Sets the
cap on the number of "idle" instances in the pool.

|`producerPoolMinEvictableIdle` |`300000` |*Camel 2.10.3:* Producer
only. Sets the minimum amount of time (value in millis) an object may
sit idle in the pool before it is eligible for eviction by the idle
object evictor.

|`bootstrapConfiguration` |`null` |*Camel 2.12:* Consumer only. Allows
to configure the Netty ServerBootstrap options using a
`org.apache.camel.component.netty.NettyServerBootstrapConfiguration`
instance. This can be used to reuse the same configuration for multiple
consumers, to align their configuration more easily.

|`bossPoll` |`null` |*Camel 2.12:* To use a explicit
`org.jboss.netty.channel.socket.nio.BossPool` as the boss thread pool.
For example to share a thread pool with multiple consumers. By default
each consumer has their own boss pool with 1 core thread.

|`workerPool` |`null` |*Camel 2.12:* To use a explicit
`org.jboss.netty.channel.socket.nio.WorkerPool` as the worker thread
pool. For example to share a thread pool with multiple consumers. By
default each consumer has their own worker pool with 2 x cpu count core
threads.

|channelGroup |null |*Camel 2.17* To use a explicit
`io.netty.channel.group.ChannelGroup` for example to broadact a message
to multiple channels.

|`networkInterface` |`null` |*Camel 2.12:* Consumer only. When using UDP
then this option can be used to specify a network interface by its name,
such as `eth0` to join a multicast group.

|`udpConnectionlessSending` |`false` |*Camel 2.15:* Producer only.  This
option supports connection less udp sending which is a real fire and
forget. A connected udp send receive the PortUnreachableException if no
one is listen on the receiving port.

|`clientMode` |`false` |*Camel 2.15:* Consumer only. If the `clientMode`
is true, netty consumer will connect the address as a TCP client.

|`useChannelBuffer` |`false` |*Camel 2.16:* Producer only. If the
`useChannelBuffer` is true, netty producer will turn the message body
into channelBuffer before sending it out.
|=======================================================================

[[BookComponentAppendix-RegistrybasedOptions]]
Registry based Options
^^^^^^^^^^^^^^^^^^^^^^

Codec Handlers and SSL Keystores can be enlisted in the
link:registry.html[Registry], such as in the Spring XML file. +
The values that could be passed in, are the following:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Name |Description
|`passphrase` |password setting to use in order to encrypt/decrypt
payloads sent using SSH

|`keyStoreFormat` |keystore format to be used for payload encryption.
Defaults to "JKS" if not set

|`securityProvider` |Security provider to be used for payload
encryption. Defaults to "SunX509" if not set.

|`keyStoreFile` |*deprecated:* Client side certificate keystore to be
used for encryption

|`trustStoreFile` |*deprecated:* Server side certificate keystore to be
used for encryption

|`keyStoreResource` |*Camel 2.11.1:* Client side certificate keystore to
be used for encryption. Is loaded by default from classpath, but you can
prefix with `"classpath:"`, `"file:"`, or `"http:"` to load the resource
from different systems.

|`trustStoreResource` |*Camel 2.11.1:* Server side certificate keystore
to be used for encryption. Is loaded by default from classpath, but you
can prefix with `"classpath:"`, `"file:"`, or `"http:"` to load the
resource from different systems.

|`sslHandler` |Reference to a class that could be used to return an SSL
Handler

|`encoder` |A custom `ChannelHandler` class that can be used to perform
special marshalling of outbound payloads. Must override
`org.jboss.netty.channel.ChannelDownStreamHandler`.

|`encorders` |A list of encoders to be used. You can use a String which
have values separated by comma, and have the values be looked up in the
link:registry.html[Registry]. Just remember to prefix the value with #
so Camel knows it should lookup.

|`decoder` |A custom `ChannelHandler` class that can be used to perform
special marshalling of inbound payloads. Must override
`org.jboss.netty.channel.ChannelUpStreamHandler`.

|`decoders` |A list of decoders to be used. You can use a String which
have values separated by comma, and have the values be looked up in the
link:registry.html[Registry]. Just remember to prefix the value with #
so Camel knows it should lookup.
|=======================================================================

*Important:* Read below about using non shareable encoders/decoders.

[[BookComponentAppendix-Usingnonshareableencodersordecoders]]
Using non shareable encoders or decoders
++++++++++++++++++++++++++++++++++++++++

If your encoders or decoders is not shareable (eg they have the
@Shareable class annotation), then your encoder/decoder must implement
the `org.apache.camel.component.netty.ChannelHandlerFactory` interface,
and return a new instance in the `newChannelHandler` method. This is to
ensure the encoder/decoder can safely be used. If this is not the case,
then the Netty component will log a WARN when +
an endpoint is created.

The Netty component offers a
`org.apache.camel.component.netty.ChannelHandlerFactories` factory
class, that has a number of commonly used methods.

[[BookComponentAppendix-SendingMessagesto/fromaNettyendpoint]]
Sending Messages to/from a Netty endpoint
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-NettyProducer]]
Netty Producer
++++++++++++++

In Producer mode, the component provides the ability to send payloads to
a socket endpoint +
using either TCP or UDP protocols (with optional SSL support).

The producer mode supports both one-way and request-response based
operations.

[[BookComponentAppendix-NettyConsumer]]
Netty Consumer
++++++++++++++

In Consumer mode, the component provides the ability to:

* listen on a specified socket using either TCP or UDP protocols (with
optional SSL support),
* receive requests on the socket using text/xml, binary and serialized
object based payloads and
* send them along on a route as message exchanges.

The consumer mode supports both one-way and request-response based
operations.

 

[[BookComponentAppendix-Headers.4]]
Headers
^^^^^^^

The following headers are filled for the exchanges created by the Netty
consumer:

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header key |Class |Description
|`NettyConstants.NETTY_CHANNEL_HANDLER_CONTEXT` /
`CamelNettyChannelHandlerContext`
|`org.jboss.netty.channel.ChannelHandlerContext`
|`ChannelHandlerContext `instance associated with the connection
received by netty.

|`NettyConstants.NETTY_MESSAGE_EVENT` / `CamelNettyMessageEvent`
|`org.jboss.netty.channel.MessageEvent` |`MessageEvent `instance
associated with the connection received by netty.

|`NettyConstants.NETTY_REMOTE_ADDRESS` / `CamelNettyRemoteAddress`
|`java.net.SocketAddress` |Remote address of the incoming socket
connection.

|`NettyConstants.NETTY_LOCAL_ADDRESS` / `CamelNettyLocalAddress`
|`java.net.SocketAddress` |Local address of the incoming socket
connection.
|=======================================================================

[[BookComponentAppendix-UsageSamples]]
Usage Samples
^^^^^^^^^^^^^

[[BookComponentAppendix-AUDPNettyendpointusingRequest-Replyandserializedobjectpayload]]
A UDP Netty endpoint using Request-Reply and serialized object payload
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

RouteBuilder builder = new RouteBuilder() \{ public void configure() \{
from("netty:udp://localhost:5155?sync=true") .process(new Processor() \{
public void process(Exchange exchange) throws Exception \{ Poetry poetry
= (Poetry) exchange.getIn().getBody(); poetry.setPoet("Dr. Sarojini
Naidu"); exchange.getOut().setBody(poetry); } } } };

[[BookComponentAppendix-ATCPbasedNettyconsumerendpointusingOne-waycommunication]]
A TCP based Netty consumer endpoint using One-way communication
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

RouteBuilder builder = new RouteBuilder() \{ public void configure() \{
from("netty:tcp://localhost:5150") .to("mock:result"); } };

[[BookComponentAppendix-AnSSL/TCPbasedNettyconsumerendpointusingRequest-Replycommunication]]
An SSL/TCP based Netty consumer endpoint using Request-Reply
communication
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[[BookComponentAppendix-UsingtheJSSEConfigurationUtility.5]]
Using the JSSE Configuration Utility

As of Camel 2.9, the Netty component supports SSL/TLS configuration
through the link:camel-configuration-utilities.html[Camel JSSE
Configuration Utility].  This utility greatly decreases the amount of
component specific code you need to write and is configurable at the
endpoint and component levels.  The following examples demonstrate how
to use the utility with the Netty component.

[[BookComponentAppendix-Programmaticconfigurationofthecomponent.2]]
Programmatic configuration of the component

KeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("/users/home/server/keystore.jks");
ksp.setPassword("keystorePassword"); KeyManagersParameters kmp = new
KeyManagersParameters(); kmp.setKeyStore(ksp);
kmp.setKeyPassword("keyPassword"); SSLContextParameters scp = new
SSLContextParameters(); scp.setKeyManagers(kmp); NettyComponent
nettyComponent = getContext().getComponent("netty",
NettyComponent.class); nettyComponent.setSslContextParameters(scp);

[[BookComponentAppendix-SpringDSLbasedconfigurationofendpoint.4]]
Spring DSL based configuration of endpoint

xml... <camel:sslContextParameters id="sslContextParameters">
<camel:keyManagers keyPassword="keyPassword"> <camel:keyStore
resource="/users/home/server/keystore.jks" password="keystorePassword"/>
</camel:keyManagers> </camel:sslContextParameters>... ... <to
uri="netty:tcp://localhost:5150?sync=true&ssl=true&sslContextParameters=#sslContextParameters"/>
...

[[BookComponentAppendix-UsingBasicSSL/TLSconfigurationontheJettyComponent]]
Using Basic SSL/TLS configuration on the Jetty Component

JndiRegistry registry = new JndiRegistry(createJndiContext());
registry.bind("password", "changeit"); registry.bind("ksf", new
File("src/test/resources/keystore.jks")); registry.bind("tsf", new
File("src/test/resources/keystore.jks"));
context.createRegistry(registry); context.addRoutes(new RouteBuilder()
\{ public void configure() \{ String netty_ssl_endpoint =
"netty:tcp://localhost:5150?sync=true&ssl=true&passphrase=#password" +
"&keyStoreFile=#ksf&trustStoreFile=#tsf"; String return_string = "When
You Go Home, Tell Them Of Us And Say," + "For Your Tomorrow, We Gave Our
Today."; from(netty_ssl_endpoint) .process(new Processor() \{ public
void process(Exchange exchange) throws Exception \{
exchange.getOut().setBody(return_string); } } } });

[[BookComponentAppendix-GettingaccesstoSSLSessionandtheclientcertificate]]
Getting access to SSLSession and the client certificate

*Available as of Camel 2.12*

You can get access to the `javax.net.ssl.SSLSession` if you eg need to
get details about the client certificate. When `ssl=true` then the
link:netty.html[Netty] component will store the `SSLSession` as a header
on the Camel link:message.html[Message] as shown below:

SSLSession session =
exchange.getIn().getHeader(NettyConstants.NETTY_SSL_SESSION,
SSLSession.class); // get the first certificate which is client
certificate javax.security.cert.X509Certificate cert =
session.getPeerCertificateChain()[0]; Principal principal =
cert.getSubjectDN();

Remember to set `needClientAuth=true` to authenticate the client,
otherwise `SSLSession` cannot access information about the client
certificate, and you may get an exception
`javax.net.ssl.SSLPeerUnverifiedException: peer not authenticated`. You
may also get this exception if the client certificate is expired or not
valid etc.

The option `sslClientCertHeaders` can be set to `true` which then
enriches the Camel link:message.html[Message] with headers having
details about the client certificate. For example the subject name is
readily available in the header `CamelNettySSLClientCertSubjectName`.

[[BookComponentAppendix-UsingMultipleCodecs]]
Using Multiple Codecs
+++++++++++++++++++++

In certain cases it may be necessary to add chains of encoders and
decoders to the netty pipeline. To add multpile codecs to a camel netty
endpoint the 'encoders' and 'decoders' uri parameters should be used.
Like the 'encoder' and 'decoder' parameters they are used to supply
references (to lists of ChannelUpstreamHandlers and
ChannelDownstreamHandlers) that should be added to the pipeline. Note
that if encoders is specified then the encoder param will be ignored,
similarly for decoders and the decoder param.

Read further above about using non shareable encoders/decoders.

The lists of codecs need to be added to the Camel's registry so they can
be resolved when the endpoint is
created.\{snippet:id=registry-beans|lang=java|url=camel/trunk/components/camel-netty/src/test/java/org/apache/camel/component/netty/MultipleCodecsTest.java}Spring's
native collections support can be used to specify the codec lists in an
application
context\{snippet:id=registry-beans|lang=xml|url=camel/trunk/components/camel-netty/src/test/resources/org/apache/camel/component/netty/multiple-codecs.xml}The
bean names can then be used in netty endpoint definitions either as a
comma separated list or contained in a List
e.g.\{snippet:id=routes|lang=java|url=camel/trunk/components/camel-netty/src/test/java/org/apache/camel/component/netty/MultipleCodecsTest.java}or
via
spring.\{snippet:id=routes|lang=xml|url=camel/trunk/components/camel-netty/src/test/resources/org/apache/camel/component/netty/multiple-codecs.xml}

[[BookComponentAppendix-ClosingChannelWhenComplete]]
Closing Channel When Complete
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When acting as a server you sometimes want to close the channel when,
for example, a client conversion is finished. +
You can do this by simply setting the endpoint option `disconnect=true`.

However you can also instruct Camel on a per message basis as follows. +
To instruct Camel to close the channel, you should add a header with the
key `CamelNettyCloseChannelWhenComplete` set to a boolean `true`
value. +
For instance, the example below will close the channel after it has
written the bye message back to the client:

from("netty:tcp://localhost:8080").process(new Processor() \{ public
void process(Exchange exchange) throws Exception \{ String body =
exchange.getIn().getBody(String.class); exchange.getOut().setBody("Bye "
+ body); // some condition which determines if we should close if
(close) \{
exchange.getOut().setHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE,
true); } } });

[[BookComponentAppendix-Addingcustomchannelpipelinefactoriestogaincompletecontroloveracreatedpipeline]]
Adding custom channel pipeline factories to gain complete control over a
created pipeline
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.5*

Custom channel pipelines provide complete control to the user over the
handler/interceptor chain by inserting custom handler(s), encoder(s) &
decoders without having to specify them in the Netty Endpoint URL in a
very simple way.

In order to add a custom pipeline, a custom channel pipeline factory
must be created and registered with the context via the context registry
(JNDIRegistry,or the camel-spring ApplicationContextRegistry etc).

A custom pipeline factory must be constructed as follows

* A Producer linked channel pipeline factory must extend the abstract
class `ClientPipelineFactory`.
* A Consumer linked channel pipeline factory must extend the abstract
class `ServerPipelineFactory`.
* The classes should override the getPipeline() method in order to
insert custom handler(s), encoder(s) and decoder(s). Not overriding the
getPipeline() method creates a pipeline with no handlers, encoders or
decoders wired to the pipeline.

The example below shows how ServerChannel Pipeline factory may be
created

Using custom pipeline factorypublic class
SampleServerChannelPipelineFactory extends ServerPipelineFactory \{
private int maxLineSize = 1024; public ChannelPipeline getPipeline()
throws Exception \{ ChannelPipeline channelPipeline =
Channels.pipeline(); channelPipeline.addLast("encoder-SD", new
StringEncoder(CharsetUtil.UTF_8));
channelPipeline.addLast("decoder-DELIM", new
DelimiterBasedFrameDecoder(maxLineSize, true,
Delimiters.lineDelimiter())); channelPipeline.addLast("decoder-SD", new
StringDecoder(CharsetUtil.UTF_8)); // here we add the default Camel
ServerChannelHandler for the consumer, to allow Camel to route the
message etc. channelPipeline.addLast("handler", new
ServerChannelHandler(consumer)); return channelPipeline; } }

The custom channel pipeline factory can then be added to the registry
and instantiated/utilized on a camel route in the following way

Registry registry = camelContext.getRegistry(); serverPipelineFactory =
new TestServerChannelPipelineFactory(); registry.bind("spf",
serverPipelineFactory); context.addRoutes(new RouteBuilder() \{ public
void configure() \{ String netty_ssl_endpoint =
"netty:tcp://localhost:5150?serverPipelineFactory=#spf" String
return_string = "When You Go Home, Tell Them Of Us And Say," + "For Your
Tomorrow, We Gave Our Today."; from(netty_ssl_endpoint) .process(new
Processor() \{ public void process(Exchange exchange) throws Exception
\{ exchange.getOut().setBody(return_string); } } } });

[[BookComponentAppendix-ReusingNettybossandworkerthreadpools]]
Reusing Netty boss and worker thread pools
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.12*

Netty has two kind of thread pools: boss and worker. By default each
Netty consumer and producer has their private thread pools. If you want
to reuse these thread pools among multiple consumers or producers then
the thread pools must be created and enlisted in the
link:registry.html[Registry].

For example using Spring XML we can create a shared worker thread pool
using the `NettyWorkerPoolBuilder` with 2 worker threads as shown below:

xml <!-- use the worker pool builder to create to help create the shared
thread pool --> <bean id="poolBuilder"
class="org.apache.camel.component.netty.NettyWorkerPoolBuilder">
<property name="workerCount" value="2"/> </bean> <!-- the shared worker
thread pool --> <bean id="sharedPool"
class="org.jboss.netty.channel.socket.nio.WorkerPool"
factory-bean="poolBuilder" factory-method="build"
destroy-method="shutdown"> </bean>

For boss thread pool there is a
`org.apache.camel.component.netty.NettyServerBossPoolBuilder` builder
for Netty consumers, and a
`org.apache.camel.component.netty.NettyClientBossPoolBuilder` for the
Netty produces.

Then in the Camel routes we can refer to this worker pools by
configuring the `workerPool` option in the
https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=CAMEL&title=URI&linkCreation=true&fromPageId=14814487[URI]
as shown below:

xml <route> <from
uri="netty:tcp://localhost:5021?textline=true&amp;sync=true&amp;workerPool=#sharedPool&amp;orderedThreadPoolExecutor=false"/>
<to uri="log:result"/> ... </route>

And if we have another route we can refer to the shared worker pool:

xml <route> <from
uri="netty:tcp://localhost:5022?textline=true&amp;sync=true&amp;workerPool=#sharedPool&amp;orderedThreadPoolExecutor=false"/>
<to uri="log:result"/> ... </route>

... and so forth.

link:endpoint-see-also.html[Endpoint See Also]

* link:netty-http.html[Netty HTTP]
* link:mina.html[MINA]

[[BookComponentAppendix-NMRComponent]]
NMR Component
~~~~~~~~~~~~~

The *nmr* component is an adapter to the Normalized Message Router (NMR)
in http://servicemix.apache.org/home.html[ServiceMix], which is intended
for use by Camel applications deployed directly into the OSGi container.
You can exchange objects with NMR and not only XML like this is the case
with the JBI specification. The interest of this component is that you
can interconnect camel routes deployed in different OSGI bundles.

By contrast, the link:jbi.html[JBI] component is intended for use by
Camel applications deployed into the ServiceMix JBI container.

[[BookComponentAppendix-InstallinginApacheServicemix]]
Installing in Apache Servicemix
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The NMR component is provided with Apache ServiceMix. It is *not*
distributed with Camel. To install the NMR component in ServiceMix,
enter the following command in the ServiceMix console window:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
features:install nmr camel-nmr
----

[[BookComponentAppendix-InstallinginplainApacheKaraf]]
Installing in plain Apache Karaf
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In plain Karaf the nmr component can also be installed using the
servicemix artifacts:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
features:chooseurl camel <version>
features:addurl mvn:org.apache.servicemix.nmr/apache-servicemix-nmr/1.5.0/xml/features
features:install camel-blueprint nmr camel-nmr
install -s mvn:org.apache.servicemix.camel/org.apache.servicemix.camel.component/4.4.2
----

[[BookComponentAppendix-Configuration]]
Configuration
^^^^^^^^^^^^^

You also need to instantiate the NMR component. You can do this by
editing your Spring configuration file, `META-INF/spring/*.xml`, and
adding the following `bean` instance:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<beans xmlns:osgi="http://www.springframework.org/schema/osgi" ... >
    ...
    <bean id="nmr" class="org.apache.servicemix.camel.nmr.ServiceMixComponent">
        <property name="nmr">
            <osgi:reference interface="org.apache.servicemix.nmr.api.NMR" />
        </property>
    </bean>
    ...
</beans>
----

[[BookComponentAppendix-NMRconsumerandproducerendpoints]]
NMR consumer and producer endpoints
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following code:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("nmr:MyServiceEndpoint")
----

Automatically exposes a new endpoint to the bus with endpoint name
`MyServiceEndpoint` (see link:nmr.html[URI-format]).

When an NMR endpoint appears at the end of a route, for example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
to("nmr:MyServiceEndpoint")
----

The messages sent by this producer endpoint are sent to the already
deployed NMR endpoint.

[[BookComponentAppendix-URI-format]]

[[BookComponentAppendix-URIformat.45]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
nmr:endpointName
----

[[BookComponentAppendix-URIOptions.8]]
URI Options
+++++++++++

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default Value |Description
|`runAsSubject` |`false` |*Apache ServiceMix 4.4:* When this is set to
`true` on a consumer endpoint, the endpoint will be invoked on behalf of
the `Subject` that is set on the `Exchange` (i.e. the call to
`Subject.getSubject(AccessControlContext)` will return the `Subject`
instance)

|`synchronous` |`false` |When this is set to `true` on a consumer
endpoint, an incoming, synchronous NMR Exchange will be handled on the
sender's thread instead of being handled on a new thread of the NMR
endpoint's thread pool

|`timeout` |`0` |*Apache ServiceMix 4.4:* When this is set to a value
greater than 0, the producer endpoint will timeout if it doesn't receive
a response from the NMR within the given timeout period (in
milliseconds). Configuring a timeout value will switch to using
synchronous interactions with the NMR instead of the usual asynchronous
messaging.

|`throwExceptionOnFailure` |true |*Apache ServiceMix 4.5.2:* When this
is set to `false` then NMR's exceptions (like TimeoutException) will be
consumed silently.

|`interfaceName` |null |*Apache ServiceMix 4.5.3:* When specify this as
a `QName` then it could be considered when NMR looking for the target
NMR endpoint during dispatch

|`serviceName` |null |*Apache ServiceMix 4.5.3:* When specify this as a
`QName` then it could be considered when NMR looking for the target NMR
endpoint during dispatch
|=======================================================================

[[BookComponentAppendix-Examples.12]]
Examples
++++++++

Consumer

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("nmr:MyServiceEndpoint") // consume nmr exchanges asynchronously
from("nmr:MyServiceEndpoint?synchronous=true").to() // consume nmr exchanges synchronously and use the same thread as defined by NMR ThreadPool
----

Producer

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from()...to("nmr:MyServiceEndpoint") // produce nmr exchanges asynchronously
from()...to("nmr:MyServiceEndpoint?timeout=10000") // produce nmr exchanges synchronously and wait till 10s to receive response
----

[[BookComponentAppendix-UsingStreambodies.1]]
Using Stream bodies
^^^^^^^^^^^^^^^^^^^

If you are using a stream type as the message body, you should be aware
that a stream is only capable of being read once. So if you enable
`DEBUG` logging, the body is usually logged and thus read. To deal with
this, Camel has a `streamCaching` option that can cache the stream,
enabling you to read it multiple times.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("nmr:MyEndpoint").streamCaching().to("xslt:transform.xsl", "bean:doSomething");
----

The stream caching is default enabled, so it is not necessary to set the
`streamCaching()` option. +
We store big input streams (by default, over 64K) in a `temp` file using
`CachedOutputStream`. When you close the input stream, the temp file
will be deleted.

[[BookComponentAppendix-Testing]]
Testing
+++++++

NMR camel routes can be tested using the camel unit test approach even
if they will be deployed next in different bundles on an OSGI runtime.
With this aim in view, you will extend the ServiceMixNMR Mock class
`org.apache.servicemix.camel.nmr.AbstractComponentTest` which will
create a NMR bus, register the Camel NMR Component and the endpoints
defined into the Camel routes.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
public class ExchangeUsingNMRTest extends AbstractComponentTest {

    @Test
    public void testProcessing() throws InterruptedException {
        MockEndpoint mock = getMockEndpoint("mock:simple");
        mock.expectedBodiesReceived("Simple message body");

        template.sendBody("direct:simple", "Simple message body");

        assertMockEndpointsSatisfied();

    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {

            @Override
            public void configure() throws Exception {
                from("direct:simple").to("nmr:simple");
                from("nmr:simple?synchronous=true").to("mock:simple");
            }
        };
    }
}
----

[[BookComponentAppendix-SeeAlso.25]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-QuartzComponent]]
Quartz Component
~~~~~~~~~~~~~~~~

The *quartz:* component provides a scheduled delivery of messages using
the http://www.quartz-scheduler.org/[Quartz Scheduler 1.x]. +
Each endpoint represents a different timer (in Quartz terms, a Trigger
and JobDetail).

[Tip]
====


If you are using Quartz 2.x then from Camel 2.12 onwards there is a
link:quartz2.html[Quartz2] component you should use

====

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-quartz</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.46]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
quartz://timerName?options
quartz://groupName/timerName?options
quartz://groupName/timerName?cron=expression
quartz://timerName?cron=expression
----

The component uses either a `CronTrigger` or a `SimpleTrigger`. If no
cron expression is provided, the component uses a simple trigger. If no
`groupName` is provided, the quartz component uses the `Camel` group
name.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.38]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter |Default |Description
|`cron` |_None_ |Specifies a `cron` expression (not compatible with the
`trigger.*` or `job.*` options).

|`trigger.repeatCount` |`0` |SimpleTrigger: How many times should the
timer repeat?

|`trigger.repeatInterval` |`0` |SimpleTrigger: The amount of time in
milliseconds between repeated triggers.

|`job.name` |`null` |Sets the job name.

|`job.XXX` |`null` |Sets the job option with the `XXX` setter name.

|`trigger.XXX` |`null` |Sets the trigger option with the `XXX` setter
name.

|`stateful` |`false` |Uses a Quartz `StatefulJob` instead of the default
job.

|`fireNow` |`false` |New to Camel 2.2.0, if it is true will fire the
trigger when the route is start when using SimpleTrigger.

|`deleteJob` |`true` |*Camel 2.12:* If set to true, then the trigger
automatically delete when route stop. Else if set to false, it will
remain in scheduler. When set to false, it will also mean user may reuse
pre-configured trigger with camel Uri. Just ensure the names match.
Notice you cannot have both deleteJob and pauseJob set to true.

|`pauseJob` |`false` |*Camel 2.12:* If set to true, then the trigger
automatically pauses when route stop. Else if set to false, it will
remain in scheduler. When set to false, it will also mean user may reuse
pre-configured trigger with camel Uri. Just ensure the names match.
Notice you cannot have both deleteJob and pauseJob set to true.

|`usingFixedCamelContextName` |`false` |**Camel 2.15.0:** If it is true,
JobDataMap uses the CamelContext name directly to reference the camel
context, if it is false, JobDataMap uses use the CamelContext management
name which could be changed during the deploy time.
|=======================================================================

For example, the following routing rule will fire two timer events to
the `mock:results` endpoint:

When using a
http://quartz-scheduler.org/api/2.0.0/org/quartz/StatefulJob.html[StatefulJob],
the
http://quartz-scheduler.org/api/2.0.0/org/quartz/JobDataMap.html[JobDataMap]
is re-persisted after every execution of the job, thus preserving state
for the next execution.

[Info]
====
 **Running in OSGi and having multiple bundles with quartz
routes**

If you run in OSGi such as Apache ServiceMix, or Apache Karaf, and have
multiple bundles with Camel routes that start from
link:quartz.html[Quartz] endpoints, then make sure if you assign +
an `id` to the <camelContext> that this id is unique, as this is
required by the `QuartzScheduler` in the OSGi container. If you do not
set any `id` on <camelContext> then +
a unique id is auto assigned, and there is no problem.

====

[[BookComponentAppendix-Configuringquartz.propertiesfile]]
Configuring quartz.properties file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

By default Quartz will look for a `quartz.properties` file in the
`org/quartz` directory of the classpath. If you are using WAR
deployments this means just drop the quartz.properties in
`WEB-INF/classes/org/quartz`.

However the Camel link:quartz.html[Quartz] component also allows you to
configure properties:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter |Default |Type |Description
|`properties` |`null` |`Properties` |*Camel 2.4*: You can configure a
`java.util.Properties` instance.

|`propertiesFile` |`null` |`String` |*Camel 2.4*: File name of the
properties to load from the classpath
|=======================================================================

To do this you can configure this in Spring XML as follows

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="quartz" class="org.apache.camel.component.quartz.QuartzComponent">
    <property name="propertiesFile" value="com/mycompany/myquartz.properties"/>
</bean>
----

[[BookComponentAppendix-EnablingQuartzschedulerinJMX]]
Enabling Quartz scheduler in JMX
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You need to configure the quartz scheduler properties to enable JMX. +
That is typically setting the option `"org.quartz.scheduler.jmx.export"`
to a `true` value in the configuration file.

From Camel 2.13 onwards Camel will automatic set this option to true,
unless explicit disabled.

[[BookComponentAppendix-StartingtheQuartzscheduler]]
Starting the Quartz scheduler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.4*

The link:quartz.html[Quartz] component offers an option to let the
Quartz scheduler be started delayed, or not auto started at all.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Parameter |Default |Type |Description
|`startDelayedSeconds` |`0` |`int` |*Camel 2.4*: Seconds to wait before
starting the quartz scheduler.

|`autoStartScheduler` |`true` |`boolean` |*Camel 2.4:* Whether or not
the scheduler should be auto started.
|=======================================================================

To do this you can configure this in Spring XML as follows

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="quartz" class="org.apache.camel.component.quartz.QuartzComponent">
    <property name="startDelayedSeconds" value="5"/>
</bean>
----

[[BookComponentAppendix-Clustering]]
Clustering
^^^^^^^^^^

*Available as of Camel 2.4*

If you use Quartz in clustered mode, e.g. the `JobStore` is clustered.
Then from Camel 2.4 onwards the link:quartz.html[Quartz] component will
*not* pause/remove triggers when a node is being stopped/shutdown. This
allows the trigger to keep running on the other nodes in the cluster.

*Note*: When running in clustered node no checking is done to ensure
unique job name/group for endpoints.

[[BookComponentAppendix-MessageHeaders.14]]
Message Headers
^^^^^^^^^^^^^^^

Camel adds the getters from the Quartz Execution Context as header
values. The following headers are added: +
`calendar`, `fireTime`, `jobDetail`, `jobInstance`, `jobRuntTime`,
`mergedJobDataMap`, `nextFireTime`, `previousFireTime`, `refireCount`,
`result`, `scheduledFireTime`, `scheduler`, `trigger`, `triggerName`,
`triggerGroup`.

The `fireTime` header contains the `java.util.Date` of when the exchange
was fired.

[[BookComponentAppendix-UsingCronTriggers]]
Using Cron Triggers
^^^^^^^^^^^^^^^^^^^

Quartz supports
http://www.quartz-scheduler.org/documentation/quartz-2.1.x/tutorials/crontrigger[Cron-like
expressions] for specifying timers in a handy format. You can use these
expressions in the `cron` URI parameter; though to preserve valid URI
encoding we allow + to be used instead of spaces. Quartz provides a
http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html[little
tutorial] on how to use cron expressions.

For example, the following will fire a message every five minutes
starting at 12pm (noon) to 6pm on weekdays:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("quartz://myGroup/myTimerName?cron=0+0/5+12-18+?+*+MON-FRI").to("activemq:Totally.Rocks");
----

which is equivalent to using the cron expression

[source,brush:,java;,gutter:,false;,theme:,Default]
----
0 0/5 12-18 ? * MON-FRI
----

The following table shows the URI character encodings we use to preserve
valid URI syntax:

[width="100%",cols="50%,50%",options="header",]
|=============================
|URI Character |Cron character
|`+` |_Space_
|=============================

[[BookComponentAppendix-Specifyingtimezone]]
Specifying time zone
^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.8.1* +
The Quartz Scheduler allows you to configure time zone per trigger. For
example to use a timezone of your country, then you can do as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
quartz://groupName/timerName?cron=0+0/5+12-18+?+*+MON-FRI&trigger.timeZone=Europe/Stockholm
----

The timeZone value is the values accepted by `java.util.TimeZone`.

In Camel 2.8.0 or older versions you would have to provide your custom
`String` to `java.util.TimeZone` link:type-converter.html[Type
Converter] to be able configure this from the endpoint uri. +
From Camel 2.8.1 onwards we have included such a
link:type-converter.html[Type Converter] in the camel-core.

[[BookComponentAppendix-SeeAlso.26]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:quartz2.html[Quartz2]
* link:timer.html[Timer]

[[BookComponentAppendix-QuickFIX/JComponent]]
QuickFIX/J Component
~~~~~~~~~~~~~~~~~~~~

The *quickfix* component adapts the
http://www.quickfixj.org/[QuickFIX/J] FIX engine for using in Camel .
This component uses the standard http://www.fixprotocol.org/[Financial
Interchange (FIX) protocol] for message transport.

Previous Versions

The *quickfix* component was rewritten for Camel 2.5. For information
about using the *quickfix* component prior to 2.5 see the documentation
section below.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-quickfix</artifactId> <version>x.x.x</version> <!--
use the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.47]]
URI format
^^^^^^^^^^

quickfix:configFile[?sessionID=sessionID&lazyCreateEngine=true|false]

The *configFile* is the name of the QuickFIX/J configuration to use for
the FIX engine (located as a resource found in your classpath). The
optional *sessionID* identifies a specific FIX session. The format of
the sessionID is:

(BeginString):(SenderCompID)[/(SenderSubID)[/(SenderLocationID)]]->(TargetCompID)[/(TargetSubID)[/(TargetLocationID)]]

The optional *lazyCreateEngine* (Camel 2.12.3+) parameter allows to
create QuickFIX/J engine on demand. Value *true* means the engine is
started when first message is send or there's consumer configured in
route definition. When *false* value is used, the engine is started at
the endpoint creation. When this parameter is missing, the value of
component's property *lazyCreateEngines* is being used.

Example URIs:

quickfix:config.cfg
quickfix:config.cfg?sessionID=FIX.4.2:MyTradingCompany->SomeExchange
quickfix:config.cfg?sessionID=FIX.4.2:MyTradingCompany->SomeExchange&lazyCreateEngine=true

[[BookComponentAppendix-Endpoints]]
Endpoints
~~~~~~~~~

FIX sessions are endpoints for the *quickfix* component. An endpoint URI
may specify a single session or all sessions managed by a specific
QuickFIX/J engine. Typical applications will use only one FIX engine but
advanced users may create multiple FIX engines by referencing different
configuration files in *quickfix* component endpoint URIs.

When a consumer does not include a session ID in the endpoint URI, it
will receive exchanges for all sessions managed by the FIX engine
associated with the configuration file specified in the URI. If a
producer does not specify a session in the endpoint URI then it must
include the session-related fields in the FIX message being sent. If a
session is specified in the URI then the component will automatically
inject the session-related fields into the FIX message.

[[BookComponentAppendix-ExchangeFormat]]
Exchange Format
^^^^^^^^^^^^^^^

The exchange headers include information to help with exchange
filtering, routing and other processing. The following headers are
available:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header Name |Description
|EventCategory |One of `AppMessageReceived`, `AppMessageSent`,
`AdminMessageReceived`, `AdminMessageSent`, `SessionCreated`,
`SessionLogon`, `SessionLogoff`. See the `QuickfixjEventCategory` enum.

|SessionID |The FIX message SessionID

|MessageType |The FIX MsgType tag value

|DataDictionary |Specifies a data dictionary to used for parsing an
incoming message. Can be an instance of a data dictionary or a resource
path for a QuickFIX/J data dictionary file
|=======================================================================

The DataDictionary header is useful if string messages are being
received and need to be parsed in a route. QuickFIX/J requires a data
dictionary to parse certain types of messages (with repeating groups,
for example). By injecting a DataDictionary header in the route after
receiving a message string, the FIX engine can properly parse the data.

[[BookComponentAppendix-QuickFIX/JConfigurationExtensions]]
QuickFIX/J Configuration Extensions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When using QuickFIX/J directly, one typically writes code to create
instances of logging adapters, message stores and communication
connectors. The *quickfix* component will automatically create instances
of these classes based on information in the configuration file. It also
provides defaults for many of the common required settings and adds
additional capabilities (like the ability to activate JMX support).

The following sections describe how the *quickfix* component processes
the QuickFIX/J configuration. For comprehensive information about
QuickFIX/J configuration, see the
http://www.quickfixj.org/quickfixj/usermanual/usage/configuration.html[QFJ
user manual].

[[BookComponentAppendix-CommunicationConnectors]]
Communication Connectors
++++++++++++++++++++++++

When the component detects an initiator or acceptor session setting in
the QuickFIX/J configuration file it will automatically create the
corresponding initiator and/or acceptor connector. These settings can be
in the default or in a specific session section of the configuration
file.

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=========================================================
|Session Setting |Component Action
|`ConnectionType=initiator` |Create an initiator connector
|`ConnectionType=acceptor` |Create an acceptor connector
|=========================================================

The threading model for the QuickFIX/J session connectors can also be
specified. These settings affect all sessions in the configuration file
and must be placed in the settings default section.

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Default/Global Setting |Component Action
|`ThreadModel=ThreadPerConnector` |Use `SocketInitiator` or
`SocketAcceptor` (default)

|`ThreadModel=ThreadPerSession` |Use `ThreadedSocketInitiator` or
`ThreadedSocketAcceptor`
|=======================================================================

[[BookComponentAppendix-Logging]]
Logging
+++++++

The QuickFIX/J logger implementation can be specified by including the
following settings in the default section of the configuration file. The
`ScreenLog` is the default if none of the following settings are present
in the configuration. It's an error to include settings that imply more
than one log implementation. The log factory implementation can also be
set directly on the Quickfix component. This will override any related
values in the QuickFIX/J settings file.

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Default/Global Setting |Component Action
|`ScreenLogShowEvents` |Use a `ScreenLog`

|`ScreenLogShowIncoming` |Use a `ScreenLog`

|`ScreenLogShowOutgoing` |Use a `ScreenLog`

|`SLF4J*` |*Camel 2.6+*. Use a `SLF4JLog`. Any of the SLF4J settings
will cause this log to be used.

|`FileLogPath` |Use a `FileLog`

|`JdbcDriver` |Use a `JdbcLog`
|=======================================================================

[[BookComponentAppendix-MessageStore]]
Message Store
+++++++++++++

The QuickFIX/J message store implementation can be specified by
including the following settings in the default section of the
configuration file. The `MemoryStore` is the default if none of the
following settings are present in the configuration. It's an error to
include settings that imply more than one message store implementation.
The message store factory implementation can also be set directly on the
Quickfix component. This will override any related values in the
QuickFIX/J settings file.

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=============================================
|Default/Global Setting |Component Action
|`JdbcDriver` |Use a `JdbcStore`
|`FileStorePath` |Use a `FileStore`
|`SleepycatDatabaseDir` |Use a `SleepcatStore`
|=============================================

[[BookComponentAppendix-MessageFactory]]
Message Factory
+++++++++++++++

A message factory is used to construct domain objects from raw FIX
messages. The default message factory is `DefaultMessageFactory`.
However, advanced applications may require a custom message factory.
This can be set on the QuickFIX/J component.

[[BookComponentAppendix-JMX]]
JMX
+++

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|============================================
|Default/Global Setting |Component Action
|`UseJmx` |if `Y`, then enable QuickFIX/J JMX
|============================================

[[BookComponentAppendix-OtherDefaults]]
Other Defaults
++++++++++++++

The component provides some default settings for what are normally
required settings in QuickFIX/J configuration files. `SessionStartTime`
and `SessionEndTime` default to "00:00:00", meaning the session will not
be automatically started and stopped. The `HeartBtInt` (heartbeat
interval) defaults to 30 seconds.

[[BookComponentAppendix-MinimalInitiatorConfigurationExample]]
Minimal Initiator Configuration Example
+++++++++++++++++++++++++++++++++++++++

[SESSION] ConnectionType=initiator BeginString=FIX.4.4
SenderCompID=YOUR_SENDER TargetCompID=YOUR_TARGET

[[BookComponentAppendix-UsingtheInOutMessageExchangePattern]]
Using the InOut Message Exchange Pattern
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Camel 2.8+*

Although the FIX protocol is event-driven and asynchronous, there are
specific pairs of messages +
that represent a request-reply message exchange. To use an InOut
exchange pattern, there should +
be a single request message and single reply message to the request.
Examples include an +
OrderStatusRequest message and UserRequest.

[[BookComponentAppendix-ImplementingInOutExchangesforConsumers]]
Implementing InOut Exchanges for Consumers
++++++++++++++++++++++++++++++++++++++++++

Add "exchangePattern=InOut" to the QuickFIX/J enpoint URI. The
`MessageOrderStatusService` in +
the example below is a bean with a synchronous service method. The
method returns the response +
to the request (an ExecutionReport in this case) which is then sent back
to the requestor session.

from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER&exchangePattern=InOut")
.filter(header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.ORDER_STATUS_REQUEST))
.bean(new MarketOrderStatusService());

[[BookComponentAppendix-ImplementingInOutExchangesforProducers]]
Implementing InOut Exchanges for Producers
++++++++++++++++++++++++++++++++++++++++++

For producers, sending a message will block until a reply is received or
a timeout occurs. There +
is no standard way to correlate reply messages in FIX. Therefore, a
correlation criteria must be +
defined for each type of InOut exchange. The correlation criteria and
timeout can be specified +
using `Exchange` properties.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Description |Key String |Key Constant |Default
|Correlation Criteria |"CorrelationCriteria"
|QuickfixjProducer.CORRELATION_CRITERIA_KEY |None

|Correlation Timeout in Milliseconds |"CorrelationTimeout"
|QuickfixjProducer.CORRELATION_TIMEOUT_KEY |1000
|=======================================================================

The correlation criteria is defined with a `MessagePredicate` object.
The following example will treat +
a FIX ExecutionReport from the specified session where the transaction
type is STATUS and the Order ID +
matches our request. The session ID should be for the _requestor_, the
sender and target CompID fields +
will be reversed when looking for the reply.

exchange.setProperty(QuickfixjProducer.CORRELATION_CRITERIA_KEY, new
MessagePredicate(new SessionID(sessionID), MsgType.EXECUTION_REPORT)
.withField(ExecTransType.FIELD, Integer.toString(ExecTransType.STATUS))
.withField(OrderID.FIELD, request.getString(OrderID.FIELD)));

[[BookComponentAppendix-Example.9]]
Example
+++++++

The source code contains an example called `RequestReplyExample` that
demonstrates the InOut exchanges +
for a consumer and producer. This example creates a simple HTTP server
endpoint that accepts order +
status requests. The HTTP request is converted to a FIX
OrderStatusRequestMessage, is augmented with a +
correlation criteria, and is then routed to a quickfix endpoint. The
response is then converted to a +
JSON-formatted string and sent back to the HTTP server endpoint to be
provided as the web response.

The Spring configuration have changed from Camel 2.9 onwards. See
further below for example.

[[BookComponentAppendix-SpringConfiguration]]
Spring Configuration
^^^^^^^^^^^^^^^^^^^^

*Camel 2.6 - 2.8.x*

The QuickFIX/J component includes a Spring `FactoryBean` for configuring
the session settings within a Spring context. A type converter for
QuickFIX/J session ID strings is also included. The following example
shows a simple configuration of an acceptor and initiator session with
default settings for both sessions.

\{snippet:id=e1|lang=xml|url=camel/branches/camel-2.8.x/components/camel-quickfix/src/test/resources/org/apache/camel/component/quickfixj/QuickfixjSpringTest-context.xml}

*Camel 2.9 onwards*

The QuickFIX/J component includes a `QuickfixjConfiguration` class for
configuring the session settings. A type converter for QuickFIX/J
session ID strings is also included. The following example shows a
simple configuration of an acceptor and initiator session with default
settings for both sessions.

\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-quickfix/src/test/resources/org/apache/camel/component/quickfixj/QuickfixjSpringTest-context.xml}

[[BookComponentAppendix-Exceptionhandling]]
Exception handling
^^^^^^^^^^^^^^^^^^

QuickFIX/J behavior can be modified if certain exceptions are thrown
during processing of a message. If a `RejectLogon` exception is thrown
while processing an incoming logon administrative message, then the
logon will be rejected.

Normally, QuickFIX/J handles the logon process automatically. However,
sometimes an outgoing logon message must be modified to include
credentials required by a FIX counterparty. If the FIX logon message
body is modified when sending a logon message
(EventCategory=`AdminMessageSent` the modified message will be sent to
the counterparty. It is important that the outgoing logon message is
being processed _synchronously_. If it is processed asynchronously (on
another thread), the FIX engine will immediately send the unmodified
outgoing message when it's callback method returns.

[[BookComponentAppendix-FIXSequenceNumberManagement]]
FIX Sequence Number Management
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If an application exception is thrown during _synchronous_ exchange
processing, this will cause QuickFIX/J to not increment incoming FIX
message sequence numbers and will cause a resend of the counterparty
message. This FIX protocol behavior is primarily intended to handle
_transport_ errors rather than application errors. There are risks
associated with using this mechanism to handle application errors. The
primary risk is that the message will repeatedly cause application
errors each time it's re-received. A better solution is to persist the
incoming message (database, JMS queue) immediately before processing it.
This also allows the application to process messages asynchronously
without losing messages when errors occur.

Although it's possible to send messages to a FIX session before it's
logged on (the messages will be sent at logon time), it is usually a
better practice to wait until the session is logged on. This eliminates
the required sequence number resynchronization steps at logon. Waiting
for session logon can be done by setting up a route that processes the
`SessionLogon` event category and signals the application to start
sending messages.

See the FIX protocol specifications and the QuickFIX/J documentation for
more details about FIX sequence number management.

[[BookComponentAppendix-RouteExamples]]
Route Examples
^^^^^^^^^^^^^^

Several examples are included in the QuickFIX/J component source code
(test subdirectories). One of these examples implements a trival trade
excecution simulation. The example defines an application component that
uses the URI scheme "trade-executor".

The following route receives messages for the trade executor session and
passes application messages to the trade executor component.

from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER").
filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.AppMessageReceived)).
to("trade-executor:market");

The trade executor component generates messages that are routed back to
the trade session. The session ID must be set in the FIX message itself
since no session ID is specified in the endpoint URI.

from("trade-executor:market").to("quickfix:examples/inprocess.cfg");

The trader session consumes execution report messages from the market
and processes them.

from("quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET").
filter(header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.EXECUTION_REPORT)).
bean(new MyTradeExecutionProcessor());

[[BookComponentAppendix-QuickFIX/JComponentPriortoCamel2.5]]
QuickFIX/J Component Prior to Camel 2.5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *quickfix* component is an implementation of the
http://www.quickfixj.org/[QuickFIX/J] engine for Java . This engine
allows to connect to a FIX server which is used to exchange financial
messages according to http://www.fixprotocol.org/[FIX protocol]
standard.

*Note:* The component can be used to send/receives messages to a FIX
server.

[[BookComponentAppendix-URIformat.48]]
URI format
^^^^^^^^^^

quickfix-server:config file quickfix-client:config file

Where *config file* is the location (in your classpath) of the quickfix
configuration file used to configure the engine at the startup.

*Note:* Information about parameters available for quickfix can be found
on
http://www.quickfixj.org/quickfixj/usermanual/usage/configuration.html[QuickFIX/J]
web site.

The quickfix-server endpoint must be used to receive from FIX server FIX
messages and quickfix-client endpoint in the case that you want to send
messages to a FIX gateway.

[[BookComponentAppendix-Exchangedataformat.1]]
Exchange data format
^^^^^^^^^^^^^^^^^^^^

The QuickFIX/J engine is like CXF component a messaging bus using MINA
as protocol layer to create the socket connection with the FIX engine
gateway.

When QuickFIX/J engine receives a message, then it create a
QuickFix.Message instance which is next received by the camel endpoint.
This object is a 'mapping object' created from a FIX message formatted
initially as a collection of key value pairs data. You can use this
object or you can use the method 'toString' to retrieve the original FIX
message.

*Note:* Alternatively, you can use link:bindy.html[camel bindy
dataformat] to transform the FIX message into your own java POJO

When a message must be send to QuickFix, then you must create a
QuickFix.Message instance.

[[BookComponentAppendix-Lazycreatingengines]]
Lazy creating engines
^^^^^^^^^^^^^^^^^^^^^

From *Camel 2.12.3* onwards, you can configure the QuickFixComponent to
lazy create and start the engines, which then only start these
on-demand. For example you can use this when you have multiple Camel
applications in a cluster with master/slaves. And want the slaves to be
standby.

[[BookComponentAppendix-Samples.9]]
Samples
^^^^^^^

Direction : to FIX gateway

xml<route> <from uri="activemq:queue:fix"/> <bean ref="fixService"
method="createFixMessage"/> // bean method in charge to transform
message into a QuickFix.Message <to
uri="quickfix-client:META-INF/quickfix/client.cfg"/> // Quickfix engine
who will send the FIX messages to the gateway </route>

Direction : from FIX gateway

xml<route> <from uri="quickfix-server:META-INF/quickfix/server.cfg"/> //
QuickFix engine who will receive the message from FIX gateway <bean
ref="fixService" method="parseFixMessage"/> // bean method parsing the
QuickFix.Message <to uri="uri="activemq:queue:fix"/>" </route>

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-PrinterComponent]]
Printer Component
~~~~~~~~~~~~~~~~~

*Available as of Camel 2.1*

The *printer* component provides a way to direct payloads on a route to
a printer. Obviously the payload has to be a formatted piece of payload
in order for the component to appropriately print it. The objective is
to be able to direct specific payloads as jobs to a line printer in a
camel flow.

This component only supports a camel producer endpoint.

The functionality allows for the payload to be printed on a default
printer, named local, remote or wirelessly linked printer using the
javax printing API under the covers.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-printer</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.49]]
URI format
^^^^^^^^^^

Since the URI scheme for a printer has not been standardized (the
nearest thing to a standard being the IETF print standard) and therefore
not uniformly applied by vendors, we have chosen *"lpr"* as the scheme.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
lpr://localhost/default[?options]
lpr://remotehost:port/path/to/printer[?options]
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.39]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`mediaSize` |`NA_LETTER` |Sets the stationary as defined by enumeration
names in the
http://download.oracle.com/javase/6/docs/api/javax/print/attribute/standard/MediaSizeName.html[javax.print.attribute.standard.MediaSizeName
API]. The default setting is to use North American Letter sized
stationary. The value's case is ignored, e.g. values of `iso_a4` and
`ISO_A4` may be used.

|`copies` |`1` |Sets number of copies based on the
javax.print.attribute.standard.Copies API

|`sides` |`Sides.ONE_SIDED` |Sets one sided or two sided printing based
on the javax.print.attribute.standard.Sides API

|`flavor` |`DocFlavor.BYTE_ARRAY` |Sets DocFlavor based on the
javax.print.DocFlavor API

|`mimeType` |`AUTOSENSE` |Sets mimeTypes supported by the
javax.print.DocFlavor API

|`mediaTray` |`AUTOSENSE` |Since *Camel 2.11.x* sets MediaTray supported
by the javax.print.DocFlavor API

|`printerPrefix` |null |Since *Camel 2.11.x* sets the prefix name of the
printer, it is useful when the printer name does not start with
//hostname/printer

|`sendToPrinter` |true |Setting this option to `false` prevents sending
of the
http://docs.oracle.com/javase/6/docs/api/javax/print/Doc.html[print
data] to the printer

|`orientation` |`portrait` |Since *Camel 2.13.x* Sets the page
orientation. Possible values: `portrait`, `landscape`,
`reverse-portrait` or `reverse-landscape`, based on
`javax.print.attribute.standard.OrientationRequested`
|=======================================================================

[[BookComponentAppendix-SendingMessagestoaPrinter]]
Sending Messages to a Printer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-PrinterProducer]]
Printer Producer
++++++++++++++++

Sending data to the printer is very straightforward and involves
creating a producer endpoint that can be sent message exchanges on in
route.

[[BookComponentAppendix-UsageSamples.1]]
Usage Samples
^^^^^^^^^^^^^

[[BookComponentAppendix-Example1:PrintingtextbasedpayloadsonaDefaultprinterusingletterstationaryandone-sidedmode]]
Example 1: Printing text based payloads on a Default printer using
letter stationary and one-sided mode
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
       from(file://inputdir/?delete=true)
       .to("lpr://localhost/default?copies=2" +
           "&flavor=DocFlavor.INPUT_STREAM&" +
           "&mimeType=AUTOSENSE" +
           "&mediaSize=NA_LETTER" +
           "&sides=one-sided")
    }};
----

[[BookComponentAppendix-Example2:PrintingGIFbasedpayloadsonaRemoteprinterusingA4stationaryandone-sidedmode]]
Example 2: Printing GIF based payloads on a Remote printer using A4
stationary and one-sided mode
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
       from(file://inputdir/?delete=true)
       .to("lpr://remotehost/sales/salesprinter" +
           "?copies=2&sides=one-sided" +
           "&mimeType=GIF&mediaSize=ISO_A4" +
           "&flavor=DocFlavor.INPUT_STREAM")
   }};
----

[[BookComponentAppendix-Example3:PrintingJPEGbasedpayloadsonaRemoteprinterusingJapanesePostcardstationaryandone-sidedmode]]
Example 3: Printing JPEG based payloads on a Remote printer using
Japanese Postcard stationary and one-sided mode
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RouteBuilder builder = new RouteBuilder() {
    public void configure() {
       from(file://inputdir/?delete=true)
       .to("lpr://remotehost/sales/salesprinter" +
           "?copies=2&sides=one-sided" +
           "&mimeType=JPEG" +
           "&mediaSize=JAPANESE_POSTCARD" +
           "&flavor=DocFlavor.INPUT_STREAM")
    }};
----

[[BookComponentAppendix-PropertiesComponent]]
Properties Component
~~~~~~~~~~~~~~~~~~~~

*Available from Camel 2.3*

[[BookComponentAppendix-URIformat.50]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
properties:key[?options]
----

Where *`key`* is the key for the property to be looked up.

[[BookComponentAppendix-Options.40]]
Options
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |Type |Default |Description
|`cache` |`boolean` |`true` |Whether or not to cache loaded properties.

|`encoding` |`String` |`null` a|
*Camel 2.14.3/2.15.1:* The charset to use when loading properties, such
as *`UTF-8`*.

The default charset is: *`ISO-8859-1`* (*`latin1`*).

|`fallbackToUnaugmentedProperty` |`boolean` |`true` a|
*Camel 2.9* If *`true`*, first attempt resolution of property name
augmented with *`propertyPrefix`* and *`propertySuffix`* before falling
back the plain property name specified.

If *`false`*, only the augmented property name is searched.

|`defaultFallbackEnabled` |`boolean` |`true` |*Camel 2.19*: If *`false`*
the component will not attempt to find a default for the key by looking
after the colon separator.

|`ignoreMissingLocation` |`boolean` |`false` |*Camel 2.10:* Whether to
silently ignore if a location cannot be located, such as a properties
file not found.

|`locations` |`String` |`null` |A comma separated list of one or more
locations of property files to be loaded. Property resolution will use
the given property files exclusively. Any default location(s) are
ignored.

|`prefixToken` |`String` |`{{` |*Camel 2.9* This token is used to mark
the start of a property placeholder definition.

|`propertyPrefix` |`String` |`null` |*Camel 2.9* An optional prefix
that's _prepended_ to each property name prior to resolution.

|`propertySuffix` |`String` |`null` |*Camel 2.9* An optional suffix
that's _appended_ to each property name prior to resolution.

|`suffixToken` |`String` |`}}` |*Camel 2.9* This token is used to mark
the end of a property placeholder definition.

|`systemPropertiesMode` |`int` |`2` a|
*Camel 2.16* The mode to use for whether to resolve and use system
properties:

*`0`* = never - JVM system properties are never used. +
*`1`* = fallback - JVM system properties are only used as fallback if no
regular property with the key exists. +
*`2`* = override - JVM system properties are used if exists, otherwise
the regular property will be used.

[Warning]
====
 **Bridging Spring and Camel Property Placeholders**

When bridging to Spring's property placeholder using
*`org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer`* the
configuration on *`BridgePropertyPlaceholderConfigurer`* will take
precedence over the configuration on the *`PropertiesComponent`*. 

====

|=======================================================================

[Tip]
====
 **Resolving property from Java code**

You can use the method *`resolvePropertyPlaceholders`* on the
*`CamelContext`* to resolve a property from any Java code.

====

[[BookComponentAppendix-UsingPropertyPlaceholder]]
Using *`PropertyPlaceholder`*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.3*

Camel now provides a new *`PropertiesComponent`* in *`camel-core`* which
allows you to use property placeholders when defining Camel
link:endpoint.html[Endpoint] URIs. This works much like you would do if
using Spring's *`<property-placeholder>`* tag. However Spring has a
limitation that prevents third-party frameworks from fully leveraging
Spring property placeholders.

For more details see:
link:how-do-i-use-spring-property-placeholder-with-camel-xml.html[How do
I use Spring Property Placeholder with Camel XML].

Bridging Spring and Camel Property Placeholders

From *Camel 2.10*: Spring's property placeholder can be bridged with
Camel's. See below for more details.

The property placeholder is typically used when trying to do any of the
following:

* Lookup or creating endpoints.
* Lookup of beans in the link:registry.html[Registry.]
* Additional supported in Spring XML (see below in examples).
* Using Blueprint *`PropertyPlaceholder`* with Camel
link:properties.html[Properties] component.
* Using *`@PropertyInject`* to inject a property in a POJO.
* *Camel 2.14.1* Using default value if a property does not exists.
* *Camel 2.14.1* Include out of the box functions, to lookup property
values from OS environment variables, JVM system properties, or the
service idiom.
* *Camel 2.14.1* Using custom functions, which can be plugged into the
property component.

[[BookComponentAppendix-Format]]
Format
^^^^^^

The value of a Camel property can be obtained by specifying its key name
within a property placeholder, using the following format:
*\{\{`key`}}*.

For example:

\{\{file.uri}}

where *`file.uri`* is the property key.

Property placeholders can be used to specify parts, or all, of an
endpoint's URI by embedding one or more placeholders in the URI's string
definition.

From *Camel 2.14.1*: you can specify a default value to use if a
property with the key does not exists, e.g., *`file.url:/some/path`*
where the default value is the text after the colon, e.g.,
*`/some/path`*.

From *Camel 2.14.1*: do _not_ use a colon in the property key. The colon
character is used as a token separator when providing a default value.

[[BookComponentAppendix-UsingPropertyResolver]]
Using `PropertyResolver`
^^^^^^^^^^^^^^^^^^^^^^^^

Camel provides a pluggable mechanism that allows third-parties to
specify their own resolver to use for the lookup of properties.

Camel provides a default implementation
*`org.apache.camel.component.properties.DefaultPropertiesResolver`*
which is capable of loading properties from the file system, classpath
or link:registry.html[Registry]. To indicate which source to use the
location must contain the appropriate prefix.

The list of prefixes is:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Prefix |Description
|`ref:` |Lookup in the link:registry.html[Registry.]

|`file:` |Load the from file system.

|`classpath:` |Load from the classpath (this is also the default if no
prefix is provided).

|`blueprint:` |Use a specific OSGi blueprint placeholder service.
|=======================================================================

[[BookComponentAppendix-DefiningLocation]]
Defining Location
^^^^^^^^^^^^^^^^^

The *`PropertiesResolver`* must be configured with the location(s) to
use when resolving properties. One or more locations can be given.
Specifying multiple locations can be done a couple of ways: using either
a single comma separated string, or an array of strings.

javapc.setLocation("com/mycompany/myprop.properties,com/mycompany/other.properties");
pc.setLocation(new String[] \{"com/mycompany/myprop.properties",
"com/mycompany/other.properties"}); 

From *Camel 2.19.0*: you can set which location can be discarded if
missing by setting  *`optional=true`*, (*`false`* by default).

Example:

 

javapc.setLocations("com/mycompany/override.properties;optional=true,com/mycompany/defaults.properties");

 

[[BookComponentAppendix-UsingSystemandEnvironmentVariablesinLocations]]
Using System and Environment Variables in Locations
+++++++++++++++++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.7*

The location now supports using placeholders for JVM system properties
and OS environments variables.

Example:

location=file:$\{karaf.home}/etc/foo.properties

In the location above we defined a location using the file scheme using
the JVM system property with key *`karaf.home`*.

To use an OS environment variable instead you would have to prefix with
*`env`*:

location=file:$\{env:APP_HOME}/etc/foo.properties

Where *`APP_HOME`* is an OS environment variable.

You can have multiple placeholders in the same location, such as:

location=file:$\{env:APP_HOME}/etc/$\{prop.name}.properties

[[BookComponentAppendix-UsingSystemorEnvironmentVariablestoConfigurePropertyPrefixesandSuffixes]]
Using System or Environment Variables to Configure Property Prefixes and
Suffixes
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

From *Camel 2.12.5, 2.13.3, 2.14.0*:*` propertyPrefix`*,
*`propertySuffix`* configuration properties support the use of
placeholders for de-referencing JVM system properties and OS
environments variables.

Example:

Assume the *`PropertiesComponent`* is configured with the following
properties file:

textdev.endpoint = result1 test.endpoint = result2

The same properties file is then referenced from a route definition:

javaPropertiesComponent pc = context.getComponent("properties",
PropertiesComponent.class); pc.setPropertyPrefix("$\{stage}."); // ...
context.addRoutes(new RouteBuilder() \{ @Override public void
configure() throws Exception \{ from("direct:start")
.to("properties:mock:\{\{endpoint}}"); } });

By using the configuration options *`propertyPrefix`* it's possible to
change the target endpoint simply by changing the value of the system
property *`stage`* either to *`dev`* (the message will be routed
to *`mock:result1`*) or *`test`* (the message will be routed
to *`mock:result2`*).

[[BookComponentAppendix-ConfiguringinJavaDSL]]
Configuring in Java DSL
^^^^^^^^^^^^^^^^^^^^^^^

You have to create and register the *`PropertiesComponent`* under the
name *`properties`* such as:

javaPropertiesComponent pc = new PropertiesComponent();
pc.setLocation("classpath:com/mycompany/myprop.properties");
context.addComponent("properties", pc);

[[BookComponentAppendix-ConfiguringinSpringXML]]
Configuring in Spring XML
^^^^^^^^^^^^^^^^^^^^^^^^^

Spring XML offers two variations to configure. You can define a spring
bean as a *`PropertiesComponent`* which resembles the way done in Java
DSL. Or you can use the *`<propertyPlaceholder>`* tag.

xml<bean id="properties"
class="org.apache.camel.component.properties.PropertiesComponent">
<property name="location"
value="classpath:com/mycompany/myprop.properties"/> </bean>

Using the *`<propertyPlaceholder>`* tag makes the configuration a bit
more fresh such as:

xml<camelContext ...> <propertyPlaceholder id="properties"
location="com/mycompany/myprop.properties"/> </camelContext>

Setting the properties location through the location tag works just fine
but sometime you have a number of resources to take into account and
starting from **Camel 2.19.0** you can set the properties location with
a dedicated *`propertiesLocation`*:

xml<camelContext ...> <propertyPlaceholder id="myPropertyPlaceholder">
<propertiesLocation resolver = "classpath" path =
"com/my/company/something/my-properties-1.properties" optional =
"false"/> <propertiesLocation resolver = "classpath" path =
"com/my/company/something/my-properties-2.properties" optional =
"false"/> <propertiesLocation resolver = "file" path =
"$\{karaf.home}/etc/my-override.properties" optional = "true"/>
</propertyPlaceholder> </camelContext>Specifying the cache option in XML

From *Camel 2.10*: Camel supports specifying a value for the *`cache`*
option both inside the Spring as well as the Blueprint XML.

[[BookComponentAppendix-UsingaPropertiesfromthe]]
Using a Properties from the link:registry.html[Registry]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.4* +
For example in OSGi you may want to expose a service which returns the
properties as a *`java.util.Properties`* object.

Then you could setup the link:properties.html[Properties] component as
follows:

xml<propertyPlaceholder id="properties" location="ref:myProperties"/>

Where *`myProperties`* is the id to use for lookup in the OSGi registry.
Notice we use the *`ref:`* prefix to tell Camel that it should lookup
the properties for the link:registry.html[Registry].

[[BookComponentAppendix-ExamplesUsingPropertiesComponent]]
Examples Using Properties Component
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When using property placeholders in the endpoint URIs you can either use
the *`properties:`* component or define the placeholders directly in the
URI. We will show example of both cases, starting with the former.

java// properties cool.end=mock:result // route from("direct:start")
.to("properties:\{\{cool.end}}");

You can also use placeholders as a part of the endpoint URI:

java// properties cool.foo=result // route from("direct:start")
.to("properties:mock:\{\{cool.foo}}");

In the example above the to endpoint will be resolved to
*`mock:result`*.

You can also have properties with refer to each other such as:

java// properties cool.foo=result cool.concat=mock:\{\{cool.foo}} //
route from("direct:start") .to("properties:mock:\{\{cool.concat}}");

Notice how *`cool.concat`* refer to another property.

The *`properties:`* component also offers you to override and provide a
location in the given URI using the *`locations`* option:

javafrom("direct:start")
.to("properties:bar.end?locations=com/mycompany/bar.properties");

[[BookComponentAppendix-Examples.13]]
Examples
^^^^^^^^

You can also use property placeholders directly in the endpoint URIs
without having to use *`properties:`*.

java// properties cool.foo=result // route from("direct:start")
.to("mock:\{\{cool.foo}}");

And you can use them in multiple wherever you want them:

java// properties cool.start=direct:start cool.showid=true
cool.result=result // route from("\{\{cool.start}}")
.to("log:\{\{cool.start}}?showBodyType=false&showExchangeId=\{\{cool.showid}}")
.to("mock:\{\{cool.result}}");

You can also your property placeholders when using
link:producertemplate.html[ProducerTemplate] for example:

javatemplate.sendBody("\{\{cool.start}}", "Hello World");

[[BookComponentAppendix-Examplewithlanguage]]
Example with link:simple.html[Simple] language
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The link:simple.html[Simple] language now also support using property
placeholders, for example in the route below:

java// properties cheese.quote=Camel rocks // route from("direct:start")
.transform().simple("Hi $\{body} do you think
$\{properties:cheese.quote}?");

You can also specify the location in the link:simple.html[Simple]
language for example:

java// bar.properties bar.quote=Beer tastes good // route
from("direct:start") .transform().simple("Hi $\{body}.
$\{properties:com/mycompany/bar.properties:bar.quote}.");

[[BookComponentAppendix-AdditionalPropertyPlaceholderSupportinSpringXML]]
Additional Property Placeholder Support in Spring XML
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The property placeholders is also supported in many of the Camel Spring
XML tags such as
`<package>, <packageScan>, <contextScan>, <jmxAgent>, <endpoint>, <routeBuilder>, <proxy>`
and the others.

Example:

xmlUsing property placeholders in the <jmxAgent> tag<camelContext
xmlns="http://camel.apache.org/schema/spring"> <propertyPlaceholder
id="properties" location="org/apache/camel/spring/jmx.properties"/> <!--
we can use propery placeholders when we define the JMX agent -->
<jmxAgent id="agent" registryPort="\{\{myjmx.port}}"
disabled="\{\{myjmx.disabled}}"
usePlatformMBeanServer="\{\{myjmx.usePlatform}}" createConnector="true"
statisticsLevel="RoutesOnly" useHostIPAddress="true"/> <route id="foo"
autoStartup="false"> <from uri="seda:start"/> <to uri="mock:result"/>
</route> </camelContext>

Example:

xmlUsing property placeholders in the attributes of
<camelContext><camelContext trace="\{\{foo.trace}}"
xmlns="http://camel.apache.org/schema/spring"> <propertyPlaceholder
id="properties"
location="org/apache/camel/spring/processor/myprop.properties"/>
<template id="camelTemplate" defaultEndpoint="\{\{foo.cool}}"/> <route>
<from uri="direct:start"/> <setHeader headerName="\{\{foo.header}}">
<simple>$\{in.body} World!</simple> </setHeader> <to uri="mock:result"/>
</route> </camelContext>

[[BookComponentAppendix-OverridingaPropertySettingUsingaJVMSystemProperty]]
Overriding a Property Setting Using a JVM System Property
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.5* +
It is possible to override a property value at runtime using a JVM
System property without the need to restart the application to pick up
the change. This may also be accomplished from the command line by
creating a JVM System property of the same name as the property it
replaces with a new value.

Example:

javaPropertiesComponent pc = context.getComponent("properties",
PropertiesComponent.class); pc.setCache(false);
System.setProperty("cool.end", "mock:override");
System.setProperty("cool.result", "override"); context.addRoutes(new
RouteBuilder() \{ @Override public void configure() throws Exception \{
from("direct:start").to("properties:cool.end");
from("direct:foo").to("properties:mock:\{\{cool.result}}"); } });
context.start();
getMockEndpoint("mock:override").expectedMessageCount(2);
template.sendBody("direct:start", "Hello World");
template.sendBody("direct:foo", "Hello Foo");
System.clearProperty("cool.end"); System.clearProperty("cool.result");
assertMockEndpointsSatisfied();

[[BookComponentAppendix-UsingPropertyPlaceholdersforAnyKindofAttributeintheXMLDSL]]
Using Property Placeholders for Any Kind of Attribute in the XML DSL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.7*

If you use OSGi Blueprint then this only works from *2.11.1* or *2.10.5*
on.

Previously it was only the *`xs:string`* type attributes in the XML DSL
that support placeholders. For example often a timeout attribute would
be a *`xs:int`* type and thus you cannot set a string value as the
placeholder key. This is now possible from Camel 2.7 on using a special
placeholder namespace.

In the example below we use the *`prop`* prefix for the namespace
`http://camel.apache.org/schema/placeholder` by which we can use the
*`prop`* prefix in the attributes in the XML DSLs. Notice how we use
that in the link:multicast.html[Multicast] to indicate that the option
*`stopOnException`* should be the value of the placeholder with the key
*`stop`*.

xml<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:prop="http://camel.apache.org/schema/placeholder"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://camel.apache.org/schema/spring
http://camel.apache.org/schema/spring/camel-spring.xsd"> <!-- Notice in
the declaration above, we have defined the prop prefix as the Camel
placeholder namespace --> <bean id="damn"
class="java.lang.IllegalArgumentException"> <constructor-arg index="0"
value="Damn"/> </bean> <camelContext
xmlns="http://camel.apache.org/schema/spring"> <propertyPlaceholder
id="properties"
location="classpath:org/apache/camel/component/properties/myprop.properties"
xmlns="http://camel.apache.org/schema/spring"/> <route> <from
uri="direct:start"/> <!-- use prop namespace, to define a property
placeholder, which maps to option stopOnException=\{\{stop}} -->
<multicast prop:stopOnException="stop"> <to uri="mock:a"/>
<throwException ref="damn"/> <to uri="mock:b"/> </multicast> </route>
</camelContext> </beans>

In our properties file we have the value defined as

stop=true

[[BookComponentAppendix-UsingPropertyPlaceholderintheJavaDSL]]
Using Property Placeholder in the Java DSL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.7*

Likewise we have added support for defining placeholders in the Java DSL
using the new *`placeholder`* DSL as shown in the following equivalent
example:

javafrom("direct:start") // use a property placeholder for the option
stopOnException on the Multicast EIP // which should have the value of
\{\{stop}} key being looked up in the properties file .multicast()
.placeholder("stopOnException", "stop") .to("mock:a")
.throwException(new IllegalAccessException("Damn")) .to("mock:b");

[[BookComponentAppendix-UsingBlueprintPropertyPlaceholderwithCamelRoutes]]
Using Blueprint Property Placeholder with Camel Routes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.7*

Camel supports link:using-osgi-blueprint-with-camel.html[Blueprint]
which also offers a property placeholder service. Camel supports
convention over configuration, so all you have to do is to define the
OSGi Blueprint property placeholder in the XML file as shown below:

xml<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0
https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"> <!-- OSGI
blueprint property placeholder --> <cm:property-placeholder
id="myblueprint.placeholder" persistent-id="camel.blueprint"> <!-- list
some properties as needed --> <cm:default-properties> <cm:property
name="result" value="mock:result"/> </cm:default-properties>
</cm:property-placeholder> <camelContext
xmlns="http://camel.apache.org/schema/blueprint"> <!-- in the route we
can use \{\{ }} placeholders which will lookup in blueprint as Camel
will auto detect the OSGi blueprint property placeholder and use it -->
<route> <from uri="direct:start"/> <to uri="mock:foo"/> <to
uri="\{\{result}}"/> </route> </camelContext> </blueprint>

By default Camel detects and uses OSGi blueprint property placeholder
service. You can disable this by setting the attribute
**`useBlueprintPropertyResolver`** to false on the **`<camelContext>`**
definition.

About placeholder syntaxes

Notice how we can use the Camel syntax for placeholders `{{ }}` in the
Camel route, which will lookup the value from OSGi blueprint. +
The blueprint syntax for placeholders is *`${}`*. So outside
the *`<camelContext>`* you must use the *`${}`* syntax. Where as
inside *`<camelContext>`* you must use `{{ }}` syntax. OSGi blueprint
allows you to configure the syntax, so you can actually align those if
you want.

You can also explicit refer to a specific OSGi blueprint property
placeholder by its id. For that you need to use the
Camel's *`<propertyPlaceholder>`* as shown in the example below:

xml<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0
https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"> <!-- OSGI
blueprint property placeholder --> <cm:property-placeholder
id="myblueprint.placeholder" persistent-id="camel.blueprint"> <!-- list
some properties as needed --> <cm:default-properties> <cm:property
name="prefix.result" value="mock:result"/> </cm:default-properties>
</cm:property-placeholder> <camelContext
xmlns="http://camel.apache.org/schema/blueprint"> <!-- using Camel
properties component and refer to the blueprint property placeholder by
its id --> <propertyPlaceholder id="properties"
location="blueprint:myblueprint.placeholder" prefixToken="[["
suffixToken="]]" propertyPrefix="prefix."/> <!-- in the route we can use
\{\{ }} placeholders which will lookup in blueprint --> <route> <from
uri="direct:start"/> <to uri="mock:foo"/> <to uri="[[result]]"/>
</route> </camelContext> </blueprint>

Notice how we use the *`blueprint`* scheme to refer to the OSGi
blueprint placeholder by its id. This allows you to mix and match, for
example you can also have additional schemes in the location. For
example to load a file from the classpath you can do:

location="blueprint:myblueprint.placeholder,classpath:myproperties.properties"

Each location is separated by comma.

[[BookComponentAppendix-OverridingBlueprintPropertyPlaceholdersOutsideCamelContext]]
Overriding Blueprint Property Placeholders Outside CamelContext
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.10.4*

When using Blueprint property placeholder in the Blueprint XML file, you
can declare the properties directly in the XML file as shown
below:\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-test-blueprint/src/test/resources/org/apache/camel/test/blueprint/configadmin-outside.xml}Notice
that we have a *`<bean>`* which refers to one of the properties. And in
the Camel route we refer to the other using the *`{{ }}`* notation.

Now if you want to override these Blueprint properties from an unit
test, you can do this as shown
below:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-test-blueprint/src/test/java/org/apache/camel/test/blueprint/ConfigAdminOverridePropertiesOutsideCamelContextTest.java}To
do this we override and implement the
*`useOverridePropertiesWithConfigAdmin`* method. We can then put the
properties we want to override on the given props parameter. And the
return value _must_ be the persistence-id of
the *`<cm:property-placeholder>`* tag, which you define in the blueprint
XML file.

[[BookComponentAppendix-Usinga.cfgor.propertiesFileForBlueprintPropertyPlaceholders]]
Using a `.cfg` or `.properties` File For Blueprint Property Placeholders
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.10.4*

When using Blueprint property placeholder in the Blueprint XML file, you
can declare the properties in a .properties or *`.cfg`* file. If you use
Apache ServiceMix/Karaf then this container has a convention that it
loads the properties from a file in the etc directory with the naming
*`etc/pid.cfg`*, where *`pid`* is the persistence-id.

For example in the blueprint XML file we have the
*`persistence-id="stuff"`*, which mean it will load the configuration
file as
*`etc/stuff.cfg`*.\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-test-blueprint/src/test/resources/org/apache/camel/test/blueprint/configadmin-loadfile.xml}Now
if you want to unit test this blueprint XML file, then you can override
the *`loadConfigAdminConfigurationFile`* and tell Camel which file to
load as shown
below:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-test-blueprint/src/test/java/org/apache/camel/test/blueprint/ConfigAdminLoadConfigurationFileTest.java}Notice
that this method requires to return a *`String[]`* with 2 values. The
1st value is the path for the configuration file to load. The second
value is the persistence-id of the *`<cm:property-placeholder>`* tag.

The *`stuff.cfg`* file is just a plain properties file with the property
placeholders such as:

## this is a comment greeting=Bye

[[BookComponentAppendix-Usinga.cfgfileandOverridingPropertiesforBlueprintPropertyPlaceholders]]
Using a `.cfg` file and Overriding Properties for Blueprint Property
Placeholders
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

You can do both as well. Here is a complete example. First we have the
Blueprint XML
file:\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-test-blueprint/src/test/resources/org/apache/camel/test/blueprint/configadmin-loadfileoverride.xml}And
in the unit test class we do as
follows:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-test-blueprint/src/test/java/org/apache/camel/test/blueprint/ConfigAdminLoadConfigurationFileAndOverrideTest.java}And
the *`etc/stuff.cfg`* configuration file contains:

greeting=Bye echo=Yay destination=mock:result

[[BookComponentAppendix-BridgingSpringandCamelPropertyPlaceholders]]
Bridging Spring and Camel Property Placeholders
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.10*

The Spring Framework does not allow third-party frameworks such as
Apache Camel to seamless hook into the Spring property placeholder
mechanism. However you can easily bridge Spring and Camel by declaring a
Spring bean with the type
*`org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer`*,
which is a Spring
*`org.springframework.beans.factory.config.PropertyPlaceholderConfigurer`*
type.

To bridge Spring and Camel you must define a single bean as shown
below:\{snippet:id=e1|lang=xml|title=Bridging Spring and Camel property
placeholders|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/component/properties/CamelSpringPropertyPlaceholderConfigurerTest.xml}You
*must not* use the spring *`<context:property-placeholder>`* namespace
at the same time; this is not possible.

After declaring this bean, you can define property placeholders using
both the Spring style, and the Camel style within the *`<camelContext>`*
tag as shown below:\{snippet:id=e2|lang=xml|title=Using bridge property
placeholders|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/component/properties/CamelSpringPropertyPlaceholderConfigurerTest.xml}Notice
how the hello bean is using pure Spring property placeholders using
the *`${}`* notation. And in the Camel routes we use the Camel
placeholder notation with *`{{ }}`*.

[[BookComponentAppendix-ClashingSpringPropertyPlaceholderswithCamelsLanguage]]
Clashing Spring Property Placeholders with Camels
link:simple.html[Simple] Language
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Take notice when using Spring bridging placeholder then the
spring *`${}`* syntax clashes with the link:simple.html[Simple] in
Camel, and therefore take care.

Example:

xml<setHeader headerName="Exchange.FILE_NAME">
<simple>\{\{file.rootdir}}/$\{in.header.CamelFileName}</simple>
</setHeader>

clashes with Spring property placeholders, and you should
use *`$simple{}`* to indicate using the link:simple.html[Simple]
language in Camel.

xml<setHeader headerName="Exchange.FILE_NAME">
<simple>\{\{file.rootdir}}/$simple\{in.header.CamelFileName}</simple>
</setHeader>

An alternative is to configure the *`PropertyPlaceholderConfigurer`*
with *`ignoreUnresolvablePlaceholders`* option to *`true`*.

[[BookComponentAppendix-OverridingPropertiesfromCamelTestKit]]
Overriding Properties from Camel Test Kit
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.10*

When link:testing.html[Testing] with Camel and using the
link:properties.html[Properties] component, you may want to be able to
provide the properties to be used from directly within the unit test
source code. This is now possible from Camel 2.10, as the Camel test
kits, e.g., *`CamelTestSupport`* class offers the following methods

* *`useOverridePropertiesWithPropertiesComponent`*
* *`ignoreMissingLocationWithPropertiesComponent`*

So for example in your unit test classes, you can override the
*`useOverridePropertiesWithPropertiesComponent`* method and return a
*`java.util.Properties`* that contains the properties which should be
preferred to be used.\{snippet:id=e1|lang=java|title=Providing
properties from within unit test
source|url=camel/trunk/components/camel-test-blueprint/src/test/java/org/apache/camel/test/blueprint/ConfigAdminOverridePropertiesTest.java}This
can be done from any of the Camel Test kits, such as *`camel-test`*,
*`camel-test-spring`* and *`camel-test-blueprint`*.

The *`ignoreMissingLocationWithPropertiesComponent`* can be used to
instruct Camel to ignore any locations which was not discoverable. For
example if you run the unit test, in an environment that does not have
access to the location of the properties.

[[BookComponentAppendix-Using@PropertyInject]]
Using `@PropertyInject`
^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.12*

Camel allows to inject property placeholders in POJOs using
the *`@PropertyInject`* annotation which can be set on fields and setter
methods. For example you can use that with *`RouteBuilder`* classes,
such as shown below:

javapublic class MyRouteBuilder extends RouteBuilder \{
@PropertyInject("hello") private String greeting; @Override public void
configure() throws Exception \{ from("direct:start")
.transform().constant(greeting) .to("\{\{result}}"); } }

Notice we have annotated the greeting field with *`@PropertyInject`* and
define it to use the key *`hello`*. Camel will then lookup the property
with this key and inject its value, converted to a String type.

You can also use multiple placeholders and text in the key, for example
we can do:

java@PropertyInject("Hello \{\{name}} how are you?") private String
greeting;

This will lookup the placeholder with they key *`name`*.

You can also add a default value if the key does not exists, such as:

java@PropertyInject(value = "myTimeout", defaultValue = "5000") private
int timeout;

[[BookComponentAppendix-UsingOutoftheBoxFunctions]]
Using Out of the Box Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.14.1*

The link:properties.html[Properties] component includes the following
functions out of the box

* *`env`* - A function to lookup the property from OS environment
variables.
* *`sys`* - A function to lookup the property from Java JVM system
properties.
* *`service`* - A function to lookup the property from OS environment
variables using the service naming idiom.
* *`service.host`* - **Camel 2.16.1: **A function to lookup the
property from OS environment variables using the service naming idiom
returning the hostname part only.
* *`service.port`* - **Camel 2.16.1: **A function to lookup the
property from OS environment variables using the service naming idiom
returning the port part only.

As you can see these functions is intended to make it easy to lookup
values from the environment. As they are provided out of the box, they
can easily be used as shown below:

xml<camelContext xmlns="http://camel.apache.org/schema/blueprint">
<route> <from uri="direct:start"/> <to uri="\{\{env:SOMENAME}}"/> <to
uri="\{\{sys:MyJvmPropertyName}}"/> </route> </camelContext>

You can use default values as well, so if the property does not exists,
you can define a default value as shown below, where the default value
is a *`log:foo`* and *`log:bar`* value.

xml<camelContext xmlns="http://camel.apache.org/schema/blueprint">
<route> <from uri="direct:start"/> <to
uri="\{\{env:SOMENAME:log:foo}}"/> <to
uri="\{\{sys:MyJvmPropertyName:log:bar}}"/> </route> </camelContext>

The service function is for looking up a service which is defined using
OS environment variables using the service naming idiom, to refer to a
service location using *`hostname : port`*

* __`NAME`__**`_SERVICE_HOST`**
* __`NAME`__**`_SERVICE_PORT`**

in other words the service uses *`_SERVICE_HOST`* and *`_SERVICE_PORT`*
as prefix. So if the service is named *`FOO`*, then the OS environment
variables should be set as

export $FOO_SERVICE_HOST=myserver export $FOO_SERVICE_PORT=8888

For example if the *`FOO`* service a remote HTTP service, then we can
refer to the service in the Camel endpoint URI, and use
the link:http.html[HTTP] component to make the HTTP call:

xml<camelContext xmlns="http://camel.apache.org/schema/blueprint">
<route> <from uri="direct:start"/> <to
uri="http://\{\{service:FOO}}/myapp"/> </route> </camelContext>

And we can use default values if the service has not been defined, for
example to call a service on localhost, maybe for unit testing etc:

xml<camelContext xmlns="http://camel.apache.org/schema/blueprint">
<route> <from uri="direct:start"/> <to
uri="http://\{\{service:FOO:localhost:8080}}/myapp"/> </route>
</camelContext>

[[BookComponentAppendix-UsingCustomFunctions]]
Using Custom Functions
^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.14.1*

The link:properties.html[Properties] component allow to plugin 3rd party
functions which can be used during parsing of the property placeholders.
These functions are then able to do custom logic to resolve the
placeholders, such as looking up in databases, do custom computations,
or whatnot. The name of the function becomes the prefix used in the
placeholder. This is best illustrated in the example code below

xml<bean id="beerFunction" class="MyBeerFunction"/> <camelContext
xmlns="http://camel.apache.org/schema/blueprint"> <propertyPlaceholder
id="properties" location="none" ignoreMissingLocation="true">
<propertiesFunction ref="beerFunction"/> </propertyPlaceholder> <route>
<from uri="direct:start"/> <to uri="\{\{beer:FOO}}"/> <to
uri="\{\{beer:BAR}}"/> </route> </camelContext>

Here we have a Camel XML route where we have defined
the *`<propertyPlaceholder>`* to use a custom function, which we refer
to be the bean id - e.g., the *`beerFunction`*. As the beer function
uses *`beer`* as its name, then the placeholder syntax can trigger the
beer function by starting with *`beer:value`*.

The implementation of the function is only two methods as shown below:

javapublic static final class MyBeerFunction implements
PropertiesFunction \{ @Override public String getName() \{ return
"beer"; }  @Override public String apply(String remainder) \{ return
"mock:" + remainder.toLowerCase(); } }

The function must implement
the *`org.apache.camel.component.properties.PropertiesFunction`*
interface. The method *`getName`* is  the name of the function, e.g.,
*`beer`*. And the *`apply`* method is where we implement the custom
logic to do. As the sample code is from an unit test, it just returns a
value to refer to a mock endpoint.

To register a custom function from Java code is as shown below:

javaPropertiesComponent pc = context.getComponent("properties",
PropertiesComponent.class); pc.addFunction(new MyBeerFunction());

[[BookComponentAppendix-SeeAlso.27]]
See Also
~~~~~~~~

* link:properties.html[Properties] component

[[BookComponentAppendix-SeeAlso.28]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:jasypt.html[Jasypt] for using encrypted values e.g., passwords,
in properties.

[[BookComponentAppendix-RefComponent]]
Ref Component
~~~~~~~~~~~~~

The *ref:* component is used for lookup of existing endpoints bound in
the link:registry.html[Registry].

[[BookComponentAppendix-URIformat.51]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
ref:someName[?options]
----

Where *someName* is the name of an endpoint in the
link:registry.html[Registry] (usually, but not always, the Spring
registry). If you are using the Spring registry, `someName` would be the
bean ID of an endpoint in the Spring registry.

[[BookComponentAppendix-Runtimelookup]]
Runtime lookup
^^^^^^^^^^^^^^

This component can be used when you need dynamic discovery of endpoints
in the link:registry.html[Registry] where you can compute the URI at
runtime. Then you can look up the endpoint using the following code:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
   // lookup the endpoint
   String myEndpointRef = "bigspenderOrder";
   Endpoint endpoint = context.getEndpoint("ref:" + myEndpointRef);
   
   Producer producer = endpoint.createProducer();
   Exchange exchange = producer.createExchange();
   exchange.getIn().setBody(payloadToSend);
   // send the exchange
   producer.process(exchange);
   ...
----

And you could have a list of endpoints defined in the
link:registry.html[Registry] such as:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <camelContext id="camel" xmlns="http://activemq.apache.org/camel/schema/spring">
      <endpoint id="normalOrder" uri="activemq:order.slow"/>
      <endpoint id="bigspenderOrder" uri="activemq:order.high"/>
      ...
  </camelContext>
----

[[BookComponentAppendix-Sample.1]]
Sample
^^^^^^

In the sample below we use the `ref:` in the URI to reference the
endpoint with the spring ID, `endpoint2`:

You could, of course, have used the `ref` attribute instead:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
      <to ref="endpoint2"/>
----

Which is the more common way to write it.

[[BookComponentAppendix-SeeAlso.29]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-RestletComponent]]
Restlet Component
~~~~~~~~~~~~~~~~~

The *Restlet* component provides http://www.restlet.org[Restlet] based
link:endpoint.html[endpoints] for consuming and producing RESTful
resources.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-restlet</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.52]]
URI format
^^^^^^^^^^

javarestlet:restletUrl[?options]

Format of restletUrl:

javaprotocol://hostname[:port][/resourcePattern]

Restlet promotes decoupling of protocol and application concerns. The
reference implementation of
http://www.noelios.com/products/restlet-engine[Restlet Engine] supports
a number of protocols. However, we have tested the HTTP protocol only.
The default port is port 80. We do not automatically switch default port
based on the protocol yet.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

 

It seems Restlet is case sensitive in understanding headers. For example
to use content-type, use Content-Type, and for location use Location and
so on.

We have received a report about drop in performance in camel-restlet in
Camel 2.14.0 and 2.14.1. We have reported this to the Restlet team in
https://github.com/restlet/restlet-framework-java/issues/996[issue 996].
To remedy the issue then from Camel 2.14.2 onwards you can set
synchronous=true as option on the endpoint uris, Or set it on the
RestletComponent as a global option so all endpoints inherit this
option.

 

[[BookComponentAppendix-Options.41]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`headerFilterStrategy=#`__refName__ |An instance of
`RestletHeaderFilterStrategy` |Use the `#` notation
(`headerFilterStrategy=#`__refName__) to reference a header filter
strategy in the Camel Registry. The strategy will be plugged into the
restlet binding if it is `HeaderFilterStrategyAware`.

|`restletBinding=#`__refName__ |An instance of `DefaultRestletBinding`
|The bean ID of a `RestletBinding` object in the Camel Registry.

|`restletMethod` |`GET` |On a producer endpoint, specifies the request
method to use. On a consumer endpoint, specifies that the endpoint
consumes only `restletMethod` requests. The string value is converted to
http://www.restlet.org/documentation/1.1/api/org/restlet/data/Method.html[org.restlet.data.Method]
by the `Method.valueOf(String)` method.

|`restletMethods` |_None_ |*Consumer only* Specify one or more methods
separated by commas (e.g. `restletMethods=post,put`) to be serviced by a
restlet consumer endpoint. If both `restletMethod` and `restletMethods`
options are specified, the `restletMethod` setting is ignored.

|`restletRealm=#`__refName__ |`null` |The bean ID of the Realm Map in
the Camel Registry.

|`restletUriPatterns=#`__refName__ |_None_ |*Consumer only* Specify one
ore more URI templates to be serviced by a restlet consumer endpoint,
using the `#` notation to reference a `List<String>` in the Camel
Registry. If a URI pattern has been defined in the endpoint URI, both
the URI pattern defined in the endpoint and the `restletUriPatterns`
option will be honored.

|`throwExceptionOnFailure` (*2.6 or later*) |`true` |*Producer only *
Throws exception on a producer failure.

|`connectionTimeout` |300000 |*Since Camel 2.12.3* *Producer only* The
Client will give up connection if the connection is timeout, 0 for
unlimited wait.

|`socketTimeout` |300000 |*Since Camel 2.12.3* *Producer only* The
Client socket receive timeout, 0 for unlimited wait.

|`disableStreamCache` |`false` |**Camel 2.14:** Determines whether or
not the raw input stream from Jetty is cached or not (Camel will read
the stream into a in memory/overflow to
file, http://camel.apache.org/stream-caching.html[Stream caching])
cache. By default Camel will cache the Jetty input stream to support
reading it multiple times to ensure it Camel can retrieve all data from
the stream. However you can set this option to `true` when you for
example need to access the raw stream, such as streaming it directly to
a file or other persistent store. DefaultRestletBinding will copy the
request input stream into a stream cache and put it into message body if
this option is `false` to support reading the stream multiple times.

|`streamRepresentation` |`false` |*Camel 2.16.4/2.17.2:* *Producer only*
Whether to support stream representation as response from calling a REST
service using the restlet producer. If the response is streaming then
this option can be enabled to use an http://java.io[java.io].InputStream
as the message body on the Camel Message body. If using this option you
may want to enable the autoCloseStream option as well to ensure the
input stream is closed when the Camel Exchange is done being routed.
However if you need to read the stream outside a Camel route, you may
need to not auto close the stream.

|`autoCloseStream` |`false` |**Camel 2.16.4/2.17.2:** *Producer only*
Whether to auto close the stream representation as response from calling
a REST service using the restlet producer. If the response is streaming
and the option streamRepresentation is enabled then you may want to auto
close the InputStream from the streaming response to ensure the input
stream is closed when the Camel Exchange is done being routed. However
if you need to read the stream outside a Camel route, you may need to
not auto close the stream.

|`cookieHandler` |`null` |*Camel 2.19: Producer only:* Configure a
cookie handler to maintain a HTTP session
|=======================================================================

[[BookComponentAppendix-ComponentOptions.1]]
Component Options
^^^^^^^^^^^^^^^^^

The Restlet component can be configured with the following options.
Notice these are *component* options and cannot be configured on the
endpoint, see further below for an example.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`controllerDaemon` |`true` |*Camel 2.10:* Indicates if the controller
thread should be a daemon (not blocking JVM exit).

|`controllerSleepTimeMs` |`100` |*Camel 2.10:* Time for the controller
thread to sleep between each control.

|`inboundBufferSize` |`8192` |*Camel 2.10:* The size of the buffer when
reading messages.

|`minThreads` |`1` |*Camel 2.10:* Minimum threads waiting to service
requests.

|`maxThreads` |`10` |*Camel 2.10:* Maximum threads that will service
requests.

|`lowThreads` |8 |*Camel 2.13:* Number of worker threads determining
when the connector is considered overloaded.

|`maxQueued` |0 |*Camel 2.13:* Maximum number of calls that can be
queued if there aren't any worker thread available to service them. If
the value is '0', then no queue is used and calls are rejected if no
worker thread is immediately available. If the value is '-1', then an
unbounded queue is used and calls are never rejected.

|`maxConnectionsPerHost` |`-1` |*Camel 2.10:* Maximum number of
concurrent connections per host (IP address).

|`maxTotalConnections` |`-1` |*Camel 2.10:* Maximum number of concurrent
connections in total.

|`outboundBufferSize` |`8192` |*Camel 2.10:* The size of the buffer when
writing messages.

|`persistingConnections` |`true` |*Camel 2.10:* Indicates if connections
should be kept alive after a call.

|`pipeliningConnections` |`false` |*Camel 2.10:* Indicates if pipelining
connections are supported.

|`threadMaxIdleTimeMs` |`60000` |*Camel 2.10:* Time for an idle thread
to wait for an operation before being collected.

|`useForwardedForHeader` |`false` |*Camel 2.10:* Lookup the
"X-Forwarded-For" header supported by popular proxies and caches and
uses it to populate the Request.getClientAddresses() method result. This
information is only safe for intermediary components within your local
network. Other addresses could easily be changed by setting a fake
header and should not be trusted for serious security checks.

|`reuseAddress` |`true` |*Camel 2.10.5/2.11.1:* Enable/disable the
SO_REUSEADDR socket option. See java.io.ServerSocket#reuseAddress
property for additional details.

|`disableStreamCache` |`false` |**Camel 2.14:** Determines whether or
not the raw input stream from Jetty is cached or not (Camel will read
the stream into a in memory/overflow to
file, http://camel.apache.org/stream-caching.html[Stream caching])
cache. By default Camel will cache the Jetty input stream to support
reading it multiple times to ensure it Camel can retrieve all data from
the stream. However you can set this option to `true` when you for
example need to access the raw stream, such as streaming it directly to
a file or other persistent store. DefaultRestletBinding will copy the
request input stream into a stream cache and put it into message body if
this option is `false` to support reading the stream multiple times.

|enabledConverters |null |**Camel 2.18:** By default, Restlet engine
loads all the extension it finds at run-time and this option filter out
all the converters except those explicit listed using full qualified
class name or simple class name. i.e. by setting
enabledConverters=JacksonConverter, GsonConverter the RestletComponent
will remove all the converters loaded by the Restlet engine except
Jackson and Gson. Note that you still need to add the extensions as
dependency.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.15]]
Message Headers
^^^^^^^^^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`Content-Type` |`String` |Specifies the content type, which can be set
on the OUT message by the application/processor. The value is the
`content-type` of the response message. If this header is not set, the
content type is based on the object type of the OUT message body. In
Camel 2.3 onward, if the Content-Type header is specified in the Camel
IN message, the value of the header determine the content type for the
Restlet request message.   Otherwise, it is defaulted to
"application/x-www-form-urlencoded'. Prior to release 2.3, it is not
possible to change the request content type default.

|`CamelAcceptContentType` |`String` |*Since Camel 2.9.3, 2.10.0:* The
HTTP Accept request header.

|`CamelHttpMethod` |`String` |The HTTP request method. This is set in
the IN message header.

|`CamelHttpQuery` |`String` |The query string of the request URI. It is
set on the IN message by `DefaultRestletBinding` when the restlet
component receives a request.

|`CamelHttpResponseCode` |`String` or `Integer` |The response code can
be set on the OUT message by the application/processor. The value is the
response code of the response message. If this header is not set, the
response code is set by the restlet runtime engine.

|`CamelHttpUri` |`String` |The HTTP request URI. This is set in the IN
message header.

|`CamelRestletLogin` |`String` |Login name for basic authentication. It
is set on the IN message by the application and gets filtered before the
restlet request header by Camel.

|`CamelRestletPassword` |`String` |Password name for basic
authentication. It is set on the IN message by the application and gets
filtered before the restlet request header by Camel.

|`CamelRestletRequest` |`Request` |*Camel 2.8:* The
`org.restlet.Request` object which holds all request details.

|`CamelRestletResponse` |`Response` |*Camel 2.8:* The
`org.restlet.Response` object. You can use this to create responses
using the API from Restlet. See examples below.

|`org.restlet.*` |  |Attributes of a Restlet message that get propagated
to Camel IN headers.

|`cache-control` |`String` or `List<CacheDirective>` |*Camel 2.11:* User
can set the cache-control with the String value or the List of
CacheDirective of Restlet from the camel message header.
|=======================================================================

[[BookComponentAppendix-MessageBody.4]]
Message Body
^^^^^^^^^^^^

Camel will store the restlet response from the external server on the
OUT body. All headers from the IN message will be copied to the OUT
message, so that headers are preserved during routing.

[[BookComponentAppendix-Samples.10]]
Samples
^^^^^^^

[[BookComponentAppendix-RestletEndpointwithAuthentication]]
Restlet Endpoint with Authentication
++++++++++++++++++++++++++++++++++++

The following route starts a `restlet` consumer endpoint that listens
for `POST` requests on http://localhost:8080. The processor creates a
response that echoes the request body and the value of the `id`
header.\{snippet:id=consumer_route|lang=java|url=camel/trunk/components/camel-restlet/src/test/java/org/apache/camel/component/restlet/route/TestRouteBuilder.java}The
`restletRealm` setting in the URI query is used to look up a Realm Map
in the registry. If this option is specified, the restlet consumer uses
the information to authenticate user logins. Only _authenticated_
requests can access the resources. In this sample, we create a Spring
application context that serves as a registry. The bean ID of the Realm
Map should match the
_restletRealmRef_.\{snippet:id=realm|lang=xml|url=camel/trunk/components/camel-restlet/src/test/resources/org/apache/camel/component/restlet/camel-context.xml}The
following sample starts a `direct` endpoint that sends requests to the
server on http://localhost:8080 (that is, our restlet consumer
endpoint).\{snippet:id=producer_route|lang=java|url=camel/trunk/components/camel-restlet/src/test/java/org/apache/camel/component/restlet/route/TestRouteBuilder.java}That
is all we need. We are ready to send a request and try out the restlet
component:\{snippet:id=auth_request|lang=java|url=camel/trunk/components/camel-restlet/src/test/java/org/apache/camel/component/restlet/RestletRouteBuilderAuthTest.java}The
sample client sends a request to the `direct:start-auth` endpoint with
the following headers:

* `CamelRestletLogin` (used internally by Camel)
* `CamelRestletPassword` (used internally by Camel)
* `id` (application header)

Note

`org.apache.camel.restlet.auth.login` and
`org.apache.camel.restlet.auth.password` will not be propagated as
Restlet header.

The sample client gets a response like the following:

textreceived [<order foo='1'/>] as an order id = 89531

[[BookComponentAppendix-SinglerestletendpointtoservicemultiplemethodsandURItemplates]]
Single restlet endpoint to service multiple methods and URI templates
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

It is possible to create a single route to service multiple HTTP methods
using the `restletMethods` option. This snippet also shows how to
retrieve the request method from the
header:\{snippet:id=routeDefinition|lang=java|url=camel/trunk/components/camel-restlet/src/test/java/org/apache/camel/component/restlet/RestletMultiMethodsEndpointTest.java}In
addition to servicing multiple methods, the next snippet shows how to
create an endpoint that supports multiple URI templates using the
`restletUriPatterns` option. The request URI is available in the header
of the IN message as well. If a URI pattern has been defined in the
endpoint URI (which is not the case in this sample), both the URI
pattern defined in the endpoint and the `restletUriPatterns` option will
be
honored.\{snippet:id=routeDefinition|lang=java|url=camel/trunk/components/camel-restlet/src/test/java/org/apache/camel/component/restlet/RestletMultiUriTemplatesEndpointTest.java}The
`restletUriPatterns=#uriTemplates` option references the `List<String>`
bean defined in the Spring XML configuration.

xml<util:list id="uriTemplates"> <value>/users/\{username}</value>
<value>/atom/collection/\{id}/component/\{cid}</value> </util:list>

[[BookComponentAppendix-UsingRestletAPItopopulateresponse]]
Using Restlet API to populate response
++++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.8*

You may want to use the `org.restlet.Response` API to populate the
response. This gives you full access to the Restlet API and fine grained
control of the response. See the route snippet below where we generate
the response from an inlined Camel
link:processor.html[Processor]:\{snippet:id=e1|title=Generating response
using Restlet Response
API|lang=java|url=camel/trunk/components/camel-restlet/src/test/java/org/apache/camel/component/restlet/RestletRequestAndResponseAPITest.java}

[[BookComponentAppendix-Configuringmaxthreadsoncomponent]]
Configuring max threads on component
++++++++++++++++++++++++++++++++++++

To configure the max threads options you must do this on the component,
such as:

xml<bean id="restlet"
class="org.apache.camel.component.restlet.RestletComponent"> <property
name="maxThreads" value="100"/> </bean>

[[BookComponentAppendix-UsingtheRestletservletwithinawebapp]]
Using the Restlet servlet within a webapp
+++++++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.8* +
There are
http://www.restlet.org/documentation/2.0/jee/ext/org/restlet/ext/servlet/ServerServlet.html[three
possible ways] to configure a Restlet application within a servlet
container and using the subclassed SpringServerServlet enables
configuration within Camel by injecting the Restlet Component.

Use of the Restlet servlet within a servlet container enables routes to
be configured with relative paths in URIs (removing the restrictions of
hard-coded absolute URIs) and for the hosting servlet container to
handle incoming requests (rather than have to spawn a separate server
process on a new port).

To configure, add the following to your camel-context.xml;

xml<camelContext> <route id="RS_RestletDemo"> <from
uri="restlet:/demo/\{id}" /> <transform> <simple>Request type :
$\{header.CamelHttpMethod} and ID : $\{header.id}</simple> </transform>
</route> </camelContext> <bean id="RestletComponent"
class="org.restlet.Component" /> <bean id="RestletComponentService"
class="org.apache.camel.component.restlet.RestletComponent">
<constructor-arg index="0"> <ref bean="RestletComponent" />
</constructor-arg> </bean>

And add this to your web.xml;

xml<!-- Restlet Servlet --> <servlet>
<servlet-name>RestletServlet</servlet-name>
<servlet-class>org.restlet.ext.spring.SpringServerServlet</servlet-class>
<init-param> <param-name>org.restlet.component</param-name>
<param-value>RestletComponent</param-value> </init-param> </servlet>
<servlet-mapping> <servlet-name>RestletServlet</servlet-name>
<url-pattern>/rs/*</url-pattern> </servlet-mapping>

You will then be able to access the deployed route at
http://localhost:8080/mywebapp/rs/demo/1234 where;

localhost:8080 is the server and port of your servlet container +
mywebapp is the name of your deployed webapp +
Your browser will then show the following content;

"Request type : GET and ID : 1234"

You will need to add dependency on the Spring extension to restlet which
you can do in your Maven pom.xml file:

xml<dependency> <groupId>org.restlet.jee</groupId>
<artifactId>org.restlet.ext.spring</artifactId>
<version>$\{restlet-version}</version> </dependency>

And you would need to add dependency on the restlet maven repository as
well:

xml<repository> <id>maven-restlet</id> <name>Public online Restlet
repository</name> <url>http://maven.restlet.org</url> </repository>

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-RMIComponent]]
RMI Component
~~~~~~~~~~~~~

The *rmi:* component binds link:exchange.html[Exchange]s to the RMI
protocol (JRMP).

Since this binding is just using RMI, normal RMI rules still apply
regarding what methods can be invoked. This component supports only
Exchanges that carry a method invocation from an interface that extends
the http://java.sun.com/j2se/1.3/docs/api/java/rmi/Remote.html[Remote]
interface. All parameters in the method should be either
http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html[Serializable]
or `Remote` objects.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-rmi</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.53]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
rmi://rmi-regisitry-host:rmi-registry-port/registry-path[?options]
----

For example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
rmi://localhost:1099/path/to/service
----

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.42]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`method` |`null` |You can set the name of the method to invoke.

|`remoteInterfaces` |`null` |Its now possible to use this option from
*Camel 2.7:* in the XML DSL. It can be a list of interface names
separated by comma.
|=======================================================================

[[BookComponentAppendix-Using.3]]
Using
^^^^^

To call out to an existing RMI service registered in an RMI registry,
create a route similar to the following:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("pojo:foo").to("rmi://localhost:1099/foo");
----

To bind an existing camel processor or service in an RMI registry,
define an RMI endpoint as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
RmiEndpoint endpoint= (RmiEndpoint) endpoint("rmi://localhost:1099/bar");
endpoint.setRemoteInterfaces(ISay.class);
from(endpoint).to("pojo:bar");
----

Note that when binding an RMI consumer endpoint, you must specify the
`Remote` interfaces exposed.

In XML DSL you can do as follows from *Camel 2.7* onwards:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    <camel:route>
        <from uri="rmi://localhost:37541/helloServiceBean?remoteInterfaces=org.apache.camel.example.osgi.HelloService"/>
        <to uri="bean:helloServiceBean"/>
    </camel:route>
----

[[BookComponentAppendix-SeeAlso.30]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-Thispageisoutdated,forthecurrentversionsee:https://github.com/apache/camel/blob/master/components/camel-rss/src/main/docs/rss-component.adoc]]
*This page is outdated, for the current version see:
https://github.com/apache/camel/blob/master/components/camel-rss/src/main/docs/rss-component.adoc*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* +
*

[[BookComponentAppendix-RSSComponent]]
RSS Component
~~~~~~~~~~~~~

The *rss:* component is used for polling RSS feeds. Camel will default
poll the feed every 60th seconds.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-rss</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency>

*Note:* The component currently only supports polling (consuming) feeds.

Camel-rss internally uses a
http://svn.apache.org/repos/asf/servicemix/smx4/bundles/trunk/rome-1.0/[patched
version] of http://rometools.github.io/rome/[ROME] hosted on ServiceMix
to solve some OSGi https://issues.apache.org/jira/browse/SMX4-510[class
loading issues].

[[BookComponentAppendix-URIformat.54]]
URI format
^^^^^^^^^^

rss:rssUri

Where `rssUri` is the URI to the RSS feed to poll.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.43]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Property |Default |Description
|`splitEntries` |`true` |If `true`, Camel splits a feed into its
individual entries and returns each entry, poll by poll. For example, if
a feed contains seven entries, Camel returns the first entry on the
first poll, the second entry on the second poll, and so on. When no more
entries are left in the feed, Camel contacts the remote RSS URI to
obtain a new feed. If `false`, Camel obtains a fresh feed on every poll
and returns all of the feed's entries.

|`filter` |`true` |Use in combination with the `splitEntries` option in
order to filter returned entries. By default, Camel applies the
`UpdateDateFilter` filter, which returns only new entries from the feed,
ensuring that the consumer endpoint never receives an entry more than
once. The filter orders the entries chronologically, with the newest
returned last.

|`throttleEntries` |`true` |*Camel 2.5:* Sets whether all entries
identified in a single feed poll should be delivered immediately. If
true, only one entry is processed per consumer.delay. Only applicable
when splitEntries is set to true.

|`lastUpdate` |`null` |Use in combination with the `filter` option to
block entries earlier than a specific date/time (uses the
`entry.updated` timestamp). The format is: `yyyy-MM-ddTHH:MM:ss`.
Example: `2007-12-24T17:45:59`.

|`feedHeader` |`true` |Specifies whether to add the ROME `SyndFeed`
object as a header.

|`sortEntries` |`false` |If `splitEntries` is `true`, this specifies
whether to sort the entries by updated date.

|`consumer.delay` |`60000` |Delay in milliseconds between each poll.

|`consumer.initialDelay` |`1000` |Milliseconds before polling starts.

|`consumer.userFixedDelay` |`false` |Set to `true` to use fixed delay
between pools, otherwise fixed rate is used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.

|`username` |  |**Camel 2.16:** For basic authentication when polling
from a HTTP feed

|`password` |  |**Camel 2.16:** For basic authentication when polling
from a HTTP feed
|=======================================================================

[[BookComponentAppendix-Exchangedatatypes]]
Exchange data types
^^^^^^^^^^^^^^^^^^^

Camel initializes the In body on the Exchange with a ROME `SyndFeed`.
Depending on the value of the `splitEntries` flag, Camel returns either
a `SyndFeed` with one `SyndEntry` or a `java.util.List` of `SyndEntrys`.

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Value |Behavior
|`splitEntries` |`true` |A single entry from the current feed is set in
the exchange.

|`splitEntries` |`false` |The entire list of entries from the current
feed is set in the exchange.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.16]]
Message Headers
^^^^^^^^^^^^^^^

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=============================================
|Header |Description
|`CamelRssFeed` |The entire `SyncFeed` object.
|=============================================

[[BookComponentAppendix-RSSDataformat]]
RSS Dataformat
^^^^^^^^^^^^^^

The RSS component ships with an RSS dataformat that can be used to
convert between String (as XML) and ROME RSS model objects.

* marshal = from ROME `SyndFeed` to XML `String`
* unmarshal = from XML `String` to ROME `SyndFeed`

A route using this would look something like
this:\{snippet:id=ex|lang=java|url=camel/trunk/components/camel-rss/src/test/java/org/apache/camel/dataformat/rss/RssDataFormatTest.java}The
purpose of this feature is to make it possible to use Camel's lovely
built-in expressions for manipulating RSS messages. As shown below, an
XPath expression can be used to filter the RSS
message:\{snippet:id=ex|lang=java|url=camel/trunk/components/camel-rss/src/test/java/org/apache/camel/dataformat/rss/RssFilterWithXPathTest.java}

Query parameters

If the URL for the RSS feed uses query parameters, this component will
understand them as well, for example if the feed uses `alt=rss`, then
you can for example do +
`from("rss:http://someserver.com/feeds/posts/default?alt=rss&splitEntries=false&consumer.delay=1000").to("bean:rss");`

[[BookComponentAppendix-Filteringentries]]
Filtering entries
^^^^^^^^^^^^^^^^^

You can filter out entries quite easily using XPath, as shown in the
data format section above. You can also exploit Camel's
link:bean-integration.html[Bean Integration] to implement your own
conditions. For instance, a filter equivalent to the XPath example above
would
be:\{snippet:id=ex1|lang=java|url=camel/trunk/components/camel-rss/src/test/java/org/apache/camel/component/rss/RssFilterTest.java}The
custom bean for this would
be:\{snippet:id=ex2|lang=java|url=camel/trunk/components/camel-rss/src/test/java/org/apache/camel/component/rss/RssFilterTest.java}link:endpoint-see-also.html[Endpoint
See Also]

* link:atom.html[Atom]

Unable to render \{include} The included page could not be found.

[[BookComponentAppendix-SEDAComponent]]
SEDA Component
~~~~~~~~~~~~~~

The *`seda:`* component provides
asynchronous https://en.wikipedia.org/wiki/Staged_event-driven_architecture[SEDA]
behavior, so that messages are exchanged on a BlockingQueue and
consumers are invoked in a separate thread from the
producer.http://www.eecs.harvard.edu/~mdw/proj/seda/[]

Note that queues are only visible within a _single_
link:camelcontext.html[CamelContext]. If you want to communicate across
*`CamelContext`* instances (for example, communicating between Web
applications), see the link:vm.html[VM] component.

This component does not implement any kind of persistence or recovery,
if the VM terminates while messages are yet to be processed. If you need
persistence, reliability or distributed SEDA, try using either
link:jms.html[JMS] or link:activemq.html[ActiveMQ].

Synchronous

The link:direct.html[Direct] component provides synchronous invocation
of any consumers when a producer sends a message exchange.

[[BookComponentAppendix-URIformat.55]]
URI format
^^^^^^^^^^

seda:someName[?options]

Where *`someName`* can be any string that uniquely identifies the
endpoint within the current link:camelcontext.html[CamelContext].

You can append query options to the URI in the following format:
*`?option=value&option=value&...`*

[[BookComponentAppendix-Options.44]]
Options
^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Since |Default |Description
|`size` |  |  a|
The maximum capacity of the *seda* queue, i.e., the number of messages
it can hold.

The default value in *Camel 2.2* or older is *`1000`*.

From *Camel 2.3*: the size is unbounded by default.

 

*Note:* Care should be taken when using this option. The size is
determined by the value specified _when the first endpoint is created_.
Each endpoint must therefore specify the same size.

*From* *Camel 2.11*: a validation is taken place to ensure if using
mixed queue sizes for the same queue name, Camel would detect this and
fail creating the endpoint.

|`concurrentConsumers` |  |`1` |Number of concurrent threads processing
exchanges.

|`waitForTaskToComplete` |  |`IfReplyExpected` a|
Option to specify whether the caller should wait for the asynchronous
task to complete before continuing.

The following options are supported:

* *`Always`*
* *`Never`*
* *`IfReplyExpected`*

The first two values are self-explanatory.

The last value, *`IfReplyExpected`*, will only wait if the message is
link:request-reply.html[Request Reply] based.

See link:async.html[Async] messaging for more details.

|`timeout` |  |`30000` a|
Timeout (in milliseconds) before a *seda* producer will stop waiting for
an asynchronous task to complete.

See *`waitForTaskToComplete`* and link:async.html[Async] for more
details.

From *Camel 2.2:* you can now disable timeout by using *`0`* or a
negative value.

|`multipleConsumers` |*2.2* |`false` |Specifies whether multiple
consumers are allowed. If enabled, you can use link:seda.html[SEDA] for
http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern[Publish-Subscribe]
messaging. That is, you can send a message to the *seda* queue and have
each consumer receive a copy of the message. When enabled, this option
should be specified on every consumer endpoint.

|`limitConcurrentConsumers` |*2.3* |`true` a|
Whether to limit the number of *`concurrentConsumers`* to the maximum of
*`500`*.

By default, an exception will be thrown if a *seda* endpoint is
configured with a greater number. You can disable that check by turning
this option off.

|`blockWhenFull` |*2.9* |`false` |Whether a thread that sends messages
to a full *seda* queue will block until the queue's capacity is no
longer exhausted. By default, an exception will be thrown stating that
the queue is full. By enabling this option, the calling thread will
instead block and wait until the message can be accepted.

|`queueSize` |*2.9* |  a|
*Component only:* the maximum size (capacity of the number of messages
it can hold) of the *seda* queue.

This option is used when *`size`* is not specified.

|`pollTimeout` |*2.9.3* |`1000` |*Consumer only*: the timeout used when
polling. When a timeout occurs, the consumer can check whether it is
allowed to continue running. Setting a lower value allows the consumer
to react more quickly upon shutdown.

|`purgeWhenStopping` |*2.11.1* |`false` |Whether to purge the task queue
when stopping the consumer/route. This allows to stop faster, as any
pending messages on the queue is discarded.

|`queue` |*2.12.0* |`null` |Define the queue instance which will be used
by *seda* endpoint

|`queueFactory` |*2.12.0* |`null` |Define the *`QueueFactory`* which
could create the queue for the *seda* endpoint

|`failIfNoConsumers` |*2.12.0* |`false` a|
Whether the producer should fail by throwing an exception when sending
to a *seda* queue with no active consumers.

Only one of the options *`discardIfNoConsumers`* and
*`failIfNoConsumers`* can be enabled at the same time.

|`discardIfNoConsumers` |*2.16* |`false` a|
Whether the producer should discard the message (do not add the message
to the queue) when sending to a *seda* queue with no active consumers. 

Only one of the options *`discardIfNoConsumers`*
and *`failIfNoConsumers`* can be enabled at the same time.

|=======================================================================

[[BookComponentAppendix-ChoosingBlockingQueueimplementation]]
Choosing BlockingQueue implementation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.12*

xml<bean id="arrayQueue" class="java.util.ArrayBlockingQueue">
<constructor-arg index="0" value="10"> <!-- size --> <constructor-arg
index="1" value="true"> <!-- fairness --> </bean> <!-- ... --> <from
uri="seda:array?queue=#arrayQueue"/>

By default, the *seda* component instantiates a *`LinkedBlockingQueue`*.
However, a different implementation can be chosen by specifying a
custom  *`BlockingQueue`* implementation. When a custom implementation
is configured the *`size`* option is ignored.

The list of available *`BlockingQueueFactory`* implementations includes:

* *`LinkedBlockingQueueFactory`*
* *`ArrayBlockingQueueFactory`*
* *`PriorityBlockingQueueFactory`* +
 +

xml<bean id="priorityQueueFactory"
class="org.apache.camel.component.seda.PriorityBlockingQueueFactory">
<property name="comparator"> <bean
class="org.apache.camel.demo.MyExchangeComparator"/> </property> </bean>
<!-- ...and later --> <from
uri="seda:priority?queueFactory=#priorityQueueFactory&size=100"/> <!--
... --> 

[[BookComponentAppendix-UseofRequestReply]]
Use of Request Reply
^^^^^^^^^^^^^^^^^^^^

The link:seda.html[SEDA] component supports using
link:request-reply.html[Request Reply], where the caller will wait for
the link:async.html[Async] route to complete. For instance:

javafrom("mina:tcp://0.0.0.0:9876?textline=true&sync=true")
.to("seda:input"); from("seda:input") .to("bean:processInput")
.to("bean:createResponse");

In the route above, we have a TCP listener on port *`9876`* that accepts
incoming requests. The request is routed to the *`seda:input`* queue. As
it is a link:request-reply.html[Request Reply] message, we wait for the
response. When the consumer on the *`seda:input`* queue is complete, it
copies the response to the original message response.

until 2.2: Works only with 2 endpoints

Using link:request-reply.html[Request Reply] over link:seda.html[SEDA]
or link:vm.html[VM] only works with 2 endpoints. You *cannot* chain
endpoints by sending to *`A -> B -> C`* etc. Only between *`A -> B`*.
The reason is the implementation logic is fairly simple. To support 3+
endpoints makes the logic much more complex to handle ordering and
notification between the waiting threads properly.

This has been improved in *Camel 2.3*, which allows you to chain as many
endpoints as you like.

[[BookComponentAppendix-Concurrentconsumers]]
Concurrent consumers
^^^^^^^^^^^^^^^^^^^^

By default, the SEDA endpoint uses a single consumer thread, but you can
configure it to use concurrent consumer threads. So, instead of thread
pools you can use:

javafrom("seda:stageName?concurrentConsumers=5") .process(...)

As for the difference between the two, note a _thread pool_ can
increase/shrink dynamically at runtime depending on load, whereas the
number of concurrent consumers is always fixed.

[[BookComponentAppendix-Threadpools]]
Thread pools
^^^^^^^^^^^^

Be aware that adding a thread pool to a *seda* endpoint by doing
something like:

javafrom("seda:stageName") .thread(5) .process(...)

Can wind up with two *`BlockQueues`:* one from the *seda* endpoint, and
one from the workqueue of the thread pool, which may not be what you
want. Instead, you might wish to configure a link:direct.html[Direct]
endpoint with a thread pool, which can process messages both
synchronously and asynchronously. For example:

javafrom("direct:stageName") .thread(5) .process(...)

You can also directly configure number of threads that process messages
on a *seda* endpoint using the *`concurrentConsumers`* option.

[[BookComponentAppendix-Sample.2]]
Sample
^^^^^^

In the route below we use the SEDA queue to send the request to this
asynchronous queue to be able to send a fire-and-forget message for
further processing in another thread, and return a constant reply in
this thread to the original
caller.INLINE\{snippet:id=e1|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/seda/SedaAsyncRouteTest.java}Here
we send a Hello World message and expects the reply to be
OK.INLINE\{snippet:id=e2|lang=java|url=camel/trunk/camel-core/src/test/java/org/apache/camel/component/seda/SedaAsyncRouteTest.java}The *`Hello World`*
message will be consumed from the *seda* queue from another thread for
further processing. Since this is from a unit test, it will be sent to a
*`mock`* endpoint where we can do assertions in the unit test.

[[BookComponentAppendix-UsingmultipleConsumers]]
Using `multipleConsumers`
^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.2*

In this example we have defined two consumers and registered them as
spring
beans.INLINE\{snippet:id=e1|lang=xml|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/spring/example/fooEventRoute.xml}Since
we have specified *`multipleConsumers=true`* on the *seda* *`foo`*
endpoint we can have those two consumers receive their own copy of the
message as a kind of pub-sub style messaging.

As the beans are part of an unit test they simply send the message to
a *`mock`* endpoint. Note the use of *`@Consume`* to consume from the
*seda*
queue.INLINE\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-spring/src/test/java/org/apache/camel/spring/example/FooEventConsumer.java}

[[BookComponentAppendix-ExtractingQueueInformation.]]
Extracting Queue Information.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If needed, information such as queue size, etc. can be obtained without
using JMX in this fashion:

javaSedaEndpoint seda = context.getEndpoint("seda:xxxx"); int size =
seda.getExchanges().size();

link:endpoint-see-also.html[Endpoint See Also]

* link:vm.html[VM]
* link:disruptor.html[Disruptor]
* link:direct.html[Direct]
* link:async.html[Async]

[[BookComponentAppendix-ServletComponent]]
Servlet Component
~~~~~~~~~~~~~~~~~

The *servlet:* component provides HTTP based
link:endpoint.html[endpoints] for consuming HTTP requests that arrive at
a HTTP endpoint that is bound to a published Servlet.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-servlet</artifactId> <version>x.x.x</version> <\!-\-
use the same version as your Camel core version \--> </dependency>
Stream

Servlet is stream based, which means the input it receives is submitted
to Camel as a stream. That means you will only be able to read the
content of the stream *once*. If you find a situation where the message
body appears to be empty or you need to access the data multiple times
(eg: doing multicasting, or redelivery error handling) you should use
link:stream-caching.html[Stream caching] or convert the message body to
a `String` which is safe to be read multiple times.

[[BookComponentAppendix-URIformat.56]]
URI format
^^^^^^^^^^

servlet://relative_path[?options]

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.45]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`httpBindingRef` |`null` |Reference to an
`org.apache.camel.component.http.HttpBinding` in the
link:registry.html[Registry]. A `HttpBinding` implementation can be used
to customize how to write a response.

|`httpBinding` |`null` |*Camel 2.16:* Reference to an
`org.apache.camel.component.http.HttpBinding` in the
link:registry.html[Registry]. A `HttpBinding` implementation can be used
to customize how to write a response.

|`matchOnUriPrefix` |`false` |Whether or not the `CamelServlet` should
try to find a target consumer by matching the URI prefix, if no exact
match is found.

|`servletName` |`CamelServlet` |Specifies the servlet name that the
servlet endpoint will bind to. This name should match the name you
define in `web.xml` file.

|`httpMethodRestrict` |`null` |**Camel 2.11:** **Consumer only**: Used
to only allow consuming if the HttpMethod matches, such as GET/POST/PUT
etc. From **Camel 2.15** onwards multiple methods can be specified
separated by comma.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.17]]
Message Headers
^^^^^^^^^^^^^^^

Camel will apply the same Message Headers as the link:http.html[HTTP]
component.

Camel will also populate *all* `request.parameter` and
`request.headers`. For example, if a client request has the URL,
`http://myserver/myserver?orderid=123`, the exchange will contain a
header named `orderid` with the value 123.

[[BookComponentAppendix-Usage.6]]
Usage
^^^^^

You can consume only from endpoints generated by the Servlet component.
Therefore, it should be used only as input into your Camel routes. To
issue HTTP requests against other HTTP endpoints, use the
link:http.html[HTTP Component]

[[BookComponentAppendix-UsingServlet3.0AsyncMode]]
Using Servlet 3.0 Async Mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.18*

You can configure the servlet with an init-param to turn on async mode
when using a Servlet 3.x container. There is a sample XML configuration
below:

xml <servlet> <servlet-name>CamelServlet</servlet-name>
<display-name>Camel Http Transport Servlet</display-name>
<servlet-class>org.apache.camel.component.servlet.CamelHttpTransportServlet</servlet-class>
<init-param> <param-name>async</param-name>
<param-value>true</param-value> </init-param>
<load-on-startup>1</load-on-startup>
<async-supported>true</async-supported> </servlet>

 

[[BookComponentAppendix-PuttingCamelJARsintheappserverbootclasspath]]
Putting Camel JARs in the app server boot classpath
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you put the Camel JARs such as `camel-core`, `camel-servlet`, etc. in
the boot classpath of your application server (eg usually in its lib
directory), then mind that the servlet mapping list is now shared
between multiple deployed Camel application in the app server.

Mind that putting Camel JARs in the boot classpath of the application
server is generally not best practice!

So in those situations you *must* define a custom and unique servlet
name in each of your Camel application, eg in the `web.xml` define:

xml<servlet> <servlet-name>MyServlet</servlet-name>
<servlet-class>org.apache.camel.component.servlet.CamelHttpTransportServlet</servlet-class>
<load-on-startup>1</load-on-startup> </servlet> <servlet-mapping>
<servlet-name>MyServlet</servlet-name> <url-pattern>/*</url-pattern>
</servlet-mapping>

And in your Camel endpoints then include the servlet name as well

xml<route> <from uri="servlet://foo?servletName=MyServlet"/> ...
</route>

From *Camel 2.11* onwards Camel will detect this duplicate and fail to
start the application. You can control to ignore this duplicate by
setting the servlet init-parameter ignoreDuplicateServletName to true as
follows:

xml <servlet> <servlet-name>CamelServlet</servlet-name>
<display-name>Camel Http Transport Servlet</display-name>
<servlet-class>org.apache.camel.component.servlet.CamelHttpTransportServlet</servlet-class>
<init-param> <param-name>ignoreDuplicateServletName</param-name>
<param-value>true</param-value> </init-param> </servlet>

But its *strongly advised* to use unique servlet-name for each Camel
application to avoid this duplication clash, as well any unforeseen
side-effects.

[[BookComponentAppendix-Sample.3]]
Sample
^^^^^^

From Camel 2.7 onwards it's easier to use link:servlet.html[Servlet] in
Spring web applications. See link:servlet-tomcat-example.html[Servlet
Tomcat Example] for details.

In this sample, we define a route that exposes a HTTP service at
`http://localhost:8080/camel/services/hello`. +
First, you need to publish the
http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java[CamelHttpTransportServlet]
through the normal Web Container, or OSGi Service. +
Use the `Web.xml` file to publish the
http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java[CamelHttpTransportServlet]
as
follows:\{snippet:id=web|lang=xml|url=camel/trunk/components/camel-servlet/src/test/resources/org/apache/camel/component/servlet/web.xml}Then
you can define your route as
follows:\{snippet:id=route|lang=java|url=camel/trunk/components/camel-servlet/src/test/java/org/apache/camel/component/servlet/HttpClientRouteTest.java}

Specify the relative path for camel-servlet endpoint

Since we are binding the Http transport with a published servlet, and we
don't know the servlet's application context path, the `camel-servlet`
endpoint uses the relative path to specify the endpoint's URL. A client
can access the `camel-servlet` endpoint through the servlet publish
address:
`("http://localhost:8080/camel/services") + RELATIVE_PATH("/hello")`.

[[BookComponentAppendix-SamplewhenusingSpring3.x]]
Sample when using Spring 3.x
++++++++++++++++++++++++++++

See link:servlet-tomcat-example.html[Servlet Tomcat Example]

[[BookComponentAppendix-SamplewhenusingSpring2.x]]
Sample when using Spring 2.x
++++++++++++++++++++++++++++

When using the Servlet component in a Camel/Spring application it's
often required to load the Spring ApplicationContext _after_ the Servlet
component has started. This can be accomplished by using Spring's
`ContextLoaderServlet` instead of `ContextLoaderListener`. In that case
you'll need to start `ContextLoaderServlet` after
http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java[CamelHttpTransportServlet]
like this:

xml <web-app> <servlet> <servlet-name>CamelServlet</servlet-name>
<servlet-class>
org.apache.camel.component.servlet.CamelHttpTransportServlet
</servlet-class> <load-on-startup>1</load-on-startup> </servlet>
<servlet> <servlet-name>SpringApplicationContext</servlet-name>
<servlet-class> org.springframework.web.context.ContextLoaderServlet
</servlet-class> <load-on-startup>2</load-on-startup> </servlet>
<web-app>

[[BookComponentAppendix-SamplewhenusingOSGi]]
Sample when using OSGi
++++++++++++++++++++++

From *Camel 2.6.0*, you can publish the
http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java[CamelHttpTransportServlet]
as an OSGi service with help of SpringDM like
this.\{snippet:id=service|lang=xml|url=camel/trunk/tests/camel-itest-osgi/src/test/resources/org/apache/camel/itest/osgi/servlet/ServletServiceContext.xml}Then
use this service in your camel route like
this:\{snippet:id=camelContext|lang=xml|url=camel/trunk/tests/camel-itest-osgi/src/test/resources/org/apache/camel/itest/osgi/servlet/CamelServletWithServletServiceContext.xml}For
versions prior to Camel 2.6 you can use an `Activator` to publish the
http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java[CamelHttpTransportServlet]
on the OSGi
platform\{snippet:id=activator|lang=java|url=camel/trunk/tests/camel-itest-osgi/src/test/java/org/apache/camel/itest/osgi/servlet/support/ServletActivator.java}link:endpoint-see-also.html[Endpoint
See Also]

* link:servlet-tomcat-example.html[Servlet Tomcat Example]
* link:servlet-tomcat-no-spring-example.html[Servlet Tomcat No Spring
Example]
* link:http.html[HTTP]
* link:jetty.html[Jetty]

[[BookComponentAppendix-ShiroSecurityComponent]]
Shiro Security Component
~~~~~~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.5*

The *shiro-security* component in Camel is a security focused component,
based on the Apache Shiro security project.

Apache Shiro is a powerful and flexible open-source security framework
that cleanly handles authentication, authorization, enterprise session
management and cryptography. The objective of the Apache Shiro project
is to provide the most robust and comprehensive application security
framework available while also being very easy to understand and
extremely simple to use.

This camel shiro-security component allows authentication and
authorization support to be applied to different segments of a camel
route.

Shiro security is applied on a route using a Camel Policy. A Policy in
Camel utilizes a strategy pattern for applying interceptors on Camel
Processors. It offering the ability to apply cross-cutting concerns (for
example. security, transactions etc) on sections/segments of a camel
route.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-shiro</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-ShiroSecurityBasics]]
Shiro Security Basics
^^^^^^^^^^^^^^^^^^^^^

To employ Shiro security on a camel route, a ShiroSecurityPolicy object
must be instantiated with security configuration details (including
users, passwords, roles etc). This object must then be applied to a
camel route. This ShiroSecurityPolicy Object may also be registered in
the Camel registry (JNDI or ApplicationContextRegistry) and then
utilized on other routes in the Camel Context.

Configuration details are provided to the ShiroSecurityPolicy using an
Ini file (properties file) or an Ini object. The Ini file is a standard
Shiro configuration file containing user/role details as shown below

[source,brush:,java;,gutter:,false;,theme:,Default]
----
[users]
# user 'ringo' with password 'starr' and the 'sec-level1' role
ringo = starr, sec-level1
george = harrison, sec-level2
john = lennon, sec-level3
paul = mccartney, sec-level3

[roles]
# 'sec-level3' role has all permissions, indicated by the 
# wildcard '*'
sec-level3 = *

# The 'sec-level2' role can do anything with access of permission 
# readonly (*) to help
sec-level2 = zone1:*

# The 'sec-level1' role can do anything with access of permission 
# readonly   
sec-level1 = zone1:readonly:*
----

[[BookComponentAppendix-InstantiatingaShiroSecurityPolicyObject]]
Instantiating a ShiroSecurityPolicy Object
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A ShiroSecurityPolicy object is instantiated as follows

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        private final String iniResourcePath = "classpath:shiro.ini";
        private final byte[] passPhrase = {
            (byte) 0x08, (byte) 0x09, (byte) 0x0A, (byte) 0x0B,
            (byte) 0x0C, (byte) 0x0D, (byte) 0x0E, (byte) 0x0F,
            (byte) 0x10, (byte) 0x11, (byte) 0x12, (byte) 0x13,
            (byte) 0x14, (byte) 0x15, (byte) 0x16, (byte) 0x17};
        List<permission> permissionsList = new ArrayList<permission>();
        Permission permission = new WildcardPermission("zone1:readwrite:*");
        permissionsList.add(permission);

        final ShiroSecurityPolicy securityPolicy = 
            new ShiroSecurityPolicy(iniResourcePath, passPhrase, true, permissionsList);
----

[[BookComponentAppendix-ShiroSecurityPolicyOptions]]
ShiroSecurityPolicy Options
^^^^^^^^^^^^^^^^^^^^^^^^^^^

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Default Value |Type |Description
|`iniResourcePath or ini` |`none` |Resource String or Ini Object |A
mandatory Resource String for the iniResourcePath or an instance of an
Ini object must be passed to the security policy. Resources can be
acquired from the file system, classpath, or URLs when prefixed with
"file:, classpath:, or url:" respectively. For e.g "classpath:shiro.ini"

|`passPhrase` |`An AES 128 based key` |byte[] |A passPhrase to decrypt
ShiroSecurityToken(s) sent along with Message Exchanges

|`alwaysReauthenticate` |`true` |boolean |Setting to ensure
re-authentication on every individual request. If set to false, the user
is authenticated and locked such than only requests from the same user
going forward are authenticated.

|`permissionsList` |`none` |List<Permission> |A List of permissions
required in order for an authenticated user to be authorized to perform
further action i.e continue further on the route. If no Permissions list
or Roles List (see below) is provided to the ShiroSecurityPolicy object,
then authorization is deemed as not required. Note that the default is
that authorization is granted if any of the Permission Objects in the
list are applicable.

|`rolesList` |`none` |List<String> |*Camel 2.13:* A List of roles
required in order for an authenticated user to be authorized to perform
further action i.e continue further on the route. If no roles list or
permissions list (see above) is provided to the ShiroSecurityPolicy
object, then authorization is deemed as not required. Note that the
default is that authorization is granted if any of the roles in the list
are applicable.

|`cipherService` |`AES` |org.apache.shiro.crypto.CipherService |Shiro
ships with AES & Blowfish based CipherServices. You may use one these or
pass in your own Cipher implementation

|`base64` |`false` |`boolean` |*Camel 2.12:* To use base64 encoding for
the security token header, which allows transferring the header over
link:jms.html[JMS] etc. This option must also be set on
`ShiroSecurityTokenInjector` as well.

|`allPermissionsRequired` |`false` |`boolean` |*Camel 2.13:* The default
is that authorization is granted if any of the Permission Objects in the
permissionsList parameter are applicable. Set this to true to require
all of the Permissions to be met.

|`allRolesRequired` |`false` |`boolean` |*Camel 2.13:* The default is
that authorization is granted if any of the roles in the rolesList
parameter are applicable. Set this to true to require all of the roles
to be met.
|=======================================================================

[[BookComponentAppendix-ApplyingShiroAuthenticationonaCamelRoute]]
Applying Shiro Authentication on a Camel Route
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ShiroSecurityPolicy, tests and permits incoming message exchanges
containing a encrypted SecurityToken in the Message Header to proceed
further following proper authentication. The SecurityToken object
contains a Username/Password details that are used to determine where
the user is a valid user.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    protected RouteBuilder createRouteBuilder() throws Exception {
        final ShiroSecurityPolicy securityPolicy = 
            new ShiroSecurityPolicy("classpath:shiro.ini", passPhrase);
        
        return new RouteBuilder() {
            public void configure() {
                onException(UnknownAccountException.class).
                    to("mock:authenticationException");
                onException(IncorrectCredentialsException.class).
                    to("mock:authenticationException");
                onException(LockedAccountException.class).
                    to("mock:authenticationException");
                onException(AuthenticationException.class).
                    to("mock:authenticationException");
                
                from("direct:secureEndpoint").
                    to("log:incoming payload").
                    policy(securityPolicy).
                    to("mock:success");
            }
        };
    }
----

[[BookComponentAppendix-ApplyingShiroAuthorizationonaCamelRoute]]
Applying Shiro Authorization on a Camel Route
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Authorization can be applied on a camel route by associating a
Permissions List with the ShiroSecurityPolicy. The Permissions List
specifies the permissions necessary for the user to proceed with the
execution of the route segment. If the user does not have the proper
permission set, the request is not authorized to continue any further.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    protected RouteBuilder createRouteBuilder() throws Exception {
        final ShiroSecurityPolicy securityPolicy = 
            new ShiroSecurityPolicy("./src/test/resources/securityconfig.ini", passPhrase);
        
        return new RouteBuilder() {
            public void configure() {
                onException(UnknownAccountException.class).
                    to("mock:authenticationException");
                onException(IncorrectCredentialsException.class).
                    to("mock:authenticationException");
                onException(LockedAccountException.class).
                    to("mock:authenticationException");
                onException(AuthenticationException.class).
                    to("mock:authenticationException");
                
                from("direct:secureEndpoint").
                    to("log:incoming payload").
                    policy(securityPolicy).
                    to("mock:success");
            }
        };
    }
----

[[BookComponentAppendix-CreatingaShiroSecurityTokenandinjectingitintoaMessageExchange]]
Creating a ShiroSecurityToken and injecting it into a Message Exchange
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A ShiroSecurityToken object may be created and injected into a Message
Exchange using a Shiro Processor called ShiroSecurityTokenInjector. An
example of injecting a ShiroSecurityToken using a
ShiroSecurityTokenInjector in the client is shown below

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    ShiroSecurityToken shiroSecurityToken = new ShiroSecurityToken("ringo", "starr");
    ShiroSecurityTokenInjector shiroSecurityTokenInjector = 
        new ShiroSecurityTokenInjector(shiroSecurityToken, passPhrase);

    from("direct:client").
        process(shiroSecurityTokenInjector).
        to("direct:secureEndpoint");
----

[[BookComponentAppendix-SendingMessagestoroutessecuredbyaShiroSecurityPolicy]]
Sending Messages to routes secured by a ShiroSecurityPolicy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Messages and Message Exchanges sent along the camel route where the
security policy is applied need to be accompanied by a SecurityToken in
the Exchange Header. The SecurityToken is an encrypted object that holds
a Username and Password. The SecurityToken is encrypted using AES 128
bit security by default and can be changed to any cipher of your choice.

Given below is an example of how a request may be sent using a
ProducerTemplate in Camel along with a SecurityToken

[source,brush:,java;,gutter:,false;,theme:,Default]
----
 
    @Test
    public void testSuccessfulShiroAuthenticationWithNoAuthorization() throws Exception {        
        //Incorrect password
        ShiroSecurityToken shiroSecurityToken = new ShiroSecurityToken("ringo", "stirr");

        // TestShiroSecurityTokenInjector extends ShiroSecurityTokenInjector
        TestShiroSecurityTokenInjector shiroSecurityTokenInjector = 
            new TestShiroSecurityTokenInjector(shiroSecurityToken, passPhrase);
        
        successEndpoint.expectedMessageCount(1);
        failureEndpoint.expectedMessageCount(0);
        
        template.send("direct:secureEndpoint", shiroSecurityTokenInjector);
        
        successEndpoint.assertIsSatisfied();
        failureEndpoint.assertIsSatisfied();
    } 
----

[[BookComponentAppendix-SendingMessagestoroutessecuredbyaShiroSecurityPolicy(mucheasierfromCamel2.12onwards)]]
Sending Messages to routes secured by a ShiroSecurityPolicy (much easier
from Camel 2.12 onwards)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

From *Camel 2.12* onwards its even easier as you can provide the subject
in two different ways.

[[BookComponentAppendix-UsingShiroSecurityToken]]
Using ShiroSecurityToken
++++++++++++++++++++++++

You can send a message to a Camel route with a header of key
`ShiroSecurityConstants.SHIRO_SECURITY_TOKEN` of the type
`org.apache.camel.component.shiro.security.ShiroSecurityToken` that
contains the username and password. For example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        ShiroSecurityToken shiroSecurityToken = new ShiroSecurityToken("ringo", "starr");

        template.sendBodyAndHeader("direct:secureEndpoint", "Beatle Mania", ShiroSecurityConstants.SHIRO_SECURITY_TOKEN, shiroSecurityToken);
----

You can also provide the username and password in two different headers
as shown below:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
        Map<String, Object> headers = new HashMap<String, Object>();
        headers.put(ShiroSecurityConstants.SHIRO_SECURITY_USERNAME, "ringo");
        headers.put(ShiroSecurityConstants.SHIRO_SECURITY_PASSWORD, "starr");
        template.sendBodyAndHeaders("direct:secureEndpoint", "Beatle Mania", headers);
----

When you use the username and password headers, then the
ShiroSecurityPolicy in the Camel route will automatic transform those
into a single header with key
ShiroSecurityConstants.SHIRO_SECURITY_TOKEN with the token. Then token
is either a `ShiroSecurityToken` instance, or a base64 representation as
a String (the latter is when you have set base64=true).

[[BookComponentAppendix-SIPComponent]]
SIP Component
~~~~~~~~~~~~~

*Available as of Camel 2.5*

The *sip* component in Camel is a communication component, based on the
Jain SIP implementation (available under the JCP license).

Session Initiation Protocol (SIP) is an IETF-defined signaling protocol,
widely used for controlling multimedia communication sessions such as
voice and video calls over Internet Protocol (IP).The SIP protocol is an
Application Layer protocol designed to be independent of the underlying
transport layer; it can run on Transmission Control Protocol (TCP), User
Datagram Protocol (UDP) or Stream Control Transmission Protocol (SCTP).

The Jain SIP implementation supports TCP and UDP only.

The Camel SIP component *only* supports the SIP Publish and Subscribe
capability as described in the
http://www.ietf.org/rfc/rfc3903.txt[RFC3903 - Session Initiation
Protocol (SIP) Extension for Event]

This camel component supports both producer and consumer endpoints.

Camel SIP Producers (Event Publishers) and SIP Consumers (Event
Subscribers) communicate event & state information to each other using
an intermediary entity called a SIP Presence Agent (a stateful brokering
entity).

For SIP based communication, a SIP Stack with a listener *must* be
instantiated on both the SIP Producer and Consumer (using separate ports
if using localhost). This is necessary in order to support the
handshakes & acknowledgements exchanged between the SIP Stacks during
communication.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-sip</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.57]]
URI format
^^^^^^^^^^

The URI scheme for a sip endpoint is as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
sip://johndoe@localhost:99999[?options]
sips://johndoe@localhost:99999/[?options]
----

This component supports producer and consumer endpoints for both TCP and
UDP.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.46]]
Options
^^^^^^^

The SIP Component offers an extensive set of configuration options &
capability to create custom stateful headers needed to propagate state
via the SIP protocol.

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`stackName` |`NAME_NOT_SET` |Name of the SIP Stack instance associated
with an SIP Endpoint.

|`transport` |`tcp` |Setting for choice of transport potocol. Valid
choices are "tcp" or "udp".

|`fromUser` |  |Username of the message originator. *Mandatory setting
unless a registry based custom FromHeader is specified.*

|`fromHost` |  |Hostname of the message originator. *Mandatory setting
unless a registry based FromHeader is specified*

|`fromPort` |  |Port of the message originator. *Mandatory setting
unless a registry based FromHeader is specified*

|`toUser` |  |Username of the message receiver. *Mandatory setting
unless a registry based custom ToHeader is specified.*

|`toHost` |  |Hostname of the message receiver. *Mandatory setting
unless a registry based ToHeader is specified*

|`toPort` |  |Portname of the message receiver. *Mandatory setting
unless a registry based ToHeader is specified*

|`maxforwards` |0 |the number of intermediaries that may forward the
message to the message receiver. *Optional setting. May alternatively be
set using as registry based MaxForwardsHeader*

|`eventId` |  |Setting for a String based event Id. *Mandatory setting
unless a registry based FromHeader is specified*

|`eventHeaderName` |  |Setting for a String based event Id. *Mandatory
setting unless a registry based FromHeader is specified*

|`maxMessageSize` |`1048576` |Setting for maximum allowed Message size
in bytes.

|`cacheConnections` |`false` |Should connections be cached by the
SipStack to reduce cost of connection creation. This is useful if the
connection is used for long running conversations.

|`consumer` |`false` |This setting is used to determine whether the kind
of header (FromHeader,ToHeader etc) that needs to be created for this
endpoint

|`contentType` |`text` |Setting for contentType can be set to any valid
MimeType.

|`contentSubType` |`xml` |Setting for contentSubType can be set to any
valid MimeSubType.

|`receiveTimeoutMillis` |`10000` |Setting for specifying amount of time
to wait for a Response and/or Acknowledgement can be received from
another SIP stack

|`useRouterForAllUris` |`false` |This setting is used when requests are
sent to the Presence Agent via a proxy.

|`msgExpiration` |`3600` |The amount of time a message received at an
endpoint is considered valid

|`presenceAgent` |`false` |This setting is used to distingish between a
Presence Agent & a consumer. This is due to the fact that the SIP Camel
component ships with a basic Presence Agent (for testing purposes only).
Consumers have to set this flag to true.
|=======================================================================

[[BookComponentAppendix-RegistrybasedOptions.1]]
Registry based Options
^^^^^^^^^^^^^^^^^^^^^^

SIP requires a number of headers to be sent/received as part of a
request. These SIP header can be enlisted in the
link:registry.html[Registry], such as in the Spring XML file.

The values that could be passed in, are the following:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Name |Description
|`fromHeader` |a custom Header object containing message originator
settings. Must implement the type javax.sip.header.FromHeader

|`toHeader` |a custom Header object containing message receiver
settings. Must implement the type javax.sip.header.ToHeader

|`viaHeaders` |List of custom Header objects of the type
javax.sip.header.ViaHeader. Each ViaHeader containing a proxy address
for request forwarding. (Note this header is automatically updated by
each proxy when the request arrives at its listener)

|`contentTypeHeader` |a custom Header object containing message content
details. Must implement the type javax.sip.header.ContentTypeHeader

|`callIdHeader` |a custom Header object containing call details. Must
implement the type javax.sip.header.CallIdHeader

|`maxForwardsHeader` |a custom Header object containing details on
maximum proxy forwards. This header places a limit on the viaHeaders
possible. Must implement the type javax.sip.header.MaxForwardsHeader

|`eventHeader` |a custom Header object containing event details. Must
implement the type javax.sip.header.EventHeader

|`contactHeader` |an optional custom Header object containing verbose
contact details (email, phone number etc). Must implement the type
javax.sip.header.ContactHeader

|`expiresHeader` |a custom Header object containing message expiration
details. Must implement the type javax.sip.header.ExpiresHeader

|`extensionHeader` |a custom Header object containing user/application
specific details. Must implement the type
javax.sip.header.ExtensionHeader
|=======================================================================

[[BookComponentAppendix-SendingMessagesto/fromaSIPendpoint]]
Sending Messages to/from a SIP endpoint
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[BookComponentAppendix-CreatingaCamelSIPPublisher]]
Creating a Camel SIP Publisher
++++++++++++++++++++++++++++++

In the example below, a SIP Publisher is created to send SIP Event
publications to +
a user "agent@localhost:5152". This is the address of the SIP Presence
Agent which acts as a broker between the SIP Publisher and Subscriber

* using a SIP Stack named client
* using a registry based eventHeader called evtHdrName
* using a registry based eventId called evtId
* from a SIP Stack with Listener set up as user2@localhost:3534
* The Event being published is EVENT_A
* A Mandatory Header called REQUEST_METHOD is set to Request.Publish
thereby setting up the endpoint as a Event publisher"

[source,brush:,java;,gutter:,false;,theme:,Default]
----
producerTemplate.sendBodyAndHeader(  
    "sip://agent@localhost:5152?stackName=client&eventHeaderName=evtHdrName&eventId=evtid&fromUser=user2&fromHost=localhost&fromPort=3534",   
    "EVENT_A",  
    "REQUEST_METHOD",   
    Request.PUBLISH);  
----

[[BookComponentAppendix-CreatingaCamelSIPSubscriber]]
Creating a Camel SIP Subscriber
+++++++++++++++++++++++++++++++

In the example below, a SIP Subscriber is created to receive SIP Event
publications sent to +
a user "johndoe@localhost:5154"

* using a SIP Stack named Subscriber
* registering with a Presence Agent user called agent@localhost:5152
* using a registry based eventHeader called evtHdrName. The evtHdrName
contains the Event which is se to "Event_A"
* using a registry based eventId called evtId

[source,brush:,java;,gutter:,false;,theme:,Default]
----
@Override  
protected RouteBuilder createRouteBuilder() throws Exception {  
    return new RouteBuilder() {  
        @Override  
        public void configure() throws Exception {    
            // Create PresenceAgent  
            from("sip://agent@localhost:5152?stackName=PresenceAgent&presenceAgent=true&eventHeaderName=evtHdrName&eventId=evtid")  
                .to("mock:neverland");  
                  
            // Create Sip Consumer(Event Subscriber)  
            from("sip://johndoe@localhost:5154?stackName=Subscriber&toUser=agent&toHost=localhost&toPort=5152&eventHeaderName=evtHdrName&eventId=evtid")  
                .to("log:ReceivedEvent?level=DEBUG")  
                .to("mock:notification");  
                  
        }  
    };  
}  
----

*The Camel SIP component also ships with a Presence Agent that is meant
to be used for Testing and Demo purposes only.* An example of
instantiating a Presence Agent is given above.

Note that the Presence Agent is set up as a user agent@localhost:5152
and is capable of communicating with both Publisher as well as
Subscriber. It has a separate SIP stackName distinct from Publisher as
well as Subscriber. While it is set up as a Camel Consumer, it does not
actually send any messages along the route to the endpoint
"mock:neverland".

[[BookComponentAppendix-SMPPComponent]]
SMPP Component
~~~~~~~~~~~~~~

*CamelSmppFinalStatusAvailable as of Camel 2.2*

This component provides access to an SMSC (Short Message Service Center)
over the http://smsforum.net/SMPP_v3_4_Issue1_2.zip[SMPP] protocol to
send and receive SMS. The http://jsmpp.org[JSMPP] library is used for
the protocol implementation.

The Camel component currently operates as an
http://en.wikipedia.org/wiki/ESME[ESME] (External Short Messaging
Entity) and not as an SMSC itself.

The http://smsrouter.org[SMS Router] project provides an excellent
example of an SMS Router daemon based on the Camel framework, routing
messages between JMS queues (ActiveMQ) and the SMPP network.  Run
multiple instances in parallel for high-availability.

Starting with *Camel 2.9* you are also able to execute ReplaceSm,
QuerySm, SubmitMulti, CancelSm and DataSm.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-smpp</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-SMSlimitations]]
SMS limitations
^^^^^^^^^^^^^^^

SMS is neither reliable or secure.  Users who require reliable and
secure delivery may want to consider using the XMPP or SIP components
instead, combined with a smartphone app supporting the chosen protocol.

* Reliability: although the SMPP standard offers a range of feedback
mechanisms to indicate errors, non-delivery and confirmation of delivery
it is not uncommon for mobile networks to hide or simulate these
responses.  For example, some networks automatically send a delivery
confirmation for every message even if the destination number is invalid
or not switched on.  Some networks silently drop messages if they think
they are spam.  Spam detection rules in the network may be very crude,
sometimes more than 100 messages per day from a single sender may be
considered spam.
* Security: there is basic encryption for the last hop from the radio
tower down to the recipient handset.  SMS messages are not encrypted or
authenticated in any other part of the network.  Some operators allow
staff in retail outlets or call centres to browse through the SMS
message histories of their customers.  Message sender identity can be
easily forged.  Regulators and even the mobile telephone industry itself
has cautioned against the use of SMS in two-factor authentication
schemes and other purposes where security is important.

While the Camel component makes it as easy as possible to send messages
to the SMS network, it can not offer an easy solution to these problems.

[[BookComponentAppendix-Datacoding,alphabetandinternationalcharactersets]]
Data coding, alphabet and international character sets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Data coding and alphabet can be specified on a per-message basis. 
Default values can be specified for the endpoint.  It is important to
understand the relationship between these options and the way the
component acts when more than one value is set.

Data coding is an 8 bit field in the SMPP wire format.

Alphabet corresponds to bits 0-3 of the data coding field.  For some
types of message, where a message class is used (by setting bit 5 of the
data coding field), the lower two bits of the data coding field are not
interpreted as alphabet and only bits 2 and 3 impact the alphabet.

Furthermore, current version of the JSMPP library only seems to support
bits 2 and 3, assuming that bits 0 and 1 are used for message class. 
This is why the Alphabet class in JSMPP doesn't support the value 3
(binary 0011) which indicates ISO-8859-1.

Although JSMPP provides a representation of the message class parameter,
the Camel component doesn't currently provide a way to set it other than
manually setting the corresponding bits in the data coding field.

When setting the data coding field in the outgoing message, the Camel
component considers the following values and uses the first one it can
find:

* the data coding specified in a header
* the alphabet specified in a header
* the data coding specified in the endpoint configuration (URI
parameter)

Older versions of Camel had bugs in support for international character
sets.  This feature only worked when a single encoding was used for all
messages and was troublesome when users wanted to change it on a
per-message basis.  Users who require this to work should ensure their
version of Camel includes the fix for 

JIRA Issues Macro: Unable to locate JIRA server for this macro. It may
be due to Application Link configuration.

.

In addition to trying to send the data coding value to the SMSC, the
Camel component also tries to analyze the message body, convert it to a
Java String (Unicode) and convert that to a byte array in the
corresponding alphabet  When deciding which alphabet to use in the byte
array, the Camel SMPP component does not consider the data coding value
(header or configuration), it only considers the specified alphabet
(from either the header or endpoint parameter).

If some characters in the String can't be represented in the chosen
alphabet, they may be replaced by the question mark ( ? ) symbol.  Users
of the API may want to consider checking if their message body can be
converted to ISO-8859-1 before passing it to the component and if not,
setting the alphabet header to request UCS-2 encoding.  If the alphabet
and data coding options are not specified at all then the component may
try to detect the required encoding and set the data coding for you.

The list of alphabet codes are specified in the SMPP specification v3.4,
section 5.2.19.  One notable limitation of the SMPP specification is
that there is no alphabet code for explicitly requesting use of the GSM
3.38 (7 bit) character set.  Choosing the value 0 for the alphabet
selects the SMSC _default_ alphabet, this usually means GSM 3.38 but it
is not guaranteed.  The SMPP gateway Nexmo
https://help.nexmo.com/hc/en-us/articles/204015813-How-to-change-the-character-encoding-in-SMPP-[actually
allows the default to be mapped to any other character set with a
control panel option]. It is suggested that users check with their SMSC
operator to confirm exactly which character set is being used as the
default.

[[BookComponentAppendix-Messagesplittingandthrottling]]
Message splitting and throttling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

After transforming a message body from a String to a byte array, the
Camel component is also responsible for splitting the message into parts
(within the 140 byte SMS size limit) before passing it to JSMPP.  This
is completed automatically.

If the GSM 3.38 alphabet is used, the component will pack up to 160
characters into the 140 byte message body.  If an 8 bit character set is
used (e.g. ISO-8859-1 for western Europe) then 140 characters will be
allowed within the 140 byte message body.  If 16 bit UCS-2 encoding is
used then just 70 characters fit into each 140 byte message.

Some SMSC providers implement throttling rules.  Each part of a message
that has been split may be counted separately by the provider's
throttling mechanism.  The Camel Throttler component can be useful for
throttling messages in the SMPP route before handing them to the SMSC.

[[BookComponentAppendix-URIformat.58]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
smpp://[username@]hostname[:port][?options]
smpps://[username@]hostname[:port][?options]
----

If no *username* is provided, then Camel will provide the default value
`smppclient`. +
If no *port* number is provided, then Camel will provide the default
value `2775`. +
*Camel 2.3:* If the protocol name is "smpps", camel-smpp with try to use
SSLSocket to init a connection to the server.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-URIOptions.9]]
URI Options
^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`password` |`password` |Specifies the password to use to log in to the
SMSC.

|`systemType` |`cp` |This parameter is used to categorize the type of
ESME (External Short Message Entity) that is binding to the SMSC (max.
13 characters).

|`dataCoding` |`0` |*Camel 2.11* Defines the data coding according the
SMPP 3.4 specification, section 5.2.19. (Prior to *Camel 2.9*, this
option is also supported.) Example data encodings are: +
`0`: SMSC Default Alphabet +
`3`: Latin 1 (ISO-8859-1) +
`4`: Octet unspecified (8-bit binary) +
`8`: UCS2 (ISO/IEC-10646) +
`13`: Extended Kanji JIS(X 0212-1990)

|`alphabet` |`0` |*Camel 2.5* Defines encoding of data according the
SMPP 3.4 specification, section 5.2.19. This option is mapped to
http://code.google.com/p/jsmpp/source/browse/tags/2.1.0/src/java/main/org/jsmpp/bean/Alphabet.java[`Alphabet.java`]
and used to create the `byte[]` which is send to the SMSC. Example
alphabets are: +
`0`: SMSC Default Alphabet +
`4`: 8 bit Alphabet +
`8`: UCS2 Alphabet

|`encoding` |`ISO-8859-1` |*only for SubmitSm, ReplaceSm and
SubmitMulti* Defines the encoding scheme of the short message user data.

|`enquireLinkTimer` |`5000` |Defines the interval in milliseconds
between the confidence checks. The confidence check is used to test the
communication path between an ESME and an SMSC.

|`transactionTimer` |`10000` |Defines the maximum period of inactivity
allowed after a transaction, after which an SMPP entity may assume that
the session is no longer active. This timer may be active on either
communicating SMPP entity (i.e. SMSC or ESME).

|`initialReconnectDelay` |`5000` |Defines the initial delay in
milliseconds after the consumer/producer tries to reconnect to the SMSC,
after the connection was lost.

|`reconnectDelay` |`5000` |Defines the interval in milliseconds between
the reconnect attempts, if the connection to the SMSC was lost and the
previous was not succeed.

|`registeredDelivery` |`1` |*only for SubmitSm, ReplaceSm, SubmitMulti
and DataSm* Is used to request an SMSC delivery receipt and/or SME
originated acknowledgements. The following values are defined: +
`0`: No SMSC delivery receipt requested. +
`1`: SMSC delivery receipt requested where final delivery outcome is
success or failure. +
`2`: SMSC delivery receipt requested where the final delivery outcome is
delivery failure.

|`serviceType` |`CMT` |The service type parameter can be used to
indicate the SMS Application service associated with the message. The
following generic service_types are defined: +
`CMT`: Cellular Messaging +
`CPT`: Cellular Paging +
`VMN`: Voice Mail Notification +
`VMA`: Voice Mail Alerting +
`WAP`: Wireless Application Protocol +
`USSD`: Unstructured Supplementary Services Data

|`sourceAddr` |`1616` |Defines the address of SME (Short Message Entity)
which originated this message.

|`destAddr` |`1717` |*only for SubmitSm, SubmitMulti, CancelSm and
DataSm* Defines the destination SME address. For mobile terminated
messages, this is the directory number of the recipient MS.

|`sourceAddrTon` |`0` |Defines the type of number (TON) to be used in
the SME originator address parameters. The following TON values are
defined: +
`0`: Unknown +
`1`: International +
`2`: National +
`3`: Network Specific +
`4`: Subscriber Number +
`5`: Alphanumeric +
`6`: Abbreviated

|`destAddrTon` |`0` |*only for SubmitSm, SubmitMulti, CancelSm and
DataSm* Defines the type of number (TON) to be used in the SME
destination address parameters. Same as the `sourceAddrTon` values
defined above.

|`sourceAddrNpi` |`0` |Defines the numeric plan indicator (NPI) to be
used in the SME originator address parameters. The following NPI values
are defined: +
`0`: Unknown +
`1`: ISDN (E163/E164) +
`2`: Data (X.121) +
`3`: Telex (F.69) +
`6`: Land Mobile (E.212) +
`8`: National +
`9`: Private +
`10`: ERMES +
`13`: Internet (IP) +
`18`: WAP Client Id (to be defined by WAP Forum)

|`destAddrNpi` |`0` |*only for SubmitSm, SubmitMulti, CancelSm and
DataSm* Defines the numeric plan indicator (NPI) to be used in the SME
destination address parameters. Same as the `sourceAddrNpi` values
defined above.

|`priorityFlag` |`1` |*only for SubmitSm and SubmitMulti* Allows the
originating SME to assign a priority level to the short message. Four
Priority Levels are supported: +
`0`: Level 0 (lowest) priority +
`1`: Level 1 priority +
`2`: Level 2 priority +
`3`: Level 3 (highest) priority

|`replaceIfPresentFlag` |`0` |*only for SubmitSm and SubmitMulti* Used
to request the SMSC to replace a previously submitted message, that is
still pending delivery. The SMSC will replace an existing message
provided that the source address, destination address and service type
match the same fields in the new message. The following replace if
present flag values are defined: +
`0`: Don't replace +
`1`: Replace

|`typeOfNumber` |`0` |Defines the type of number (TON) to be used in the
SME. Use the `sourceAddrTon` values defined above.

|`numberingPlanIndicator` |`0` |Defines the numeric plan indicator (NPI)
to be used in the SME. Use the `sourceAddrNpi` values defined above.

|`lazySessionCreation` |`false` |*Camel 2.8 onwards* Sessions can be
lazily created to avoid exceptions, if the SMSC is not available when
the Camel producer is started. +
*Camel 2.11 onwards* Camel will check the in message headers
'CamelSmppSystemId' and 'CamelSmppPassword' of the first exchange. If
they are present, Camel will use these data to connect to the SMSC.

|`httpProxyHost` |`null` |*Camel 2.9.1:* If you need to tunnel SMPP
through a HTTP proxy, set this attribute to the hostname or ip address
of your HTTP proxy.

|`httpProxyPort` |`3128` |*Camel 2.9.1:* If you need to tunnel SMPP
through a HTTP proxy, set this attribute to the port of your HTTP proxy.

|`httpProxyUsername` |`null` |*Camel 2.9.1:* If your HTTP proxy requires
basic authentication, set this attribute to the username required for
your HTTP proxy.

|`httpProxyPassword` |`null` |*Camel 2.9.1:* If your HTTP proxy requires
basic authentication, set this attribute to the password required for
your HTTP proxy.

|`sessionStateListener` |`null` |*Camel 2.9.3:* You can refer to a
`org.jsmpp.session.SessionStateListener` in the `Registry` to receive
callbacks when the session state changed.

|`addressRange` |`""` |*Camel 2.11:* You can specify the address range
for the `SmppConsumer` as defined in section 5.2.7 of the SMPP 3.4
specification. The `SmppConsumer` will receive messages only from SMSC's
which target an address (MSISDN or IP address) within this range.

|splittingPolicy |ALLOW a|
*Camel 2.14.1 and 2.15.0:* You can specify a policy for handling long
messages:

* ALLOW - the default, long messages are split to 140 bytes per message
* TRUNCATE - long messages are split and only the first fragment will be
sent to the SMSC.  Some carriers drop subsequent fragments so this
reduces load on the SMPP connection sending parts of a message that will
never be delivered.
* REJECT - if a message would need to be split, it is rejected with an
SMPP NegativeResponseException and the reason code signifying the
message is too long.

|proxyHeaders |null |*Camel 2.17:* These headers will be passed to the
proxy server while establishing the connection.

|maxReconnect |2147483647 |*Camel 2.18:* Defines the maximum number of
attempts to reconnect to the SMSC, if SMSC returns a negative bind
response
|=======================================================================

You can have as many of these options as you like.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
smpp://smppclient@localhost:2775?password=password&enquireLinkTimer=3000&transactionTimer=5000&systemType=consumer
----

[[BookComponentAppendix-ProducerMessageHeaders]]
Producer Message Headers
^^^^^^^^^^^^^^^^^^^^^^^^

The following message headers can be used to affect the behavior of the
SMPP producer

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelSmppDestAddr` |`List`/`String` |*only for SubmitSm, SubmitMulti,
CancelSm and DataSm* Defines the destination SME address(es). For mobile
terminated messages, this is the directory number of the recipient MS.
Is must be a `List<String>` for SubmitMulti and a `String` otherwise.

|`CamelSmppDestAddrTon` |`Byte` |*only for SubmitSm, SubmitMulti,
CancelSm and DataSm* Defines the type of number (TON) to be used in the
SME destination address parameters. Use the `sourceAddrTon` URI option
values defined above.

|`CamelSmppDestAddrNpi` |`Byte` |*only for SubmitSm, SubmitMulti,
CancelSm and DataSm* Defines the numeric plan indicator (NPI) to be used
in the SME destination address parameters. Use the URI option
`sourceAddrNpi` values defined above.

|`CamelSmppSourceAddr` |`String` |Defines the address of SME (Short
Message Entity) which originated this message.

|`CamelSmppSourceAddrTon` |`Byte` |Defines the type of number (TON) to
be used in the SME originator address parameters. Use the
`sourceAddrTon` URI option values defined above.

|`CamelSmppSourceAddrNpi` |`Byte` |Defines the numeric plan indicator
(NPI) to be used in the SME originator address parameters. Use the URI
option `sourceAddrNpi` values defined above.

|`CamelSmppServiceType` |`String` |The service type parameter can be
used to indicate the SMS Application service associated with the
message. Use the URI option `serviceType` settings above.

|`CamelSmppRegisteredDelivery` |`Byte` |*only for SubmitSm, ReplaceSm,
SubmitMulti and DataSm* Is used to request an SMSC delivery receipt
and/or SME originated acknowledgements. Use the URI option
`registeredDelivery` settings above.

|`CamelSmppPriorityFlag` |`Byte` |*only for SubmitSm and SubmitMulti*
Allows the originating SME to assign a priority level to the short
message. Use the URI option `priorityFlag` settings above.

|`CamelSmppScheduleDeliveryTime` |`Date` |*only for SubmitSm,
SubmitMulti and ReplaceSm* This parameter specifies the scheduled time
at which the message delivery should be first attempted. It defines
either the absolute date and time or relative time from the current SMSC
time at which delivery of this message will be attempted by the SMSC. It
can be specified in either absolute time format or relative time format.
The encoding of a time format is specified in chapter 7.1.1. in the smpp
specification v3.4.

|`CamelSmppValidityPeriod` |`String`/`Date` |*only for SubmitSm,
SubmitMulti and ReplaceSm* The validity period parameter indicates the
SMSC expiration time, after which the message should be discarded if not
delivered to the destination. If it's provided as `Date`, it's
interpreted as absolute time. *Camel 2.9.1 onwards:* It can be defined
in absolute time format or relative time format if you provide it as
`String` as specified in chapter 7.1.1 in the smpp specification v3.4.

|`CamelSmppReplaceIfPresentFlag` |`Byte` |*only for SubmitSm and
SubmitMulti* The replace if present flag parameter is used to request
the SMSC to replace a previously submitted message, that is still
pending delivery. The SMSC will replace an existing message provided
that the source address, destination address and service type match the
same fields in the new message. The following values are defined: +
`0`: Don't replace +
`1`: Replace

|`CamelSmppAlphabet` / `CamelSmppDataCoding` |`Byte` |*Camel 2.5* *For
SubmitSm, SubmitMulti and ReplaceSm* (Prior to *Camel 2.9* use
`CamelSmppDataCoding` instead of `CamelSmppAlphabet`.) The data coding
according to the SMPP 3.4 specification, section 5.2.19. Use the URI
option `alphabet` settings above.

|`CamelSmppOptionalParameters` |`Map<String, String>` |*Deprecated and
will be removed in Camel 2.13.0/3.0.0* +
*Camel 2.10.5 and 2.11.1 onwards and only for SubmitSm, SubmitMulti and
DataSm* The optional parameters send back by the SMSC.

|`CamelSmppOptionalParameter` |`Map<Short, Object>` |*Camel 2.10.7 and
2.11.2 onwards and only for SubmitSm, SubmitMulti and DataSm* The
optional parameter which are send to the SMSC. The value is converted in
the following way: +
`String` -> `org.jsmpp.bean.OptionalParameter.COctetString` +
`byte[]` -> `org.jsmpp.bean.OptionalParameter.OctetString` +
`Byte` -> `org.jsmpp.bean.OptionalParameter.Byte` +
`Integer` -> `org.jsmpp.bean.OptionalParameter.Int` +
`Short` -> `org.jsmpp.bean.OptionalParameter.Short` +
`null` -> `org.jsmpp.bean.OptionalParameter.Null`

|CamelSmppEncoding |String |*Camel 2.14.1 and Camel 2.15.0 onwards and*
*only for SubmitSm, SubmitMulti and DataSm*.  Specifies the encoding
(character set name) of the bytes in the message body.  If the message
body is a string then this is not relevant because Java Strings are
always Unicode.  If the body is a byte array then this header can be
used to indicate that it is ISO-8859-1 or some other value.  Default
value is specified by the endpoint configuration parameter _encoding_

|CamelSmppSplittingPolicy |String |*Camel 2.14.1 and Camel 2.15.0
onwards and* *only for SubmitSm, SubmitMulti and DataSm*.  Specifies the
policy for message splitting for this exchange.  Possible values are
described in the endpoint configuration parameter _splittingPolicy_
|=======================================================================

The following message headers are used by the SMPP producer to set the
response from the SMSC in the message header

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelSmppId` |`List<String>`/`String` |The id to identify the
submitted short message(s) for later use. *From Camel 2.9.0*: In case of
a ReplaceSm, QuerySm, CancelSm and DataSm this header vaule is a
`String`. In case of a SubmitSm or SubmitMultiSm this header vaule is a
`List<String>`.

|`CamelSmppSentMessageCount` |`Integer` |*From Camel 2.9 onwards only
for SubmitSm and SubmitMultiSm* The total number of messages which has
been sent.

|`CamelSmppError` |`Map<String, List<Map<String, Object>>>` |*From Camel
2.9 onwards only for SubmitMultiSm* The errors which occurred by sending
the short message(s) the form `Map<String, List<Map<String, Object>>>`
(messageID : (destAddr : address, error : errorCode)).

|`CamelSmppOptionalParameters` |`Map<String, String>` |*Deprecated and
will be removed in Camel 2.13.0/3.0.0* +
*From Camel 2.11.1 onwards only for DataSm* The optional parameters
which are returned from the SMSC by sending the message.

|`CamelSmppOptionalParameter` |`Map<Short, Object>` |*From Camel 2.10.7,
2.11.2 onwards only for DataSm* The optional parameter which are
returned from the SMSC by sending the message. The key is the `Short`
code for the optional parameter. The value is converted in the following
way: +
`org.jsmpp.bean.OptionalParameter.COctetString` -> `String` +
`org.jsmpp.bean.OptionalParameter.OctetString` -> `byte[]` +
`org.jsmpp.bean.OptionalParameter.Byte` -> `Byte` +
`org.jsmpp.bean.OptionalParameter.Int` -> `Integer` +
`org.jsmpp.bean.OptionalParameter.Short` -> `Short` +
`org.jsmpp.bean.OptionalParameter.Null` -> `null`
|=======================================================================

[[BookComponentAppendix-ConsumerMessageHeaders]]
Consumer Message Headers
^^^^^^^^^^^^^^^^^^^^^^^^

The following message headers are used by the SMPP consumer to set the
request data from the SMSC in the message header

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|`CamelSmppSequenceNumber` |`Integer` |*only for AlertNotification,
DeliverSm and DataSm* A sequence number allows a response PDU to be
correlated with a request PDU. The associated SMPP response PDU must
preserve this field.

|`CamelSmppCommandId` |`Integer` |*only for AlertNotification, DeliverSm
and DataSm* The command id field identifies the particular SMPP PDU. For
the complete list of defined values see chapter 5.1.2.1 in the smpp
specification v3.4.

|`CamelSmppSourceAddr` |`String` |*only for AlertNotification, DeliverSm
and DataSm* Defines the address of SME (Short Message Entity) which
originated this message.

|`CamelSmppSourceAddrNpi` |`Byte` |*only for AlertNotification and
DataSm* Defines the numeric plan indicator (NPI) to be used in the SME
originator address parameters. Use the URI option `sourceAddrNpi` values
defined above.

|`CamelSmppSourceAddrTon` |`Byte` |*only for AlertNotification and
DataSm* Defines the type of number (TON) to be used in the SME
originator address parameters. Use the `sourceAddrTon` URI option values
defined above.

|`CamelSmppEsmeAddr` |`String` |*only for AlertNotification* Defines the
destination ESME address. For mobile terminated messages, this is the
directory number of the recipient MS.

|`CamelSmppEsmeAddrNpi` |`Byte` |*only for AlertNotification* Defines
the numeric plan indicator (NPI) to be used in the ESME originator
address parameters. Use the URI option `sourceAddrNpi` values defined
above.

|`CamelSmppEsmeAddrTon` |`Byte` |*only for AlertNotification* Defines
the type of number (TON) to be used in the ESME originator address
parameters. Use the `sourceAddrTon` URI option values defined above.

|`CamelSmppId` |`String` |*only for smsc DeliveryReceipt and DataSm* The
message ID allocated to the message by the SMSC when originally
submitted.

|`CamelSmppDelivered` |`Integer` |*only for smsc DeliveryReceipt* Number
of short messages delivered. This is only relevant where the original
message was submitted to a distribution list.The value is padded with
leading zeros if necessary.

|`CamelSmppDoneDate` |`Date` |*only for smsc DeliveryReceipt* The time
and date at which the short message reached it's final state. The format
is as follows: YYMMDDhhmm.

|`CamelSmppStatus` |`DeliveryReceiptState` |*only for smsc
DeliveryReceipt:* The final status of the message. The following values
are defined: +
`DELIVRD`: Message is delivered to destination +
`EXPIRED`: Message validity period has expired. +
`DELETED`: Message has been deleted. +
`UNDELIV`: Message is undeliverable +
`ACCEPTD`: Message is in accepted state (i.e. has been manually read on
behalf of the subscriber by customer service) +
`UNKNOWN`: Message is in invalid state +
`REJECTD`: Message is in a rejected state

|`CamelSmppCommandStatus` |`Integer` |*only for DataSm* The Command
status of the message.

|`CamelSmppError` |`String` |*only for smsc DeliveryReceipt* Where
appropriate this may hold a Network specific error code or an SMSC error
code for the attempted delivery of the message. These errors are Network
or SMSC specific and are not included here.

|`CamelSmppSubmitDate` |`Date` |*only for smsc DeliveryReceipt* The time
and date at which the short message was submitted. In the case of a
message which has been replaced, this is the date that the original
message was replaced. The format is as follows: YYMMDDhhmm.

|`CamelSmppSubmitted` |`Integer` |*only for smsc DeliveryReceipt* Number
of short messages originally submitted. This is only relevant when the
original message was submitted to a distribution list.The value is
padded with leading zeros if necessary.

|`CamelSmppDestAddr` |`String` |*only for DeliverSm and DataSm:* Defines
the destination SME address. For mobile terminated messages, this is the
directory number of the recipient MS.

|`CamelSmppScheduleDeliveryTime` |`String` |*only for DeliverSm:* This
parameter specifies the scheduled time at which the message delivery
should be first attempted. It defines either the absolute date and time
or relative time from the current SMSC time at which delivery of this
message will be attempted by the SMSC. It can be specified in either
absolute time format or relative time format. The encoding of a time
format is specified in Section 7.1.1. in the smpp specification v3.4.

|`CamelSmppValidityPeriod` |`String` |*only for DeliverSm* The validity
period parameter indicates the SMSC expiration time, after which the
message should be discarded if not delivered to the destination. It can
be defined in absolute time format or relative time format. The encoding
of absolute and relative time format is specified in Section 7.1.1 in
the smpp specification v3.4.

|`CamelSmppServiceType` |`String` |*only for DeliverSm and DataSm* The
service type parameter indicates the SMS Application service associated
with the message.

|`CamelSmppRegisteredDelivery` |`Byte` |*only for DataSm* Is used to
request an delivery receipt and/or SME originated acknowledgements. Same
values as in Producer header list above.

|`CamelSmppDestAddrNpi` |`Byte` |*only for DataSm* Defines the numeric
plan indicator (NPI) in the destination address parameters. Use the URI
option `sourceAddrNpi` values defined above.

|`CamelSmppDestAddrTon` |`Byte` |*only for DataSm* Defines the type of
number (TON) in the destination address parameters. Use the
`sourceAddrTon` URI option values defined above.

|`CamelSmppMessageType` |`String` |*Camel 2.6 onwards*: Identifies the
type of an incoming message: +
`AlertNotification`: an SMSC alert notification +
`DataSm`: an SMSC data short message +
`DeliveryReceipt`: an SMSC delivery receipt +
`DeliverSm`: an SMSC deliver short message

|`CamelSmppOptionalParameters` |`Map<String, Object>` |*Deprecated and
will be removed in Camel 2.13.0/3.0.0* +
*Camel 2.10.5 onwards and only for DeliverSm* The optional parameters
send back by the SMSC.

|`CamelSmppOptionalParameter` |`Map<Short, Object>` |*Camel 2.10.7,
2.11.2 onwards and only for DeliverSm* The optional parameters send back
by the SMSC. The key is the `Short` code for the optional parameter. The
value is converted in the following way: +
`org.jsmpp.bean.OptionalParameter.COctetString` -> `String` +
`org.jsmpp.bean.OptionalParameter.OctetString` -> `byte[]` +
`org.jsmpp.bean.OptionalParameter.Byte` -> `Byte` +
`org.jsmpp.bean.OptionalParameter.Int` -> `Integer` +
`org.jsmpp.bean.OptionalParameter.Short` -> `Short` +
`org.jsmpp.bean.OptionalParameter.Null` -> `null`
|=======================================================================

[Tip]
====
 **JSMPP library**

See the documentation of the http://jsmpp.org[JSMPP Library] for more
details about the underlying library.

====

[[BookComponentAppendix-Exceptionhandling.1]]
Exception handling
^^^^^^^^^^^^^^^^^^

This component supports the general Camel exception handling
capabilities

When an error occurs sending a message with SubmitSm (the default
action), the org.apache.camel.component.smpp.SmppException is thrown
with a nested exception, org.jsmpp.extra.NegativeResponseException. 
Call NegativeResponseException.getCommandStatus() to obtain the exact
SMPP negative response code, the values are explained in the SMPP
specification 3.4, section 5.1.3. +
*Camel 2.8 onwards*: When the SMPP consumer receives a `DeliverSm` or
`DataSm` short message and the processing of these messages fails, you
can also throw a `ProcessRequestException` instead of handle the
failure. In this case, this exception is forwarded to the underlying
http://jsmpp.org[JSMPP library] which will return the included error
code to the SMSC. This feature is useful to e.g. instruct the SMSC to
resend the short message at a later time. This could be done with the
following lines of code:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("smpp://smppclient@localhost:2775?password=password&enquireLinkTimer=3000&transactionTimer=5000&systemType=consumer")
  .doTry()
    .to("bean:dao?method=updateSmsState")
  .doCatch(Exception.class)
    .throwException(new ProcessRequestException("update of sms state failed", 100))
  .end();
----

Please refer to the http://smsforum.net/SMPP_v3_4_Issue1_2.zip[SMPP
specification] for the complete list of error codes and their meanings.

[[BookComponentAppendix-Samples.11]]
Samples
^^^^^^^

See the http://smsrouter.org[SMS Router] source code for a full sample
application.  Consider integrating your application with SMS Router
through queues rather than adding the SMPP code directly to your routes,
building a more loosely-coupled architecture.

A route which sends an SMS using the Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start")
  .to("smpp://smppclient@localhost:2775?
      password=password&enquireLinkTimer=3000&transactionTimer=5000&systemType=producer");
----

A route which sends an SMS using the Spring XML DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<route>
  <from uri="direct:start"/>
  <to uri="smpp://smppclient@localhost:2775?
           password=password&amp;enquireLinkTimer=3000&amp;transactionTimer=5000&amp;systemType=producer"/>
</route>
----

A route which receives an SMS using the Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("smpp://smppclient@localhost:2775?password=password&enquireLinkTimer=3000&transactionTimer=5000&systemType=consumer")
  .to("bean:foo");
----

A route which receives an SMS using the Spring XML DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <route>
     <from uri="smpp://smppclient@localhost:2775?
                password=password&amp;enquireLinkTimer=3000&amp;transactionTimer=5000&amp;systemType=consumer"/>
     <to uri="bean:foo"/>
  </route>
----

[Tip]
====
 **SMSC simulator**

If you need an SMSC simulator for your test, you can use the simulator
provided by
http://opensmpp.logica.com/CommonPart/Download/download2.html#simulator[Logica].

====

[[BookComponentAppendix-Debuglogging.2]]
Debug logging
^^^^^^^^^^^^^

This component has log level *DEBUG*, which can be helpful in debugging
problems. If you use log4j, you can add the following line to your
configuration:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
log4j.logger.org.apache.camel.component.smpp=DEBUG
----

[[BookComponentAppendix-SeeAlso.31]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-SNMPComponent]]
SNMP Component
~~~~~~~~~~~~~~

*Available as of Camel 2.1*

The *snmp:* component gives you the ability to poll SNMP capable devices
or receiving traps.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-snmp</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.59]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
snmp://hostname[:port][?Options]
----

The component supports polling OID values from an SNMP enabled device
and receiving traps.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.47]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`type` |none |The type of action you want to perform. Actually you can
enter here `POLL` or `TRAP`. The value `POLL` will instruct the endpoint
to poll a given host for the supplied OID keys. If you put in `TRAP` you
will setup a listener for SNMP Trap Events.

|`protocol` |`udp` |Here you can select which protocol to use. You can
use either `udp` or `tcp`.

|`retries` |`2` |Defines how often a retry is made before canceling the
request.

|`timeout` |`1500` |Sets the timeout value for the request in millis.

|`snmpVersion` |`0` (which means SNMPv1) |Sets the snmp version for the
request.

|`snmpCommunity` |`public` |Sets the community octet string for the snmp
request.

|`delay` |`60` seconds |Defines the delay in seconds between to poll
cycles. From *Camel 2.15* onwards the delay is using millis as its
timeunit, so configure 30000 for 30 seconds. Older releases uses the
value in seconds.

|`oids` |none |Defines which values you are interested in. Please have a
look at the http://en.wikipedia.org/wiki/Object_identifier[Wikipedia] to
get a better understanding. You may provide a single OID or a coma
separated list of OIDs. Example:
oids="1.3.6.1.2.1.1.3.0,1.3.6.1.2.1.25.3.2.1.5.1,1.3.6.1.2.1.25.3.5.1.1.1,1.3.6.1.2.1.43.5.1.1.11.1"
|=======================================================================

[[BookComponentAppendix-Theresultofapoll]]
The result of a poll
^^^^^^^^^^^^^^^^^^^^

Given the situation, that I poll for the following OIDs:

*OIDs*

[source,brush:,java;,gutter:,false;,theme:,Default]
----
1.3.6.1.2.1.1.3.0
1.3.6.1.2.1.25.3.2.1.5.1
1.3.6.1.2.1.25.3.5.1.1.1
1.3.6.1.2.1.43.5.1.1.11.1
----

The result will be the following:

*Result of toString conversion*

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<?xml version="1.0" encoding="UTF-8"?>
<snmp>
  <entry>
    <oid>1.3.6.1.2.1.1.3.0</oid>
    <value>6 days, 21:14:28.00</value>
  </entry>
  <entry>
    <oid>1.3.6.1.2.1.25.3.2.1.5.1</oid>
    <value>2</value>
  </entry>
  <entry>
    <oid>1.3.6.1.2.1.25.3.5.1.1.1</oid>
    <value>3</value>
  </entry>
  <entry>
    <oid>1.3.6.1.2.1.43.5.1.1.11.1</oid>
    <value>6</value>
  </entry>
  <entry>
    <oid>1.3.6.1.2.1.1.1.0</oid>
    <value>My Very Special Printer Of Brand Unknown</value>
  </entry>
</snmp>
----

As you maybe recognized there is one more result than
requested....1.3.6.1.2.1.1.1.0. +
This one is filled in by the device automatically in this special case.
So it may absolutely happen, that you receive more than you
requested...be prepared.

[[BookComponentAppendix-Examples.14]]
Examples
^^^^^^^^

Polling a remote device:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
snmp:192.168.178.23:161?protocol=udp&type=POLL&oids=1.3.6.1.2.1.1.5.0
----

Setting up a trap receiver (*Note that no OID info is needed here!*):

[source,brush:,java;,gutter:,false;,theme:,Default]
----
snmp:127.0.0.1:162?protocol=udp&type=TRAP
----

*From Camel 2.10.0*, you can get the community of SNMP TRAP with message
header 'securityName', +
peer address of the SNMP TRAP with message header 'peerAddress'.

Routing example in Java: (converts the SNMP PDU to XML String)

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("snmp:192.168.178.23:161?protocol=udp&type=POLL&oids=1.3.6.1.2.1.1.5.0").
convertBodyTo(String.class).
to("activemq:snmp.states");
----

[[BookComponentAppendix-SeeAlso.32]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-SpringIntegrationComponent]]
Spring Integration Component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *spring-integration:* component provides a bridge for Camel
components to talk to
http://www.springsource.org/spring-integration[spring integration
endpoints].

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml <dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-spring-integration</artifactId>
<version>x.x.x</version> <!-- use the same version as your Camel core
version --> </dependency>

[[BookComponentAppendix-URIformat.60]]
URI format
^^^^^^^^^^

spring-integration:defaultChannelName[?options]

Where *defaultChannelName* represents the default channel name which is
used by the Spring Integration Spring context. It will equal to the
`inputChannel` name for the Spring Integration consumer and the
`outputChannel` name for the Spring Integration provider.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.48]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`inputChannel` |String |The Spring integration input channel name that
this endpoint wants to consume from, where the specified channel name is
defined in the Spring context.

|`outputChannel` |String |The Spring integration output channel name
that is used to send messages to the Spring integration context.

|`inOut` |String |The exchange pattern that the Spring integration
endpoint should use. If `inOut=true` then a reply channel is expected,
either from the Spring Integration Message header or configured on the
endpoint.
|=======================================================================

[[BookComponentAppendix-Usage.7]]
Usage
^^^^^

The Spring integration component is a bridge that connects Camel
endpoints with Spring integration endpoints through the Spring
integration's input channels and output channels. Using this component,
we can send Camel messages to Spring Integration endpoints or receive
messages from Spring integration endpoints in a Camel routing context.

[[BookComponentAppendix-Examples.15]]
Examples
^^^^^^^^

[[BookComponentAppendix-UsingtheSpringintegrationendpoint]]
Using the Spring integration endpoint
+++++++++++++++++++++++++++++++++++++

You can set up a Spring integration endpoint using a URI, as follows:

\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring-integration/src/test/resources/org/apache/camel/component/spring/integration/producer.xml}
\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring-integration/src/test/resources/org/apache/camel/component/spring/integration/twoWayConsumer.xml}

Or directly using a Spring integration channel name:

\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring-integration/src/test/resources/org/apache/camel/component/spring/integration/springChannelConverter.xml}

[[BookComponentAppendix-TheSourceandTargetadapter]]
The Source and Target adapter
+++++++++++++++++++++++++++++

Spring integration also provides the Spring integration's source and
target adapters, which can route messages from a Spring integration
channel to a Camel endpoint or from a Camel endpoint to a Spring
integration channel.

This example uses the following namespaces:

\{snippet:id=header|lang=xml|url=camel/trunk/components/camel-spring-integration/src/test/resources/org/apache/camel/component/spring/integration/adapter/CamelTarget.xml}

You can bind your source or target to a Camel endpoint as follows:

\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring-integration/src/test/resources/org/apache/camel/component/spring/integration/adapter/CamelTarget.xml}
\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring-integration/src/test/resources/org/apache/camel/component/spring/integration/adapter/CamelSource.xml}
link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-SpringLDAPComponent]]
Spring LDAP Component
~~~~~~~~~~~~~~~~~~~~~

*Available since Camel 2.11*

The *spring-ldap:* component provides a Camel wrapper for
http://www.springsource.org/ldap[Spring LDAP].

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-spring-ldap</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.61]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
spring-ldap:springLdapTemplate[?options]
----

Where *springLdapTemplate* is the name of the
http://static.springsource.org/spring-ldap/site/apidocs/org/springframework/ldap/core/LdapTemplate.html[Spring
LDAP Template bean]. In this bean, you configure the URL and the
credentials for your LDAP access.

[[BookComponentAppendix-Options.49]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`operation` |String |The LDAP operation to be performed. Must be one of
`search`, `bind`, or `unbind`.

|`scope` |String |The scope of the search operation. Must be one of
`object`, `onelevel`, or `subtree`, see also
http://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol#Search_and_Compare
|=======================================================================

If an unsupported value is specified for some option, the component
throws an `UnsupportedOperationException`.

[[BookComponentAppendix-Usage.8]]
Usage
^^^^^

The component supports producer endpoint only. An attempt to create a
consumer endpoint will result in an `UnsupportedOperationException`. +
The body of the message must be a map (an instance of `java.util.Map`).
This map must contain at least an entry with the key *`dn`* that
specifies the root node for the LDAP operation to be performed. Other
entries of the map are operation-specific (see below).

The body of the message remains unchanged for the `bind` and `unbind`
operations. For the `search` operation, the body is set to the result of
the search, see
http://static.springsource.org/spring-ldap/site/apidocs/org/springframework/ldap/core/LdapTemplate.html#search%28java.lang.String,%20java.lang.String,%20int,%20org.springframework.ldap.core.AttributesMapper%29.

[[BookComponentAppendix-Search]]
Search
++++++

The message body must have an entry with the key *`filter`*. The value
must be a String representing a valid LDAP filter, see
http://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol#Search_and_Compare.

[[BookComponentAppendix-Bind]]
Bind
++++

The message body must have an entry with the key *`attributes`*. The
value must be an instance of
http://docs.oracle.com/javase/6/docs/api/javax/naming/directory/Attributes.html[javax.naming.directory.Attributes]
This entry specifies the LDAP node to be created.

[[BookComponentAppendix-Unbind]]
Unbind
++++++

No further entries necessary, the node with the specified *`dn`* is
deleted.

*Key definitions*

In order to avoid spelling errors, the following constants are defined
in `org.apache.camel.springldap.SpringLdapProducer`:

* public static final String DN = "dn"
* public static final String FILTER = "filter"
* public static final String ATTRIBUTES = "attributes"

[[BookComponentAppendix-SpringWebServicesComponent]]
Spring Web Services Component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.6*

The *spring-ws:* component allows you to integrate with
http://static.springsource.org/spring-ws/sites/1.5/[Spring Web
Services]. It offers both _client_-side support, for accessing web
services, and _server_-side support for creating your own contract-first
web services.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-spring-ws</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[Info]
====
 **Dependencies**

As of Camel 2.8 this component ships with Spring-WS 2.0.x which (like
the rest of Camel) requires Spring 3.0.x.

Earlier Camel versions shipped Spring-WS 1.5.9 which is compatible with
Spring 2.5.x and 3.0.x. In order to run earlier versions of
`camel-spring-ws` on Spring 2.5.x you need to add the `spring-webmvc`
module from Spring 2.5.x. In order to run Spring-WS 1.5.9 on Spring
3.0.x you need to exclude the OXM module from Spring 3.0.x as this
module is also included in Spring-WS 1.5.9 (see
http://stackoverflow.com/questions/3313314/can-spring-ws-1-5-be-used-with-spring-3[this
post])

====

[[BookComponentAppendix-URIformat.62]]
URI format
^^^^^^^^^^

The URI scheme for this component is as follows

[source,brush:,java;,gutter:,false;,theme:,Default]
----
spring-ws:[mapping-type:]address[?options]
----

To expose a web service *mapping-type* needs to be set to any of the
following:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Mapping type |Description
|`rootqname` |Offers the option to map web service requests based on the
qualified name of the root element contained in the message.

|`soapaction` |Used to map web service requests based on the SOAP action
specified in the header of the message.

|`uri` |In order to map web service requests that target a specific URI.

|`xpathresult` |Used to map web service requests based on the evaluation
of an XPath `expression` against the incoming message. The result of the
evaluation should match the XPath result specified in the endpoint URI.

|`beanname` |Allows you to reference an
`org.apache.camel.component.spring.ws.bean.CamelEndpointDispatcher`
object in order to integrate with existing (legacy)
http://static.springsource.org/spring-ws/sites/1.5/reference/html/server.html#server-endpoint-mapping[endpoint
mappings] like `PayloadRootQNameEndpointMapping`,
`SoapActionEndpointMapping`, etc
|=======================================================================

As a consumer the *address* should contain a value relevant to the
specified mapping-type (e.g. a SOAP action, XPath expression). As a
producer the address should be set to the URI of the web service your
calling upon.

You can append query *options* to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.50]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Required? |Description
|`soapAction` |No |SOAP action to include inside a SOAP request when
accessing remote web services

|`wsAddressingAction` |No |WS-Addressing 1.0 action header to include
when accessing web services. The `To` header is set to the _address_ of
the web service as specified in the endpoint URI (default Spring-WS
behavior).

|outputAction |No |Signifies the value for the response WS-Addressing
Action header that is provided by the method. 

|faultAction |No |Signifies the value for the faultAction response
WS-Addressing Fault Action header that is provided by the method.

|faultTo |No |Signifies the value for the faultAction response
WS-Addressing FaultTo header that is provided by the method.

|replyTo |No |Signifies the value for the replyTo response
WS-Addressing ReplyTo header that is provided by the method.

|`expression` |Only when _mapping-type_ is `xpathresult` |XPath
expression to use in the process of mapping web service requests, should
match the result specified by `xpathresult`

|`timeout` |No |*Camel 2.10:* Sets the socket read timeout (in
milliseconds) while invoking a webservice using the producer, see
http://docs.oracle.com/javase/6/docs/api/java/net/URLConnection.html#setReadTimeout(int)[URLConnection.setReadTimeout()]
and
http://static.springsource.org/spring-ws/site/apidocs/org/springframework/ws/transport/http/CommonsHttpMessageSender.html#setReadTimeout(int)[CommonsHttpMessageSender.setReadTimeout()].
 This option works when using the built-in message sender
implementations: _CommonsHttpMessageSender_ and _HttpUrlConnectionMessageSender_.
 One of these implementations will be used by default for HTTP based
services unless you customize the Spring WS configuration options
supplied to the component.  If you are using a non-standard sender, it
is assumed that you will handle your own timeout configuration. +
*Camel 2.12:* The built-in message
sender _HttpComponentsMessageSender_ is considered *instead
of* _CommonsHttpMessageSender_ which has been deprecated, see
http://static.springsource.org/spring-ws/site/apidocs/org/springframework/ws/transport/http/HttpComponentsMessageSender.html#setReadTimeout(int)[HttpComponentsMessageSender.setReadTimeout()].

|`sslContextParameters` |No |*Camel 2.10:* Reference to
an `org.apache.camel.util.jsse.SSLContextParameters`
in the http://camel.apache.org/registry.html[Registry].
 See http://camel.apache.org/http4.html#HTTP4-UsingtheJSSEConfigurationUtility[Using
the JSSE Configuration Utility].  This option works when using the
built-in message sender
implementations: _CommonsHttpMessageSender_ and _HttpUrlConnectionMessageSender_.
 One of these implementations will be used by default for HTTP based
services unless you customize the Spring WS configuration options
supplied to the component.  If you are using a non-standard sender, it
is assumed that you will handle your own TLS configuration. +
*Camel 2.12:* The built-in message
sender _HttpComponentsMessageSender_ is considered *instead
of* _CommonsHttpMessageSender_ which has been deprecated.

|`webServiceTemplate` |No |Option to provide a custom
http://static.springsource.org/spring-ws/sites/1.5/apidocs/org/springframework/ws/client/core/WebServiceTemplate.html[WebServiceTemplate].
This allows for full control over client-side web services handling;
like adding a custom interceptor or specifying a fault resolver, message
sender or message factory.

|`messageSender` |No |Option to provide a custom
http://static.springsource.org/spring-ws/sites/1.5/apidocs/org/springframework/ws/transport/WebServiceMessageSender.html[WebServiceMessageSender].
For example to perform authentication or use alternative transports

|`messageFactory` |No |Option to provide a custom
http://static.springsource.org/spring-ws/sites/1.5/apidocs/org/springframework/ws/WebServiceMessageFactory.html[WebServiceMessageFactory].
For example when you want Apache Axiom to handle web service messages
instead of SAAJ

|endpointMappingKey |No |Reference to an instance of
org.apache.camel.component.spring.ws.type.EndpointMappingKey

|`endpointMapping` |Only when _mapping-type_ is `rootqname`,
`soapaction`, `uri` or `xpathresult` |Reference to an instance of
`org.apache.camel.component.spring.ws.bean.CamelEndpointMapping` in the
Registry/ApplicationContext. Only one bean is required in the registry
to serve all Camel/Spring-WS endpoints. This bean is auto-discovered by
the
http://static.springsource.org/spring-ws/sites/1.5/apidocs/org/springframework/ws/server/MessageDispatcher.html[MessageDispatcher]
and used to map requests to Camel endpoints based on characteristics
specified on the endpoint (like root QName, SOAP action, etc)

|endpointDispatcher |No | Spring \{@link
http://org.springframework.ws[org.springframework.ws].server.endpoint.MessageEndpoint}
for dispatching messages received by Spring-WS to a Camel endpoint, to
integrate with existing (legacy) endpoint mappings like
PayloadRootQNameEndpointMapping, SoapActionEndpointMapping, etc.

|`messageFilter` |No |*Camel 2.10.3* Option to provide a custom
MessageFilter. For example when you want to process your headers or
attachments by your own.

|messageIdStrategy |No |A custom MessageIdStrategy to control generation
of unique message ids

|webServiceEndpointUri |No |The default Web Service endpoint uri to use
for the producer
|=======================================================================

[[BookComponentAppendix-Messageheaders]]
Message headers
+++++++++++++++

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`CamelSpringWebserviceEndpointUri` |String |URI of the web service your
accessing as a client, overrides _address_ part of the endpoint URI

|`CamelSpringWebserviceSoapAction` |String |Header to specify the SOAP
action of the message, overrides `soapAction` option if present

|CamelSpringWebserviceSoapHeader |Source |**Camel 2.11.1:** Use this
header to specify/access the SOAP headers of the message.

|`CamelSpringWebserviceAddressingAction` |URI |Use this header to
specify the WS-Addressing action of the message, overrides
`wsAddressingAction` option if present

|CamelSpringWebserviceAddressingFaultTo |URI |Use this header to specify
the  WS-Addressing FaultTo , overrides faultTo option if present

|CamelSpringWebserviceAddressingReplyTo |URI |Use this header to specify
the  WS-Addressing ReplyTo , overrides replyTo option if present

|CamelSpringWebserviceAddressingOutputAction |URI |Use this header to
specify the WS-Addressing Action , overrides outputAction option if
present

|CamelSpringWebserviceAddressingFaultAction |URI |Use this header to
specify the WS-Addressing Fault Action , overrides faultAction option if
present
|=======================================================================

[[BookComponentAppendix-Accessingwebservices]]
Accessing web services
~~~~~~~~~~~~~~~~~~~~~~

To call a web service at `http://foo.com/bar` simply define a route:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:example").to("spring-ws:http://foo.com/bar")
----

And sent a message:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
template.requestBody("direct:example", "<foobar xmlns=\"http://foo.com\"><msg>test message</msg></foobar>");
----

Remember if it's a SOAP service you're calling you don't have to include
SOAP tags. Spring-WS will perform the XML-to-SOAP marshaling.

[[BookComponentAppendix-SendingSOAPandWS-Addressingactionheaders]]
Sending SOAP and WS-Addressing action headers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When a remote web service requires a SOAP action or use of the
WS-Addressing standard you define your route as:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:example")
.to("spring-ws:http://foo.com/bar?soapAction=http://foo.com&wsAddressingAction=http://bar.com")
----

Optionally you can override the endpoint options with header values:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
template.requestBodyAndHeader("direct:example",
"<foobar xmlns=\"http://foo.com\"><msg>test message</msg></foobar>",
SpringWebserviceConstants.SPRING_WS_SOAP_ACTION, "http://baz.com");
----

[[BookComponentAppendix-UsingSOAPheaders]]
Using SOAP headers
^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.11.1*

You can provide the SOAP header(s) as a Camel Message header when
sending a message to a spring-ws endpoint, for example given the
following SOAP header in a String

[source,brush:,java;,gutter:,false;,theme:,Default]
----
String body = ...
String soapHeader = "<h:Header xmlns:h=\"http://www.webserviceX.NET/\"><h:MessageID>1234567890</h:MessageID><h:Nested><h:NestedID>1111</h:NestedID></h:Nested></h:Header>";
----

We can set the body and header on the Camel Message as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
exchange.getIn().setBody(body);
exchange.getIn().setHeader(SpringWebserviceConstants.SPRING_WS_SOAP_HEADER, soapHeader);
----

And then send the Exchange to a `spring-ws` endpoint to call the Web
Service.

Likewise the spring-ws consumer will also enrich the Camel Message with
the SOAP header.

For an example see this
https://svn.apache.org/repos/asf/camel/trunk/components/camel-spring-ws/src/test/java/org/apache/camel/component/spring/ws/SoapHeaderTest.java[unit
test].

[[BookComponentAppendix-Theheaderandattachmentpropagation]]
The header and attachment propagation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Spring WS Camel supports propagation of the headers and attachments into
Spring-WS WebServiceMessage response since version *2.10.3*. The
endpoint will use so called "hook" the MessageFilter (default
implementation is provided by BasicMessageFilter) to propagate the
exchange headers and attachments into WebServiceMessage response. Now
you can use

[source,brush:,java;,gutter:,false;,theme:,Default]
----
exchange.getOut().getHeaders().put("myCustom","myHeaderValue")
exchange.getIn().addAttachment("myAttachment", new DataHandler(...))
----

Note: If the exchange header in the pipeline contains text, it generates
Qname(key)=value attribute in the soap header. Recommended is to create
a QName class directly and put into any key into header.

[[BookComponentAppendix-HowtouseMTOMattachments]]
How to use MTOM attachments
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The BasicMessageFilter provides all required information for Apache
Axiom in order to produce MTOM message. If you want to use Apache Camel
Spring WS within Apache Axiom, here is an example: +
1. Simply define the messageFactory as is bellow and Spring-WS will use
MTOM strategy to populate your SOAP message with optimized attachments.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="axiomMessageFactory"
class="org.springframework.ws.soap.axiom.AxiomSoapMessageFactory">
<property name="payloadCaching" value="false" />
<property name="attachmentCaching" value="true" />
<property name="attachmentCacheThreshold" value="1024" />
</bean>
----

\2. Add into your pom.xml the following dependencies

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
<groupId>org.apache.ws.commons.axiom</groupId>
<artifactId>axiom-api</artifactId>
<version>1.2.13</version>
</dependency>
<dependency>
<groupId>org.apache.ws.commons.axiom</groupId>
<artifactId>axiom-impl</artifactId>
<version>1.2.13</version>
<scope>runtime</scope>
</dependency>
----

\3. Add your attachment into the pipeline, for example using a Processor
implementation.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
private class Attachement implements Processor {
public void process(Exchange exchange) throws Exception
{ exchange.getOut().copyFrom(exchange.getIn()); File file = new File("testAttachment.txt"); exchange.getOut().addAttachment("test", new DataHandler(new FileDataSource(file)));  }
}
----

\4. Define endpoint (producer) as ussual, for example like this:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:send")
.process(new Attachement())
.to("spring-ws:http://localhost:8089/mySoapService?soapAction=mySoap&messageFactory=axiomMessageFactory");
----

\5. Now, your producer will generate MTOM message with otpmized
attachments.

[[BookComponentAppendix-Thecustomheaderandattachmentfiltering]]
The custom header and attachment filtering
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you need to provide your custom processing of either headers or
attachments, extend existing BasicMessageFilter and override the
appropriate methods or write a brand new implementation of the
MessageFilter interface. +
To use your custom filter, add this into your spring context:

You can specify either a global a or a local message filter as
follows: +
a) the global custom filter that provides the global configuration for
all Spring-WS endpoints

[source,brush:,java;,gutter:,false;,theme:,Default]
----
 
<bean id="messageFilter" class="your.domain.myMessageFiler" scope="singleton" />
----

or +
b) the local messageFilter directly on the endpoint as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
to("spring-ws:http://yourdomain.com?messageFilter=#myEndpointSpecificMessageFilter");
----

For more information see
https://issues.apache.org/jira/browse/CAMEL-5724[CAMEL-5724]

If you want to create your own MessageFilter, consider overriding the
following methods in the default implementation of MessageFilter in
class BasicMessageFilter:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
protected void doProcessSoapHeader(Message inOrOut, SoapMessage soapMessage)
{your code /*no need to call super*/ }

protected void doProcessSoapAttachements(Message inOrOut, SoapMessage response)
{ your code /*no need to call super*/ }
----

[[BookComponentAppendix-UsingacustomMessageSenderandMessageFactory]]
Using a custom MessageSender and MessageFactory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A custom message sender or factory in the registry can be referenced
like this:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:example")
.to("spring-ws:http://foo.com/bar?messageFactory=#messageFactory&messageSender=#messageSender")
----

Spring configuration:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<!-- authenticate using HTTP Basic Authentication -->
<bean id="messageSender" class="org.springframework.ws.transport.http.HttpComponentsMessageSender">
    <property name="credentials">
        <bean class="org.apache.commons.httpclient.UsernamePasswordCredentials">
            <constructor-arg index="0" value="admin"/>
            <constructor-arg index="1" value="secret"/>
        </bean>
    </property>
</bean>

<!-- force use of Sun SAAJ implementation, http://static.springsource.org/spring-ws/sites/1.5/faq.html#saaj-jboss -->
<bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory">
    <property name="messageFactory">
        <bean class="com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl"></bean>
    </property>
</bean>
----

[[BookComponentAppendix-Exposingwebservices]]
Exposing web services
~~~~~~~~~~~~~~~~~~~~~

In order to expose a web service using this component you first need to
set-up a
http://static.springsource.org/spring-ws/sites/1.5/reference/html/server.html[MessageDispatcher]
to look for endpoint mappings in a Spring XML file. If you plan on
running inside a servlet container you probably want to use a
`MessageDispatcherServlet` configured in `web.xml`.

By default the `MessageDispatcherServlet` will look for a Spring XML
named `/WEB-INF/spring-ws-servlet.xml`. To use Camel with Spring-WS the
only mandatory bean in that XML file is `CamelEndpointMapping`. This
bean allows the `MessageDispatcher` to dispatch web service requests to
your routes.

_web.xml_

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<web-app>
    <servlet>
        <servlet-name>spring-ws</servlet-name>
        <servlet-class>org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring-ws</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
</web-app>
----

_spring-ws-servlet.xml_

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<bean id="endpointMapping" class="org.apache.camel.component.spring.ws.bean.CamelEndpointMapping" />

<bean id="wsdl" class="org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition">
    <property name="schema">
        <bean class="org.springframework.xml.xsd.SimpleXsdSchema">
            <property name="xsd" value="/WEB-INF/foobar.xsd"/>
        </bean>
    </property>
    <property name="portTypeName" value="FooBar"/>
    <property name="locationUri" value="/"/>
    <property name="targetNamespace" value="http://example.com/"/>
</bean>
----

More information on setting up Spring-WS can be found in
http://static.springsource.org/spring-ws/sites/1.5/reference/html/tutorial.html[Writing
Contract-First Web Services]. Basically paragraph 3.6 "Implementing the
Endpoint" is handled by this component (specifically paragraph 3.6.2
"Routing the Message to the Endpoint" is where `CamelEndpointMapping`
comes in). Also don't forget to check out the
link:spring-ws-example.html[Spring Web Services Example] included in the
Camel distribution.

[[BookComponentAppendix-Endpointmappinginroutes]]
Endpoint mapping in routes
^^^^^^^^^^^^^^^^^^^^^^^^^^

With the XML configuration in-place you can now use Camel's DSL to
define what web service requests are handled by your endpoint:

The following route will receive all web service requests that have a
root element named "GetFoo" within the `http://example.com/` namespace.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("spring-ws:rootqname:{http://example.com/}GetFoo?endpointMapping=#endpointMapping")
.convertBodyTo(String.class).to(mock:example)
----

The following route will receive web service requests containing the
`http://example.com/GetFoo` SOAP action.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("spring-ws:soapaction:http://example.com/GetFoo?endpointMapping=#endpointMapping")
.convertBodyTo(String.class).to(mock:example)
----

The following route will receive all requests sent to
`http://example.com/foobar`.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("spring-ws:uri:http://example.com/foobar?endpointMapping=#endpointMapping")
.convertBodyTo(String.class).to(mock:example)
----

The route below will receive requests that contain the element
`<foobar>abc</foobar>` anywhere inside the message (and the default
namespace).

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("spring-ws:xpathresult:abc?expression=//foobar&endpointMapping=#endpointMapping")
.convertBodyTo(String.class).to(mock:example)
----

[[BookComponentAppendix-Alternativeconfiguration,usingexistingendpointmappings]]
Alternative configuration, using existing endpoint mappings
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For every endpoint with mapping-type `beanname` one bean of type
`CamelEndpointDispatcher` with a corresponding name is required in the
Registry/ApplicationContext. This bean acts as a bridge between the
Camel endpoint and an existing
http://static.springsource.org/spring-ws/sites/1.5/reference/html/server.html#server-endpoint-mapping[endpoint
mapping] like `PayloadRootQNameEndpointMapping`.

[Note]
====


The use of the `beanname` mapping-type is primarily meant for (legacy)
situations where you're already using Spring-WS and have endpoint
mappings defined in a Spring XML file. The `beanname` mapping-type
allows you to wire your Camel route into an existing endpoint mapping.
When you're starting from scratch it's recommended to define your
endpoint mappings as Camel URI's (as illustrated above with
`endpointMapping`) since it requires less configuration and is more
expressive. Alternatively you could use vanilla Spring-WS with the help
of annotations.

====

An example of a route using `beanname`:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
    <route>
        <from uri="spring-ws:beanname:QuoteEndpointDispatcher" />
        <to uri="mock:example" />
    </route>
</camelContext>

<bean id="legacyEndpointMapping" class="org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping">
    <property name="mappings">
        <props>
            <prop key="{http://example.com/}GetFuture">FutureEndpointDispatcher</prop>
            <prop key="{http://example.com/}GetQuote">QuoteEndpointDispatcher</prop>
        </props>
    </property>
</bean>

<bean id="QuoteEndpointDispatcher" class="org.apache.camel.component.spring.ws.bean.CamelEndpointDispatcher" />
<bean id="FutureEndpointDispatcher" class="org.apache.camel.component.spring.ws.bean.CamelEndpointDispatcher" />
----

[[BookComponentAppendix-POJO(un)marshalling]]
POJO (un)marshalling
~~~~~~~~~~~~~~~~~~~~

Camel's link:data-format.html[pluggable data formats] offer support for
pojo/xml marshalling using libraries such as JAXB, XStream, JibX, Castor
and XMLBeans. You can use these data formats in your route to sent and
receive pojo's, to and from web services.

When _accessing_ web services you can marshal the request and unmarshal
the response message:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
JaxbDataFormat jaxb = new JaxbDataFormat(false);
jaxb.setContextPath("com.example.model");

from("direct:example").marshal(jaxb).to("spring-ws:http://foo.com/bar").unmarshal(jaxb);
----

Similarly when _providing_ web services, you can unmarshal XML requests
to POJO's and marshal the response message back to XML:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("spring-ws:rootqname:{http://example.com/}GetFoo?endpointMapping=#endpointMapping").unmarshal(jaxb)
.to("mock:example").marshal(jaxb);
----

[[BookComponentAppendix-SeeAlso.33]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-StreamComponent]]
Stream Component
~~~~~~~~~~~~~~~~

The *stream:* component provides access to the `System.in`, `System.out`
and `System.err` streams as well as allowing streaming of file and URL.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-stream</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.63]]
URI format
^^^^^^^^^^

stream:in[?options] stream:out[?options] stream:err[?options]
stream:header[?options]

In addition, the `file` and `url` endpoint URIs are supported:

stream:file?fileName=/foo/bar.txt stream:url[?options]

If the `stream:header` URI is specified, the `stream` header is used to
find the stream to write to. This option is available only for stream
producers (that is, it cannot appear in `from()`).

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.51]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`delay` |`0` |Initial delay in milliseconds before consuming or
producing the stream.

|`encoding` |_JVM Default_ |You can configure the encoding (is a
http://java.sun.com/j2se/1.5.0/docs/api/java/nio/charset/Charset.html[charset
name]) to use text-based streams (for example, message body is a
`String` object). If not provided, Camel uses the
http://java.sun.com/j2se/1.5.0/docs/api/java/nio/charset/Charset.html#defaultCharset()[JVM
default Charset].

|`promptMessage` |`null` |Message prompt to use when reading from
`stream:in`; for example, you could set this to `Enter a command:`

|`promptDelay` |`0` |Optional delay in milliseconds before showing the
message prompt.

|`initialPromptDelay` |`2000` |Initial delay in milliseconds before
showing the message prompt. This delay occurs only once. Can be used
during system startup to avoid message prompts being written while other
logging is done to the system out.

|`fileName` |`null` |When using the `stream:file` URI format, this
option specifies the filename to stream to/from.

|`url` |`null` |When using the `stream:url` URI format, this option
specifies the URL to stream to/from. The input/output stream will be
opened using the
http://docs.oracle.com/javase/6/docs/api/java/net/URLConnection.html[JDK
URLConnection] facility.

|`scanStream` |`false` |To be used for continuously reading a stream
such as the unix `tail` command. +
*Camel 2.4 to Camel 2.6:* will retry opening the file if it is
overwritten, somewhat like `tail --retry`

|`retry` |`false` |*Camel 2.7:* will retry opening the file if it's
overwritten, somewhat like `tail --retry`

|`scanStreamDelay` |`0` |Delay in milliseconds between read attempts
when using `scanStream`.

|`groupLines` |`0` |*Camel 2.5:* To group X number of lines in the
consumer. For example to group 10 lines and therefore only spit out an
link:exchange.html[Exchange] with 10 lines, instead of 1
link:exchange.html[Exchange] per line.

|`autoCloseCount` |`0` |*Camel 2.10.0:* (2.9.3 and 2.8.6) Number of
messages to process before closing stream on Producer side. Never close
stream by default (only when Producer is stopped). If more messages are
sent, the stream is reopened for another `autoCloseCount` batch.

|`closeOnDone` |`false` |*Camel 2.11.0:* This option is used in
combination with link:splitter.html[Splitter] and streaming to the same
file. The idea is to keep the stream open and only close when the
link:splitter.html[Splitter] is done, to improve performance. Mind this
requires that you only stream to the same file, and not 2 or more files,
and that the last split message that carries the information that its
the last, is routed to the stream endpoint so it gets the signal to
close.
|=======================================================================

[[BookComponentAppendix-Messagecontent]]
Message content
^^^^^^^^^^^^^^^

The *stream:* component supports either `String` or `byte[]` for writing
to streams. Just add either `String` or `byte[]` content to the
`message.in.body`. Messages sent to the *stream:* producer in binary
mode are not followed by the newline character (as opposed to the
`String` messages). Message with `null` body will not be appended to the
output stream. +
The special `stream:header` URI is used for custom output streams. Just
add a `java.io.OutputStream` object to `message.in.header` in the key
`header`. +
See samples for an example.

[[BookComponentAppendix-Samples.12]]
Samples
^^^^^^^

In the following sample we route messages from the `direct:in` endpoint
to the `System.out` stream:

java// Route messages to the standard output.
from("direct:in").to("stream:out"); // Send String payload to the
standard output. // Message will be followed by the newline.
template.sendBody("direct:in", "Hello Text World"); // Send byte[]
payload to the standard output. // No newline will be added after the
message. template.sendBody("direct:in", "Hello Bytes World".getBytes());

The following sample demonstrates how the header type can be used to
determine which stream to use. In the sample we use our own output
stream,
`MyOutputStream`.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-stream/src/test/java/org/apache/camel/component/stream/StreamHeaderTest.java}The
following sample demonstrates how to continuously read a file stream
(analogous to the UNIX `tail` command):

javafrom("stream:file?fileName=/server/logs/server.log&scanStream=true&scanStreamDelay=1000").to("bean:logService?method=parseLogLine");

One gotcha with scanStream (pre Camel 2.7) or scanStream + retry is the
file will be re-opened and scanned with each iteration of
scanStreamDelay. Until NIO2 is available we cannot reliably detect when
a file is deleted/recreated.

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-StringTemplate]]
String Template
~~~~~~~~~~~~~~~

The *`string-template:`* component allows you to process a message using
a http://www.stringtemplate.org/[String Template]. This can be ideal
when using link:templating.html[Templating] to generate responses for
requests.

Maven users will need to add the following dependency to their
*`pom.xml`* for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-stringtemplate</artifactId> <version>x.x.x</version>
<!-- use the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIFormat.6]]
URI Format
^^^^^^^^^^

string-template:templateName[?options]

Where *`templateName`* is the classpath-local URI of the template to
invoke; or the complete URL of the remote template.

You can append query options to the URI in the following format,
*`?option=value&option=value&...`*

[[BookComponentAppendix-Options.52]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`contentCache` |`false` |Cache for the resource content when its
loaded. +
*Note*: as of *Camel 2.9* cached resource content can be cleared via JMX
using the endpoint's *`clearContentCache`* operation.

|`delimiterStart` |`null` |From *Camel 2.11.1*: configuring the variable
start delimiter

|`delimiterStop` |`null` |From *Camel 2.11.1*: configuring the variable
end delimiter
|=======================================================================

[[BookComponentAppendix-Headers.5]]
Headers
^^^^^^^

Camel will store a reference to the resource in the message header with
key, *`org.apache.camel.stringtemplate.resource`*. The Resource is an
*`org.springframework.core.io.Resource`* object.

[[BookComponentAppendix-Hot-Reloading]]
Hot-Reloading
^^^^^^^^^^^^^

The string template resource is by default hot-reloadable for both file
and classpath resources (expanded jar). If you set
*`contentCache=true`*, Camel will load the resource just once, disabling
hot-reloading. This scenario can be used in production when the resource
never changes.

[[BookComponentAppendix-StringTemplateAttributes]]
StringTemplate Attributes
^^^^^^^^^^^^^^^^^^^^^^^^^

Camel will provide exchange information as attributes (just a
*`java.util.Map`*) to the string template. The Exchange is transferred
as:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Key |Value
|`exchange` |The Exchange itself.

|`headers` |The headers of the *`IN`* message.

|`camelContext` |The Camel Context.

|`request` |The *`IN`* message.

|`in` |The *`IN`* message.

|`body` |The *`IN`* message body.

|`out` |The *`OUT`* message (only for *`InOut`* message exchange
pattern).

|`response` |The *`OUT`* message (only for *`InOut`* message exchange
pattern).
|=======================================================================

From *Camel 2.14*: you can define the custom context map by setting the
message header *`CamelStringTemplateVariableMap`*, as shown below:

javaMap<String, Object> variableMap = new HashMap<String, Object>();
Map<String, Object> headersMap = new HashMap<String, Object>();
headersMap.put("name", "Willem"); variableMap.put("headers",
headersMap); variableMap.put("body", "Monday");
variableMap.put("exchange", exchange);
exchange.getIn().setHeader("CamelStringTemplateVariableMap",
variableMap);

[[BookComponentAppendix-Samples.13]]
Samples
^^^^^^^

For example you could use a string template as follows in order to
formulate a response to a message:

from("activemq:My.Queue") .to("string-template:com/acme/MyResponse.tm");

[[BookComponentAppendix-TheEmailSample.1]]
The Email Sample
^^^^^^^^^^^^^^^^

In this sample we want to use a string template to send an order
confirmation email. The email template is laid out in *`StringTemplate`*
as: +
This example works for *camel 2.11.0*. If your camel version is less
than *2.11.0*, the variables should be started and ended with *`$`*.

Dear <headers.lastName>, <headers.firstName> Thanks for the order of
<headers.item>. Regards Camel Riders Bookstore <body>

And the java code is as
follows:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-stringtemplate/src/test/java/org/apache/camel/component/stringtemplate/StringTemplateLetterTest.java}link:endpoint-see-also.html[Endpoint
See Also]

[[BookComponentAppendix-SQLComponent]]
SQL Component
~~~~~~~~~~~~~

The *sql:* component allows you to work with databases using JDBC
queries. The difference between this component and link:jdbc.html[JDBC]
component is that in case of SQL the query is a property of the endpoint
and it uses message payload as parameters passed to the query.

This component uses `spring-jdbc` behind the scenes for the actual SQL
handling.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-sql</artifactId> <version>x.x.x</version> <!-- use the
same version as your Camel core version --> </dependency>

The SQL component also supports:

* a JDBC based repository for the
link:idempotent-consumer.html[Idempotent Consumer] EIP pattern. See
further below.
* a JDBC based repository for the link:aggregator2.html[Aggregator] EIP
pattern. See further below.

[[BookComponentAppendix-URIformat.64]]
URI format
^^^^^^^^^^

From Camel 2.11 onwards this component can create both consumer (e.g.
`from()`) and producer endpoints (e.g. `to()`).

In previous versions, it could only act as a producer.

This component can be used as a
http://camel.apache.org/transactional-client.html[Transactional Client].

The SQL component uses the following endpoint URI notation:

sql:select * from table where id=# order by name[?options]

From Camel 2.11 onwards you can use named parameters by using
:`#name_of_the_parameter` style as shown:

sql:select * from table where id=:#myId order by name[?options]

When using named parameters, Camel will lookup the names from, in the
given precedence: +
1. from message body if its a `java.util.Map` +
2. from message headers

If a named parameter cannot be resolved, then an exception is thrown.

From *Camel 2.14* onward you can use Simple expressions as parameters as
shown:

sql:select * from table where id=:#$\{property.myId} order by
name[?options]

Notice that the standard `?` symbol that denotes the parameters to an
SQL query is substituted with the `#` symbol, because the `?` symbol is
used to specify options for the endpoint. The `?` symbol replacement can
be configured on endpoint basis.

From *Camel 2.17* onwards you can externalize your SQL queries to files
in the classpath or file system as shown:

sql:classpath:sql/myquery.sql[?options]

And the myquery.sql file is in the classpath and is just a plain text

-- this is a comment select * from table where id = :#$\{property.myId}
order by name

In the file you can use multilines and format the SQL as you wish. And
also use comments such as the – dash line.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.53]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Option |Type |Default |Description
|`batch` |`boolean` |`false` |*Camel 2.7.5, 2.8.4 and 2.9:* Execute SQL
batch update statements. See notes below on how the treatment of the
inbound message body changes if this is set to `true`.

|`dataSourceRef` |`String` |`null` |*Deprecated and will be removed in
Camel 3.0:* Reference to a `DataSource` to look up in the registry. Use
`dataSource=#theName` instead.

|`dataSource` |`String` |`null` |*Camel 2.11:* Reference to a
`DataSource` to look up in the registry.

|`placeholder` |`String` |`#` |*Camel 2.4:* Specifies a character that
will be replaced to `?` in SQL query. Notice, that it is simple
`String.replaceAll()` operation and no SQL parsing is involved (quoted
strings will also change). This replacement is *only* happening if the
endpoint is created using the `SqlComponent`. If you manually create the
endpoint, then use the expected `?` sign instead.

|`usePlaceholder` |`boolean` |`true` |*Camel 2.17:* Sets whether to use
placeholder and replace all placeholder characters with ? sign in the
SQL queries.

|`template.<xxx>` |  |`null` |Sets additional options on the Spring
`JdbcTemplate` that is used behind the scenes to execute the queries.
For instance, `template.maxRows=10`. For detailed documentation, see the
http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jdbc/core/JdbcTemplate.html[JdbcTemplate
javadoc] documentation.

|`allowNamedParameters` |`boolean` |`true` |*Camel 2.11:* Whether to
allow using named parameters in the queries.

|`processingStrategy` |  |  |*Camel 2.11:* *SQL consumer only:* Allows
to plugin to use a custom
`org.apache.camel.component.sql.SqlProcessingStrategy` to execute
queries when the consumer has processed the rows/batch.

|`prepareStatementStrategy` |  |  |*Camel 2.11:* Allows to plugin to use
a custom `org.apache.camel.component.sql.SqlPrepareStatementStrategy` to
control preparation of the query and prepared statement.

|`consumer.delay` |`long` |`500` |*Camel 2.11:* *SQL consumer only:*
Delay in milliseconds between each poll.

|`consumer.initialDelay` |`long` |`1000` |*Camel 2.11:* *SQL consumer
only:* Milliseconds before polling starts.

|`consumer.useFixedDelay` |`boolean` |`false` |*Camel 2.11:* *SQL
consumer only:* Set to `true` to use fixed delay between polls,
otherwise fixed rate is used. See
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html[ScheduledExecutorService]
in JDK for details.

|`maxMessagesPerPoll` |`int` |`0` |*Camel 2.11:* *SQL consumer only:* An
integer value to define the maximum number of messages to gather per
poll. By default, no maximum is set.

|`useIterator` |`boolean` |`true` |*Camel 2.11:* *SQL consumer only:* If
`true` each row returned when polling will be processed individually. If
`false` the entire `java.util.List` of data is set as the IN body.
Notice in Camel 2.15.x or older you need to prefix this option with
consumer., eg consumer.useIterator=true.

|`routeEmptyResultSet` |`boolean` |`false` |*Camel 2.11:* *SQL consumer
only:* Whether to route a single empty link:exchange.html[Exchange] if
there was no data to poll. Notice in Camel 2.15.x or older you need to
prefix this option with consumer., eg consumer.useIterator=true.

|`onConsume` |`String` |`null` |*Camel 2.11:* *SQL consumer only:* After
processing each row then this query can be executed, if the
link:exchange.html[Exchange] was processed successfully, for example to
mark the row as processed. The query can have parameter. Notice in Camel
2.15.x or older you need to prefix this option with consumer., eg
consumer.useIterator=true.

|`onConsumeFailed` |`String` |`null` |*Camel 2.11:* *SQL consumer only:*
After processing each row then this query can be executed, if the
link:exchange.html[Exchange] failed, for example to mark the row as
failed. The query can have parameter. Notice in Camel 2.15.x or older
you need to prefix this option with consumer., eg
consumer.useIterator=true.

|`onConsumeBatchComplete` |`String` |`null` |*Camel 2.11:* *SQL consumer
only:* After processing the entire batch, this query can be executed to
bulk update rows etc. The query cannot have parameters. Notice in Camel
2.15.x or older you need to prefix this option with consumer., eg
consumer.useIterator=true.

|`expectedUpdateCount` |`int` |`-1` |*Camel 2.11:* *SQL consumer only:*
If using `consumer.onConsume` then this option can be used to set an
expected number of rows being updated. Typically you may set this to `1`
to expect one row to be updated. Notice in Camel 2.15.x or older you
need to prefix this option with consumer., eg consumer.useIterator=true.

|`breakBatchOnConsumeFail` |`boolean` |`false` |*Camel 2.11:* *SQL
consumer only:* If using `consumer.onConsume` and it fails, then this
option controls whether to break out of the batch or continue processing
the next row from the batch. Notice in Camel 2.15.x or older you need to
prefix this option with consumer., eg consumer.useIterator=true.

|`alwaysPopulateStatement` |`boolean` |`false` |*Camel 2.11:* *SQL
producer only:* If enabled then the `populateStatement` method from
`org.apache.camel.component.sql.SqlPrepareStatementStrategy` is always
invoked, also if there is no expected parameters to be prepared. When
this is `false` then the `populateStatement` is only invoked if there is
1 or more expected parameters to be set; for example this avoids reading
the message body/headers for SQL queries with no parameters.

|`separator` |`char` |`,` |*Camel 2.11.1:* The separator to use when
parameter values is taken from message body (if the body is a String
type), to be inserted at # placeholders. Notice if you use named
parameters, then a `Map` type is used instead.

|`outputType` |`String` |`SelectList` a|
*Camel 2.12.0:* outputType='SelectList', for consumer or producer, will
output a List of Map. `SelectOne` will output single Java object in the
following way: +
a) If the query has only single column, then that JDBC Column object is
returned. (such as `SELECT COUNT( * ) FROM PROJECT` will return a Long
object. +
b) If the query has more than one column, then it will return a Map of
that result. +
c) If the `outputClass` is set, then it will convert the query result
into an Java bean object by calling all the setters that match the
column names. It will assume your class has a default constructor to
create instance with. +
d) If the query resulted in more than one rows, it throws an non-unique
result exception.

From *Camel 2.14.1* onwards the SelectList also supports mapping each
row to a Java object as the SelectOne does (only step c).

From *Camel 2.18* onwards there is a new StreamList outputType that
streams the result of the query using an Iterator. It can be used with
the link:splitter.html[Splitter] EIP in streaming mode to process the
ResultSet in streaming fashion. This StreamList do not support batch
mode, but you can use outputClass to map each row to a class.

|`outputClass` |`String` |`null` |*Camel 2.12.0:* Specify the full
package and class name to use as conversion when `outputType=SelectOne`.

|`outputHeader` |`String` |`null` |*Camel 2.15:* To store the result as
a header instead of the message body. This allows to preserve the
existing message body as-is.

|`parametersCount` |`int` |`0` |*Camel 2.11.2/2.12.0* If set greater
than zero, then Camel will use this count value of parameters to replace
instead of querying via JDBC metadata API. This is useful if the JDBC
vendor could not return correct parameters count, then user may override
instead.

|`noop` |`boolean` |`false` |*Camel 2.12.0* If set, will ignore the
results of the SQL query and use the existing IN message as the OUT
message for the continuation of processing

|`useMessageBodyForSql` |`boolean` |`false` |*Camel 2.16:* Whether to
use the message body as the SQL and then headers for parameters. If this
option is enabled then the SQL in the uri is not used. The SQL
parameters must then be provided in a header with the key
`CamelSqlParameters`. This option is only for the producer.

|`transacted` |`boolean` |`false` |*Camel 2.16.2:* **SQL consumer
only:**Enables or disables transaction. If enabled then if processing an
exchange failed then the consumer break out processing any further
exchanges to cause a rollback eager
|=======================================================================

[[BookComponentAppendix-Treatmentofthemessagebody]]
Treatment of the message body
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The SQL component tries to convert the message body to an object of
`java.util.Iterator` type and then uses this iterator to fill the query
parameters (where each query parameter is represented by a `#` symbol
(or configured placeholder) in the endpoint URI). If the message body is
not an array or collection, the conversion results in an iterator that
iterates over only one object, which is the body itself.

For example, if the message body is an instance of `java.util.List`, the
first item in the list is substituted into the first occurrence of `#`
in the SQL query, the second item in the list is substituted into the
second occurrence of `#`, and so on.

If `batch` is set to `true`, then the interpretation of the inbound
message body changes slightly – instead of an iterator of parameters,
the component expects an iterator that contains the parameter iterators;
the size of the outer iterator determines the batch size.

From Camel 2.16 onwards you can use the option useMessageBodyForSql that
allows to use the message body as the SQL statement, and then the SQL
parameters must be provided in a header with the
key SqlConstants.SQL_PARAMETERS. This allows the SQL component to work
more dynamic as the SQL query is from the message body.

[[BookComponentAppendix-Resultofthequery]]
Result of the query
^^^^^^^^^^^^^^^^^^^

For `select` operations, the result is an instance of
`List<Map<String, Object>>` type, as returned by the
http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jdbc/core/JdbcTemplate.html#queryForList(java.lang.String,%20java.lang.Object%91%93)[JdbcTemplate.queryForList()]
method. For `update` operations, the result is the number of updated
rows, returned as an `Integer`.

By default, the result is placed in the message body.  If the
outputHeader parameter is set, the result is placed in the header.  This
is an alternative to using a full message enrichment pattern to add
headers, it provides a concise syntax for querying a sequence or some
other small value into a header.  It is convenient to use outputHeader
and outputType together:

javafrom("jms:order.inbox") .to("sql:select order_seq.nextval from
dual?outputHeader=OrderId&outputType=SelectOne")
.to("jms:order.booking");

[[BookComponentAppendix-UsingStreamList]]
Using StreamList
^^^^^^^^^^^^^^^^

From *Camel 2.18* onwards the producer supports outputType=StreamList
that uses an iterator to stream the output of the query. This allows to
process the data in a streaming fashion which for example can be used by
the link:splitter.html[Splitter] EIP to process each row one at a time,
and load data from the database as needed.

javafrom("direct:withSplitModel") .to("sql:select * from projects order
by
id?outputType=StreamList&outputClass=org.apache.camel.component.sql.ProjectModel")
.to("log:stream") .split(body()).streaming() .to("log:row")
.to("mock:result") .end();

 

[[BookComponentAppendix-Headervalues]]
Header values
^^^^^^^^^^^^^

When performing `update` operations, the SQL Component stores the update
count in the following message headers:

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelSqlUpdateCount` |The number of rows updated for `update`
operations, returned as an `Integer` object. This header is not provided
when using outputType=StreamList.

|`CamelSqlRowCount` |The number of rows returned for `select`
operations, returned as an `Integer` object. This header is not provided
when using outputType=StreamList.

|`CamelSqlQuery` |*Camel 2.8:* Query to execute. This query takes
precedence over the query specified in the endpoint URI. Note that query
parameters in the header _are_ represented by a `?` instead of a `#`
symbol
|=======================================================================

When performing `insert` operations, the SQL Component stores the rows
with the generated keys and number of these rown in the following
message headers (*Available as of Camel 2.12.4, 2.13.1*):

[width="100%",cols="50%,50%",options="header",]
|=================================================================
|Header |Description
a|
....
CamelSqlGeneratedKeysRowCount
....

 |The number of rows in the header that contains generated keys.
a|
....
CamelSqlGeneratedKeyRows
....

 | Rows that contains the generated keys (a list of maps of keys).
|=================================================================

[[BookComponentAppendix-Generatedkeys.1]]
Generated keys
^^^^^^^^^^^^^^

*Available as of Camel 2.12.4, 2.13.1 and 2.14 +
*

If you insert data using SQL INSERT, then the RDBMS may support auto
generated keys. You can instruct the SQL producer to return the
generated keys in headers. +
To do that set the header `CamelSqlRetrieveGeneratedKeys=true`. Then the
generated keys will be provided as headers with the keys listed in the
table above.

You can see more details in this
https://git-wip-us.apache.org/repos/asf?p=camel.git;a=blob_plain;f=components/camel-sql/src/test/java/org/apache/camel/component/sql/SqlGeneratedKeysTest.java;hb=3962b23f94bb4bc23011b931add08c3f6833c82e[unit
test].

[[BookComponentAppendix-Configuration.1]]
Configuration
^^^^^^^^^^^^^

You can now set a reference to a `DataSource` in the URI directly:

sql:select * from table where id=# order by name?dataSource=myDS

[[BookComponentAppendix-Sample.4]]
Sample
^^^^^^

In the sample below we execute a query and retrieve the result as a
`List` of rows, where each row is a `Map<String, Object` and the key is
the column name.

First, we set up a table to use for our sample. As this is based on an
unit test, we do it in
java:\{snippet:id=e2|lang=java|url=camel/trunk/components/camel-sql/src/test/java/org/apache/camel/component/sql/SqlDataSourceRefTest.java}The
SQL script `createAndPopulateDatabase.sql` we execute looks like as
described
below:\{snippet:id=e1|lang=sql|url=camel/trunk/components/camel-sql/src/test/resources/sql/createAndPopulateDatabase.sql}Then
we configure our route and our `sql` component. Notice that we use a
`direct` endpoint in front of the `sql` endpoint. This allows us to send
an exchange to the `direct` endpoint with the URI, `direct:simple`,
which is much easier for the client to use than the long `sql:` URI.
Note that the `DataSource` is looked up up in the registry, so we can
use standard Spring XML to configure our
`DataSource`.\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-sql/src/test/java/org/apache/camel/component/sql/SqlDataSourceRefTest.java}And
then we fire the message into the `direct` endpoint that will route it
to our `sql` component that queries the
database.\{snippet:id=e3|lang=java|url=camel/trunk/components/camel-sql/src/test/java/org/apache/camel/component/sql/SqlDataSourceRefTest.java}We
could configure the `DataSource` in Spring XML as follows:

xml <jee:jndi-lookup id="myDS" jndi-name="jdbc/myDataSource"/>

[[BookComponentAppendix-Usingnamedparameters.1]]
Using named parameters
++++++++++++++++++++++

*Available as of Camel 2.11*

In the given route below, we want to get all the projects from the
projects table. Notice the SQL query has 2 named parameters, :#lic and
:#min. +
Camel will then lookup for these parameters from the message body or
message headers. Notice in the example above we set two headers with
constant value +
for the named parameters:

java from("direct:projects") .setHeader("lic", constant("ASF"))
.setHeader("min", constant(123)) .to("sql:select * from projects where
license = :#lic and id > :#min order by id")

Though if the message body is a `java.util.Map` then the named
parameters will be taken from the body.

java from("direct:projects") .to("sql:select * from projects where
license = :#lic and id > :#min order by id")

[[BookComponentAppendix-Usingexpressionparameters]]
Using expression parameters
+++++++++++++++++++++++++++

*Available as of Camel 2.14*

In the given route below, we want to get all the project from the
database. It uses the body of the exchange for defining the license and
uses the value of a property as the second parameter.

javafrom("direct:projects") .setBody(constant("ASF"))
.setProperty("min", constant(123)) .to("sql:select * from projects where
license = :#$\{body} and id > :#$\{property.min} order by id")

[[BookComponentAppendix-UsingINquerieswithdynamicvalues]]
Using IN queries with dynamic values
++++++++++++++++++++++++++++++++++++

*Available as of Camel 2.17*

From Camel 2.17 onwards the SQL producer allows to use SQL queries with
IN statements where the IN values is dynamic computed. For example from
the message body or a header etc.

To use IN you need to:

* prefix the parameter name with `in:`
* add `( )` around the parameter

An example explains this better. The following query is used:

-- this is a comment select * from projects where project in
(:#in:names) order by id

In the following route:

from("direct:query") .to("sql:classpath:sql/selectProjectsIn.sql")
.to("log:query") .to("mock:query");

Then the IN query can use a header with the key names with the dynamic
values such as:

// use an array template.requestBodyAndHeader("direct:query", "Hi
there!", "names", new String[]\{"Camel", "AMQ"}); // use a list
List<String> names = new ArrayList<String>(); names.add("Camel");
names.add("AMQ"); template.requestBodyAndHeader("direct:query", "Hi
there!", "names", names); // use a string separated values with comma
template.requestBodyAndHeader("direct:query", "Hi there!", "names",
"Camel,AMQ");

The query can also be specified in the endpoint instead of being
externalized (notice that externalizing makes maintaining the SQL
queries easier)

from("direct:query") .to("sql:select * from projects where project in
(:#in:names) order by id") .to("log:query") .to("mock:query");

 

[[BookComponentAppendix-UsingtheJDBCbasedidempotentrepository]]
Using the JDBC based idempotent repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.7*: In this section we will use the JDBC based
idempotent repository.

Abstract class From Camel 2.9 onwards there is an abstract
class `org.apache.camel.processor.idempotent.jdbc.AbstractJdbcMessageIdRepository` you
can extend to build custom JDBC idempotent repository.

First we have to create the database table which will be used by the
idempotent repository. For *Camel 2.7*, we use the following schema:

sqlCREATE TABLE CAMEL_MESSAGEPROCESSED ( processorName VARCHAR(255),
messageId VARCHAR(100) ) 

In *Camel 2.8*, we added the createdAt column:

sqlCREATE TABLE CAMEL_MESSAGEPROCESSED ( processorName VARCHAR(255),
messageId VARCHAR(100), createdAt TIMESTAMP )  The SQL
Server *TIMESTAMP* type is a fixed-length binary-string type. It does
not map to any of the JDBC time types: *DATE*, *TIME*, or *TIMESTAMP*.

 

We recommend to have a unique constraint on the columns processorName
and messageId. Because the syntax for this constraint differs for
database to database, we do not show it here.

Second we need to setup a `javax.sql.DataSource` in the spring XML file:

xml<jdbc:embedded-database id="dataSource" type="DERBY" /> 

 +
And finally we can create our JDBC idempotent repository in the spring
XML file as well:

xml <bean id="messageIdRepository"
class="org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository">
<constructor-arg ref="dataSource" /> <constructor-arg
value="myProcessorName" /> </bean> 

 +
Customize the JdbcMessageIdRepository

Starting with *Camel 2.9.1* you have a few options to tune the
`org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository` for
your needs:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Parameter |Default Value |Description
|createTableIfNotExists |true |Defines whether or not Camel should try
to create the table if it doesn't exist.

|tableExistsString |SELECT 1 FROM CAMEL_MESSAGEPROCESSED WHERE 1 = 0
|This query is used to figure out whether the table already exists or
not. It must throw an exception to indicate the table doesn't exist.

|createString |CREATE TABLE CAMEL_MESSAGEPROCESSED (processorName
VARCHAR(255), messageId VARCHAR(100), createdAt TIMESTAMP) |The
statement which is used to create the table.

|queryString |SELECT COUNT(*) FROM CAMEL_MESSAGEPROCESSED WHERE
processorName = ? AND messageId = ? |The query which is used to figure
out whether the message already exists in the repository (the result is
not equals to '0'). It takes two parameters. This first one is the
processor name (`String`) and the second one is the message id
(`String`).

|insertString |INSERT INTO CAMEL_MESSAGEPROCESSED (processorName,
messageId, createdAt) VALUES (?, ?, ?) |The statement which is used to
add the entry into the table. It takes three parameter. The first one is
the processor name (`String`), the second one is the message id
(`String`) and the third one is the timestamp (`java.sql.Timestamp`)
when this entry was added to the repository.

|deleteString |DELETE FROM CAMEL_MESSAGEPROCESSED WHERE processorName =
? AND messageId = ? |The statement which is used to delete the entry
from the database. It takes two parameter. This first one is the
processor name (`String`) and the second one is the message id
(`String`).
|=======================================================================

 

A customized
`org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository`
could look like:

xml <bean id="messageIdRepository"
class="org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository">
<constructor-arg ref="dataSource" /> <constructor-arg
value="myProcessorName" /> <property name="tableExistsString"
value="SELECT 1 FROM CUSTOMIZED_MESSAGE_REPOSITORY WHERE 1 = 0" />
<property name="createString" value="CREATE TABLE
CUSTOMIZED_MESSAGE_REPOSITORY (processorName VARCHAR(255), messageId
VARCHAR(100), createdAt TIMESTAMP)" /> <property name="queryString"
value="SELECT COUNT(*) FROM CUSTOMIZED_MESSAGE_REPOSITORY WHERE
processorName = ? AND messageId = ?" /> <property name="insertString"
value="INSERT INTO CUSTOMIZED_MESSAGE_REPOSITORY (processorName,
messageId, createdAt) VALUES (?, ?, ?)" /> <property name="deleteString"
value="DELETE FROM CUSTOMIZED_MESSAGE_REPOSITORY WHERE processorName = ?
AND messageId = ?" /> </bean>

 +
Using the JDBC based aggregation repository

*Available as of Camel 2.6*

Using JdbcAggregationRepository in Camel 2.6 In Camel 2.6, the
JdbcAggregationRepository is provided in
the `camel-jdbc-aggregator` component. From Camel 2.7 onwards,
the `JdbcAggregationRepository` is provided in
the `camel-sql` component.

`JdbcAggregationRepository` is an `AggregationRepository` which on the
fly persists the aggregated messages. This ensures that you will not
loose messages, as the default aggregator will use an in memory only
`AggregationRepository`.

The `JdbcAggregationRepository` allows together with Camel to provide
persistent support for the link:aggregator2.html[Aggregator].

It has the following options:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Type |Description
|dataSource |DataSource |*Mandatory:* The `javax.sql.DataSource` to use
for accessing the database.

|repositoryName |String |*Mandatory:* The name of the repository.

|transactionManager |TransactionManager
|*Mandatory:* The `org.springframework.transaction.PlatformTransactionManager` to
mange transactions for the database. The TransactionManager must be able
to support databases.

|lobHandler |LobHandler
|A `org.springframework.jdbc.support.lob.LobHandler` to handle Lob types
in the database. Use this option to use a vendor specific LobHandler,
for example when using Oracle.

|returnOldExchange |boolean |Whether the get operation should return the
old existing Exchange if any existed. By default this option
is `false` to optimize as we do not need the old exchange when
aggregating.

|useRecovery |boolean |Whether or not recovery is enabled. This option
is by default `true`. When enabled the
Camel link:aggregator2.html[Aggregator] automatic recover failed
aggregated exchange and have them resubmitted.

|recoveryInterval |long |If recovery is enabled then a background task
is run every x'th time to scan for failed exchanges to recover and
resubmit. By default this interval is 5000 millis.

|maximumRedeliveries |int |Allows you to limit the maximum number of
redelivery attempts for a recovered exchange. If enabled then the
Exchange will be moved to the dead letter channel if all redelivery
attempts failed. By default this option is disabled. If this option is
used then the `deadLetterUri` option must also be provided.

|`deadLetterUri` |String |An endpoint uri for
a link:dead-letter-channel.html[Dead Letter Channel] where exhausted
recovered Exchanges will be moved. If this option is used then
the `maximumRedeliveries` option must also be provided.

|storeBodyAsText |boolean |*Camel 2.11:* Whether to store the message
body as String which is human readable. By default this option
is `false` storing the body in binary format.

|headersToStoreAsText |List<String> | *Camel 2.11:* Allows to store
headers as String which is human readable. By default this option is
disabled, storing the headers in binary format.

|jdbcOptimisticLockingExceptionMapper
|jdbcOptimisticLockingExceptionMapper |*Camel 2.12:* Allows to plugin a
custom `org.apache.camel.processor.aggregate.jdbc.JdbcOptimisticLockingExceptionMapper` to
map vendor specific error codes to an optimistick locking error, for
Camel to perform a retry. This requires `optimisticLocking` to be
enabled.
|=======================================================================

Optimistic Locking

Optimistic locking is set to on by default.  If two exchanges attempt to
insert at the same time an exception will thrown, caught, converted to
an OptimisticLockingException, and rethrown.  

[[BookComponentAppendix-Whatispreservedwhenpersisting]]
What is preserved when persisting
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`JdbcAggregationRepository` will only preserve any `Serializable`
compatible data types. If a data type is not such a type its dropped and
a `WARN` is logged. And it only persists the `Message` body and the
`Message` headers. The `Exchange` properties are *not* persisted.

From Camel 2.11 onwards you can store the message body and select(ed)
headers as String in separate columns.

Recovery

The `JdbcAggregationRepository` will by default recover any failed
link:exchange.html[Exchange]. It does this by having a background tasks
that scans for failed link:exchange.html[Exchange]s in the persistent
store. You can use the `checkInterval` option to set how often this task
runs. The recovery works as transactional which ensures that Camel will
try to recover and redeliver the failed link:exchange.html[Exchange].
Any link:exchange.html[Exchange] which was found to be recovered will be
restored from the persistent store and resubmitted and send out again.

The following headers is set when an link:exchange.html[Exchange] is
being recovered/redelivered:

 

[cols=",,",options="header",]
|=======================================================================
|Header |Type |Description
|Exchange.REDELIVERED |Boolean |Is set to true to indicate
the link:exchange.html[Exchange] is being redelivered.

|Exchange.REDELIVERY_COUNTER |Integer |The redelivery attempt, starting
from 1.
|=======================================================================

 

Only when an link:exchange.html[Exchange] has been successfully
processed it will be marked as complete which happens when the `confirm`
method is invoked on the `AggregationRepository`. This means if the same
link:exchange.html[Exchange] fails again it will be kept retried until
it success.

You can use option `maximumRedeliveries` to limit the maximum number of
redelivery attempts for a given recovered link:exchange.html[Exchange].
You must also set the `deadLetterUri` option so Camel knows where to
send the link:exchange.html[Exchange] when the `maximumRedeliveries` was
hit.

You can see some examples in the unit tests of camel-sql, for example
https://svn.apache.org/repos/asf/camel/trunk/components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcAggregateRecoverDeadLetterChannelTest.java[this
test].

Database

To be operational, each aggregator uses two table: the aggregation and
completed one. By convention the completed has the same name as the
aggregation one suffixed with `"_COMPLETED"`. The name must be
configured in the Spring bean with the `RepositoryName` property. In the
following example aggregation will be used.

The table structure definition of both table are identical: in both case
a String value is used as key (*id*) whereas a Blob contains the
exchange serialized in byte array. +
However one difference should be remembered: the *id* field does not
have the same content depending on the table. +
In the aggregation table *id* holds the correlation Id used by the
component to aggregate the messages. In the completed table, *id* holds
the id of the exchange stored in corresponding the blob field.

Here is the SQL query used to create the tables, just replace
`"aggregation"` with your aggregator repository name.

sql CREATE TABLE aggregation ( id varchar(255) NOT NULL, exchange blob
NOT NULL, constraint aggregation_pk PRIMARY KEY (id) ); CREATE TABLE
aggregation_completed ( id varchar(255) NOT NULL, exchange blob NOT
NULL, constraint aggregation_completed_pk PRIMARY KEY (id) );

Storing body and headers as text

*Available as of Camel 2.11*

You can configure the `JdbcAggregationRepository` to store message body
and select(ed) headers as String in separate columns. For example to
store the body, and the following two headers `companyName` and
`accountName` use the following SQL:

sqlCREATE TABLE aggregationRepo3 ( id varchar(255) NOT NULL, exchange
blob NOT NULL, body varchar(1000), companyName varchar(1000),
accountName varchar(1000), constraint aggregationRepo3_pk PRIMARY KEY
(id) ); CREATE TABLE aggregationRepo3_completed ( id varchar(255) NOT
NULL, exchange blob NOT NULL, body varchar(1000), companyName
varchar(1000), accountName varchar(1000), constraint
aggregationRepo3_completed_pk PRIMARY KEY (id) );

And then configure the repository to enable this behavior as shown
below:

xml <bean id="repo3"
class="org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository">
<property name="repositoryName" value="aggregationRepo3"/> <property
name="transactionManager" ref="txManager3"/> <property name="dataSource"
ref="dataSource3"/> <!-- configure to store the message body and
following headers as text in the repo --> <property
name="storeBodyAsText" value="true"/> <property
name="headersToStoreAsText"> <list> <value>companyName</value>
<value>accountName</value> </list> </property> </bean>

Codec (Serialization)

Since they can contain any type of payload, Exchanges are not
serializable by design. It is converted into a byte array to be stored
in a database BLOB field. All those conversions are handled by the
`JdbcCodec` class. One detail of the code requires your attention: the
`ClassLoadingAwareObjectInputStream`.

The `ClassLoadingAwareObjectInputStream` has been reused from the
http://activemq.apache.org/[Apache ActiveMQ] project. It wraps an
`ObjectInputStream` and use it with the `ContextClassLoader` rather than
the `currentThread` one. The benefit is to be able to load classes
exposed by other bundles. This allows the exchange body and headers to
have custom types object references.

Transaction

A Spring `PlatformTransactionManager` is required to orchestrate
transaction.

Service (Start/Stop)

The `start` method verify the connection of the database and the
presence of the required tables. If anything is wrong it will fail
during starting.

Aggregator configuration

Depending on the targeted environment, the aggregator might need some
configuration. As you already know, each aggregator should have its own
repository (with the corresponding pair of table created in the
database) and a data source. If the default lobHandler is not adapted to
your database system, it can be injected with the `lobHandler` property.

Here is the declaration for Oracle:

xml <bean id="lobHandler"
class="org.springframework.jdbc.support.lob.OracleLobHandler"> <property
name="nativeJdbcExtractor" ref="nativeJdbcExtractor"/> </bean> <bean
id="nativeJdbcExtractor"
class="org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor"/>
<bean id="repo"
class="org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository">
<property name="transactionManager" ref="transactionManager"/> <property
name="repositoryName" value="aggregation"/> <property name="dataSource"
ref="dataSource"/> <!-- Only with Oracle, else use default --> <property
name="lobHandler" ref="lobHandler"/> </bean>

Optimistic locking

From *Camel 2.12* onwards you can turn on `optimisticLocking` and use
this JDBC based aggregation repository in a clustered environment where
multiple Camel applications shared the same database for the aggregation
repository. If there is a race condition there JDBC driver will throw a
vendor specific exception which the `JdbcAggregationRepository` can
react upon. To know which caused exceptions from the JDBC driver is
regarded as an optimistick locking error we need a mapper to do this.
Therefore there is a
`org.apache.camel.processor.aggregate.jdbc.JdbcOptimisticLockingExceptionMapper`
allows you to implement your custom logic if needed. There is a default
implementation
`org.apache.camel.processor.aggregate.jdbc.DefaultJdbcOptimisticLockingExceptionMapper`
which works as follows:

The following check is done:

If the caused exception is an `SQLException` then the SQLState is
checked if starts with 23.

If the caused exception is a `DataIntegrityViolationException`

If the caused exception class name has "ConstraintViolation" in its
name.

optional checking for FQN class name matches if any class names has been
configured

You can in addition add FQN classnames, and if any of the caused
exception (or any nested) equals any of the FQN class names, then its an
optimistick locking error.

Here is an example, where we define 2 extra FQN class names from the
JDBC vendor.

xml <bean id="repo"
class="org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository">
<property name="transactionManager" ref="transactionManager"/> <property
name="repositoryName" value="aggregation"/> <property name="dataSource"
ref="dataSource"/> <property name"jdbcOptimisticLockingExceptionMapper"
ref="myExceptionMapper"/> </bean> <!-- use the default mapper with extra
FQN class names from our JDBC driver --> <bean id="myExceptionMapper"
class="org.apache.camel.processor.aggregate.jdbc.DefaultJdbcOptimisticLockingExceptionMapper">
<property name="classNames"> <util:set>
<value>com.foo.sql.MyViolationExceptoion</value>
<value>com.foo.sql.MyOtherViolationExceptoion</value> </util:set>
</property> </bean>

 

link:endpoint-see-also.html[Endpoint See Also]

link:sql-stored-procedure.html[SQL Stored Procedure]

link:jdbc.html[JDBC]

[[BookComponentAppendix-TelegramComponent]]
Telegram Component
~~~~~~~~~~~~~~~~~~

*Available as of Camel 2.18*

The *Telegram* component provides access to the
https://core.telegram.org/bots/api[Telegram Bot API]. It allows a
Camel-based application to send and receive messages by acting as a Bot,
participating in direct conversations with normal users, private and
public groups or channels.

A Telegram Bot must be created before using this component, following
the instructions at the
https://core.telegram.org/bots#3-how-do-i-create-a-bot[Telegram Bot
developers home]. When a new Bot is created, the BotFather provides an
*authorization token* corresponding to the Bot. The authorization token
is a mandatory parameter for the *`camel-telegram`* endpoint.

[Note]
====
 **Note**

In order to allow the Bot to receive all messages exchanged within a
group or channel (not just the ones starting with a *`/`* character),
ask the BotFather to **disable the privacy mode**, using the
*`/setprivacy`* command.

====

Maven users will need to add the following dependency to
their *`pom.xml`* for this component:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-telegram</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIFormat.7]]
URI Format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
telegram:type/authorizationToken[?options]
----

[[BookComponentAppendix-Options.54]]
Options
^^^^^^^

The Telegram component has no options. However, the Telegram component
does support 24 endpoint options, which are listed below:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|=======================================================================
|Name |Group |Default |Description
|`authorizationToken` |`common` |  |*Required* The authorization token
for using the bot (ask the BotFather) e.g.,
*`654321531:HGF_dTra456323dHuOedsE343211fqr3t-H`*.

|`type` |`common` |  |*Required* The endpoint type. Currently only
the *`bots`* type is supported.

|`bridgeErrorHandler` |`consumer` |`false` |Allows for bridging the
consumer to the Camel routing Error Handler which mean any exceptions
occurred while the consumer is trying to pickup incoming messages or the
likes will now be processed as a message and handled by the routing
Error Handler. By default the consumer will use
the *`org.apache.camel.spi.ExceptionHandler`* to deal with exceptions
that will be logged at *`WARN`/`ERROR`* level and ignored.

|`limit` |`consumer` |`100` |Limit on the number of updates that can be
received in a single polling request.

|`sendEmptyMessageWhenIdle` |`consumer` |`false` |If the polling
consumer did not poll any files you can enable this option to send an
empty message (no body) instead.

|`timeout` |`consumer` |`30` |Timeout in seconds for long polling.
Put *`0`* for short polling or a bigger number for long polling. Long
polling produces shorter response time.

|`exceptionHandler` a|
`consumer` 

(advanced)

 |  a|
To let the consumer use a custom *`ExceptionHandler`*.

*Note*: if the option *`bridgeErrorHandler`* is enabled then this
options is not in use. By default the consumer will deal with exceptions
that will be logged at *`WARN`/`ERROR`* level and ignored.

|`pollStrategy` a|
`consumer` 

(advanced)

 |  |A pluggable *`org.apache.camel.PollingConsumerPollingStrategy`*
allowing you to provide your custom implementation to control error
handling usually occurred during the poll operation before an Exchange
have been created and being routed in Camel.

|`chatId` |`producer` |  |The identifier of the chat that will receive
the produced messages. Chat ids can be first obtained from incoming
messages e.g., when a telegram user starts a conversation with a bot its
client sends automatically a *`/start`* message containing the chat id.
It is an optional parameter as the chat id can be set dynamically for
each outgoing message (using body or headers).

|`exchangePattern` |`advanced` |`InOnly` |Sets the default exchange
pattern when creating an exchange

|`synchronous` |`advanced` |`false` |Sets whether synchronous processing
should be strictly used or Camel is allowed to use asynchronous
processing (if supported).

|`backoffErrorThreshold` |`scheduler` |  |The number of subsequent error
polls (failed due some error) that should happen before
the *`backoffMultiplier`* should kick-in.

|`backoffIdleThreshold` |`scheduler` |  |The number of subsequent idle
polls that should happen before the *`backoffMultiplier`* should
kick-in.

|`backoffMultiplier` |`scheduler` |  |To let the scheduled polling
consumer back-off if there has been a number of subsequent idles/errors
in a row. The multiplier is then the number of polls that will be
skipped before the next actual attempt is happening again. When this
option is in use then *`backoffIdleThreshold`*
and/or *`backoffErrorThreshold`* must also be configured.

|`delay` |`scheduler` |`500` a|
Milliseconds before the next poll. You can also specify time values
using units such as:

* *`60s`* (60 seconds)
* *`5m30s`* (5 minutes and 30 seconds)
* *`1h`* (1 hour)

|`greedy` |`scheduler` |`false` |If greedy is enabled then
the *`ScheduledPollConsumer`* will run immediately again if the previous
run polled 1 or more messages.

|`initialDelay` |`scheduler` |`1000` a|
Milliseconds before the first poll starts. You can also specify time
values using units such as:

* *`60s`* (60 seconds)
* *`5m30s`* (5 minutes and 30 seconds)
* *`1h`* (1 hour)

|`runLoggingLevel` |`scheduler` |`TRACE` |The consumer logs a
start/complete log line when it polls. This option allows you to
configure the logging level for that.

|`scheduledExecutorService` |`scheduler` |  |Allows for configuring a
custom/shared thread pool to use for the consumer. By default each
consumer has its own single threaded thread pool.

|`scheduler` |`scheduler` |`none` |To use a cron scheduler from either
camel-spring or *`camel-quartz2`* component

|`schedulerProperties` |`scheduler` |  |To configure additional
properties when using a custom scheduler or any of the Quartz2 Spring
based scheduler.

|`startScheduler` |`scheduler` |`true` |Whether the scheduler should be
auto started.

|`timeUnit` |`scheduler` |`ms` |Time unit for *`initialDelay`* and delay
options.

|`useFixedDelay` |`scheduler` |`true` a|
Controls if fixed delay or fixed rate is used.

See *`ScheduledExecutorService`* in JDK for details.

|=======================================================================

[[BookComponentAppendix-MessageHeaders.18]]
Message Headers
^^^^^^^^^^^^^^^

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Name |Description
|`CamelTelegramChatId` |This header is used by the producer endpoint in
order to resolve the chat id that will receive the message. The
recipient chat id can be placed (in order of priority) in message body,
in the *`CamelTelegramChatId`* header or in the endpoint configuration
(*`chatId`* option). This header is also present in all incoming
messages.

|`CamelTelegramMediaType` |This header is used to identify the media
type when the outgoing message is composed of pure binary data. Possible
values are strings or enum values belonging to the
*`org.apache.camel.component.telegram.TelegramMediaType`* enumeration.

|`CamelTelegramMediaTitleCaption` |This header is used to provide a
caption or title for outgoing binary messages.
|=======================================================================

[[BookComponentAppendix-Usage.9]]
Usage
^^^^^

The Telegram component supports both consumer and producer endpoints. It
can also be used in *reactive chat-bot mode* (to consume, then produce
messages).

[[BookComponentAppendix-ProducerExample.1]]
Producer Example
++++++++++++++++

The following is a basic example of how to send a message to a Telegram
chat through the Telegram Bot API.

in Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start")
  .to("telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L");
----

or in Spring XML:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="direct:start"/>
    <to uri="telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L"/>
</route>
----

The code
*`123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L`*
is the *authorization token* corresponding to the Bot.

When using the producer endpoint without specifying the *chat id*
option, the target chat will be identified using information contained
in the body or headers of the message. The following message bodies are
allowed for a producer endpoint (messages of type *`OutgoingXXXMessage`*
belong to the package *`org.apache.camel.component.telegram.model`*)

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Java Type |Description
|`OutgoingTextMessage` |To send a text message to a chat.

|`OutgoingPhotoMessage` |To send a photo (JPG, PNG) to a chat.

|`OutgoingAudioMessage` |To send a mp3 audio to a chat.

|`OutgoingVideoMessage` |To send a mp4 video to a chat.

|`byte[]` |To send any media type supported. It requires the
*`CamelTelegramMediaType`* header to be set to the appropriate media
type.

|`String` |To send a text message to a chat. It gets converted
automatically into a *`OutgoingTextMessage`*
|=======================================================================

[[BookComponentAppendix-ConsumerExample.1]]
Consumer Example
++++++++++++++++

The following is a basic example of how to receive all messages that
telegram users are sending to the configured Bot.

In Java DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L")
  .bean(ProcessorBean.class)
----

or in Spring XML:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L"/>
    <bean ref="myBean"/>
</route>

<bean id="myBean" class="com.example.MyBean"/>
----

The *`MyBean`* is a simple bean that will receive the messages:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
public class MyBean {
    public void process(String message) {
        // or Exchange, or org.apache.camel.component.telegram.model.IncomingMessage (or both)
        // do process
    }
}
----

Supported types for incoming messages are

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Java Type |Description
|`IncomingMessage` |The full object representation of an incoming
message

|`String` |The content of the message, for text messages only
|=======================================================================

[[BookComponentAppendix-ReactiveChat-BotExample]]
Reactive Chat-Bot Example
+++++++++++++++++++++++++

The reactive chat-bot mode is a simple way of using the Camel component
to build a simple chat bot that replies directly to chat messages
received from the Telegram users.

The following is a basic configuration of the chat-bot in Java DSL

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L")
  .bean(ChatBotLogic.class)
  .to("telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L");
----

or in Spring XML

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<route>
    <from uri="telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L"/>
    <bean ref="chatBotLogic"/>
    <to uri="telegram:bots/123456789:AAE_dLq5C19xwGjw3yiC2NvEUrZcejK21-Q987654321:AAE_dLq5C19xwOmg5yiC2NvSrkT3wj5Q1-L"/>
</route>

<bean id="chatBotLogic" class="com.example.ChatBotLogic"/>
----

The *`ChatBotLogic`* is a simple bean that implements a generic
String-to-String method.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
public class ChatBotLogic {
    public String chatBotProcess(String message) {
        if( "do-not-reply".equals(message) ) {
            return null; // no response in the chat
        }
        return "echo from the bot: " + message; // echoes the message
    }
}
----

Every non-null string returned by the *`chatBotProcess()`* method is
automatically routed to the chat that originated the request (as
the *`CamelTelegramChatId`* header is used to route the message).

[[BookComponentAppendix-TestComponent]]
Test Component
~~~~~~~~~~~~~~

link:testing.html[Testing] of distributed and asynchronous processing is
notoriously difficult. The link:mock.html[Mock], link:test.html[Test]
and link:dataset.html[DataSet] endpoints work great with the
link:testing.html[Camel Testing Framework] to simplify your unit and
integration testing using
link:enterprise-integration-patterns.html[Enterprise Integration
Patterns] and Camel's large range of link:components.html[Components]
together with the powerful link:bean-integration.html[Bean Integration].

The *`test`* component extends the link:mock.html[Mock] component to
support pulling messages from another endpoint on startup to set the
expected message bodies on the underlying link:mock.html[Mock] endpoint.
That is, you use the test endpoint in a route and messages arriving on
it will be implicitly compared to some expected messages extracted from
some other location.

So you can use, for example, an expected set of message bodies as files.
This will then set up a properly configured link:mock.html[Mock]
endpoint, which is only valid if the received messages match the number
of expected messages and their message payloads are equal.

Maven users will need to add the following dependency to their
*`pom.xml`* for this component when using *Camel 2.8* or older:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-spring</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

From *Camel 2.9*: the link:test.html[Test] component is provided
directly in *`camel-core`*.

[[BookComponentAppendix-URIformat.65]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
test:expectedMessagesEndpointUri
----

Where *`expectedMessagesEndpointUri`* refers to some other
link:component.html[Component] URI that the expected message bodies are
pulled from before starting the test.

[[BookComponentAppendix-URIOptions.10]]
URI Options
^^^^^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`anyOrder` |`false` |*Camel 2.17:* Whether the expected messages should
arrive in the same order, or in any order.

|`delimiter` |`\n|\r` |*Camel 2.17:* The delimiter to use
when *`split=true`*. The delimiter can be a regular expression.

|`split` |`false` |*Camel 2.17:* If *`true`* messages loaded from the
test endpoint will be split using the defined *`delimiter`*.For example
to use a *`file`* endpoint to load a file where each line is an expected
message. 

|`timeout` |`2000` |*Camel 2.12:* The timeout to use when polling for
message bodies from the URI.
|=======================================================================

[[BookComponentAppendix-Example.10]]
Example
^^^^^^^

For example, you could write a test case as follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("seda:someEndpoint")
  .to("test:file://data/expectedOutput?noop=true");
----

If your test then invokes the
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#assertIsSatisfied(org.apache.camel.CamelContext)[MockEndpoint.assertIsSatisfied(camelContext)
method], your test case will perform the necessary assertions.

To see how you can set other expectations on the test endpoint, see the
link:mock.html[Mock] component.

[[BookComponentAppendix-SeeAlso.34]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:spring-testing.html[Spring Testing]

[[BookComponentAppendix-TimerComponent]]
Timer Component
~~~~~~~~~~~~~~~

The *timer:* component is used to generate message exchanges when a
timer fires You can only consume events from this endpoint.

[[BookComponentAppendix-URIformat.66]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
timer:name[?options]
----

Where `name` is the name of the `Timer` object, which is created and
shared across endpoints. So if you use the same name for all your timer
endpoints, only one `Timer` object and thread will be used.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

*Note:* The IN body of the generated exchange is `null`. So
`exchange.getIn().getBody()` returns `null`.

[Tip]
====
 **Advanced Scheduler**

See also the link:quartz.html[Quartz] component that supports much more
advanced scheduling.

====

[Tip]
====
 **Specify time in human friendly format**

In *Camel 2.3* onwards you can specify the time in
link:how-do-i-specify-time-period-in-a-human-friendly-syntax.html[human
friendly syntax].

====

[[BookComponentAppendix-Options.55]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`time` |`null` |A `java.util.Date` the *first* event should be
generated. If using the URI, the pattern expected is:
`yyyy-MM-dd HH:mm:ss` or `yyyy-MM-dd'T'HH:mm:ss`.

|`pattern` |`null` |Allows you to specify a custom `Date` pattern to use
for setting the time option using URI syntax.

|`period` |`1000` |If greater than 0, generate periodic events every
`period` milliseconds. +
You can also specify time values using units, such as 60s (60 seconds),
5m30s (5 minutes and 30 seconds), and 1h (1 hour).

|`delay` |0 / `1000` |The number of milliseconds to wait before the
first event is generated. Should not be used in conjunction with the
`time` option. +
You can also specify time values using units, such as 60s (60 seconds),
5m30s (5 minutes and 30 seconds), and 1h (1 hour).  +
Before *Camel 2.11* the default value is 0 +
From **Camel 2.11** the default value is `1000`From *Camel 2.17 it* is
possible to specify a negative delay. In this scenario the timer will
generate and fire events as soon as possible.

|`fixedRate` |`false` |Events take place at approximately regular
intervals, separated by the specified period.

|`daemon` |`true` |Specifies whether or not the thread associated with
the timer endpoint runs as a daemon.

|`repeatCount` |`0` |*Camel 2.8:* Specifies a maximum limit of number of
fires. So if you set it to 1, the timer will only fire once. If you set
it to 5, it will only fire five times. A value of zero or negative means
fire forever.
|=======================================================================

[[BookComponentAppendix-ExchangeProperties]]
Exchange Properties
^^^^^^^^^^^^^^^^^^^

When the timer is fired, it adds the following information as properties
to the `Exchange`:

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`Exchange.TIMER_NAME` |`String` |The value of the `name` option.

|`Exchange.TIMER_TIME` |`Date` |The value of the `time` option.

|`Exchange.TIMER_PERIOD` |`long` |The value of the `period` option.

|`Exchange.TIMER_FIRED_TIME` |`Date` |The time when the consumer fired.

|`Exchange.TIMER_COUNTER` |`Long` |*Camel 2.8:* The current fire
counter. Starts from 1.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.19]]
Message Headers
^^^^^^^^^^^^^^^

When the timer is fired, it adds the following information as headers to
the IN message

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Type |Description
|`Exchange.TIMER_FIRED_TIME` |`java.util.Date` |The time when the
consumer fired
|=======================================================================

[[BookComponentAppendix-Sample.5]]
Sample
^^^^^^

To set up a route that generates an event every 60 seconds:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
   from("timer://foo?fixedRate=true&period=60000").to("bean:myBean?method=someMethodName");
----

[Tip]
====


Instead of 60000 you can use period=60s which is more friendly to read.

====

The above route will generate an event and then invoke the
`someMethodName` method on the bean called `myBean` in the
link:registry.html[Registry] such as JNDI or link:spring.html[Spring].

And the route in Spring DSL:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <route>
    <from uri="timer://foo?fixedRate=true&amp;period=60000"/>
    <to uri="bean:myBean?method=someMethodName"/>
  </route>
----

[[BookComponentAppendix-Firingassoonaspossible]]
Firing as soon as possible
++++++++++++++++++++++++++

[[BookComponentAppendix-AvailableasofCamel2.17]]
Available as of Camel 2.17
++++++++++++++++++++++++++

You may want to fire messages in a Camel route as soon as possible you
can use a negative delay:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <route>
    <from uri="timer://foo?delay=-1"/>
    <to uri="bean:myBean?method=someMethodName"/>
  </route>
----

In this way the timer will fire messages immediately.

You can also specify a repeatCount parameter in conjunction with a
negative delay to stop firing messages after a fixed number has been
reached.

If you don't specify a repeatCount then the timer will continue firing
messages until the route will be stopped. 

[[BookComponentAppendix-Firingonlyonce]]
Firing only once
++++++++++++++++

*Available as of Camel 2.8*

You may want to fire a message in a Camel route only once, such as when
starting the route. To do that you use the repeatCount option as shown:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <route>
    <from uri="timer://foo?repeatCount=1"/>
    <to uri="bean:myBean?method=someMethodName"/>
  </route>
----

[[BookComponentAppendix-SeeAlso.35]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:quartz.html[Quartz]

[[BookComponentAppendix-ValidationComponent]]
Validation Component
~~~~~~~~~~~~~~~~~~~~

The Validation component performs XML validation of the message body
using the JAXP Validation API and based on any of the supported XML
schema languages, which defaults to http://www.w3.org/XML/Schema[XML
Schema]

Note that the link:jing.html[Jing] component also supports the following
useful schema languages:

* http://relaxng.org/compact-tutorial-20030326.html[RelaxNG Compact
Syntax]
* http://relaxng.org/[RelaxNG XML Syntax]

The link:msv.html[MSV] component also supports
http://relaxng.org/[RelaxNG XML Syntax].

[[BookComponentAppendix-URIformat.67]]
URI format
^^^^^^^^^^

validator:someLocalOrRemoteResource

Where *someLocalOrRemoteResource* is some URL to a local resource on the
classpath or a full URL to a remote resource or resource on the file
system which contains the XSD to validate against. For example:

* `msv:org/foo/bar.xsd`
* `msv:file:../foo/bar.xsd`
* `msv:http://acme.com/cheese.xsd`
* `validator:com/mypackage/myschema.xsd`

Maven users will need to add the following dependency to their `pom.xml`
for this component when using *Camel 2.8* or older:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-spring</artifactId> <version>x.x.x</version> <!-- use
the same version as your Camel core version --> </dependency>

From Camel 2.9 onwards the link:validation.html[Validation] component is
provided directly in the camel-core.

[[BookComponentAppendix-Options.56]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|resourceResolverFactory |DefaultValidatorResourceResolverFactory
|*Camel 2.17*: Reference to a
`org.apache.camel.component.validator.ValidatorResourceResolverFactory `which
creates a resource resolver per endpoint`. `The default implementation
creates an instance of
`org.apache.camel.component.validator.DefaultLSResourceResolver per endpoint `which
creates the default resource resolver
`org.apache.camel.component.validator.DefaultLSResourceResolver. The default resource resolver`
reads the schema files from the classpath and the file system. This
option instead of the option `resourceResolver` shall be used when the
resource resolver depends on the resource URI of the root schema
document specified in the endpoint; for example, if you want to extend
the default resource resolver. This option is also available on the
validator component, so that you can set the resource resolver factory
only once for all endpoints.

|`resourceResolver` |`null` |*Camel 2.9:* Reference to a
`org.w3c.dom.ls.LSResourceResolver` in the link:registry.html[Registry].

|`useDom` |`false` |Whether `DOMSource`/`DOMResult` or
`SaxSource`/`SaxResult` should be used by the validator.

|`useSharedSchema` |`true` |*Camel 2.3:* Whether the `Schema` instance
should be shared or not. This option is introduced to work around a
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6773084[JDK 1.6.x
bug]. Xerces should not have this issue.

|`failOnNullBody` |`true` |*Camel 2.9.5/2.10.3:* Whether to fail if no
body exists.

|`headerName` |`null` |*Camel 2.11:* To validate against a header
instead of the message body.

|`failOnNullHeader` |`true` |*Camel 2.11:* Whether to fail if no header
exists when validating against a header.
|=======================================================================

[[BookComponentAppendix-Example.11]]
Example
^^^^^^^

The following
http://svn.apache.org/repos/asf/camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/component/validator/camelContext.xml[example]
shows how to configure a route from endpoint *direct:start* which then
goes to one of two endpoints, either *mock:valid* or *mock:invalid*
based on whether or not the XML matches the given schema (which is
supplied on the
classpath).\{snippet:id=example|lang=xml|url=camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/component/validator/camelContext.xml}

[[BookComponentAppendix-Advanced:JMXmethodclearCachedSchema]]
Advanced: JMX method clearCachedSchema
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since *Camel 2.17*, you can force that the cached schema in the
validator endpoint is cleared and reread with the next process call with
the JMX operation `clearCachedSchema. `You can also use this method to
programmatically clear the cache. This method is available on the
`ValidatorEndpoint `class`.`

[[BookComponentAppendix-Advanced:GlobalOption"CamelXmlValidatorAccessExternalDTD"]]
Advanced: Global Option "CamelXmlValidatorAccessExternalDTD"
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since *Camel 2.19, 2.18.3, and  2.17.6* the default schema factory no
longer allows reading external DTDs and external DTD entities. To
achieve the old behavior where it was possible to access external DTDs
and DTDs entities you can set the CamelContext global option
 "CamelXmlValidatorAccessExternalDTD" to "true". Prior to 2.19 global
options where called properties.

link:endpoint-see-also.html[Endpoint See Also]

[[BookComponentAppendix-Velocity]]
Velocity
~~~~~~~~

The *velocity:* component allows you to process a message using an
http://velocity.apache.org/[Apache Velocity] template. This can be ideal
when using link:templating.html[Templating] to generate responses for
requests.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

xml<dependency> <groupId>org.apache.camel</groupId>
<artifactId>camel-velocity</artifactId> <version>x.x.x</version> <!--
use the same version as your Camel core version --> </dependency>

[[BookComponentAppendix-URIformat.68]]
URI format
^^^^^^^^^^

velocity:templateName[?options]

Where *templateName* is the classpath-local URI of the template to
invoke; or the complete URL of the remote template (eg:
file://folder/myfile.vm).

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.57]]
Options
^^^^^^^

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Option |Default |Description
|`loaderCache` |`true` |Velocity based file loader cache.

|`contentCache` |`true` |Cache for the resource content when it is
loaded. +
Note : as of Camel 2.9 cached resource content can be cleared via JMX
using the endpoint's `clearContentCache` operation.

|`encoding` |`null` |Character encoding of the resource content.

|`propertiesFile` |`null` |New option in Camel 2.1: The URI of the
properties file which is used for VelocityEngine initialization.
|=======================================================================

[[BookComponentAppendix-MessageHeaders.20]]
Message Headers
^^^^^^^^^^^^^^^

The velocity component sets a couple headers on the message (you can't
set these yourself and from Camel 2.1 velocity component will not set
these headers which will cause some side effect on the dynamic template
support):

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Header |Description
|`CamelVelocityResourceUri` |The *templateName* as a `String` object.

|`CamelVelocitySupplementalContext` |*Camel 2.16:* To add additional
information to the used VelocityContext. The value of this header should
be a `Map` with key/values that will added (override any existing key
with the same name). +
This can be used to pre setup some common key/values you want to reuse
in your velocity endpoints.
|=======================================================================

Headers set during the Velocity evaluation are returned to the message
and added as headers. Then its kinda possible to return values from
Velocity to the Message.

For example, to set the header value of `fruit` in the Velocity template
`.tm`:

$in.setHeader("fruit", "Apple")

The `fruit` header is now accessible from the `message.out.headers`.

[[BookComponentAppendix-VelocityContext]]
Velocity Context
^^^^^^^^^^^^^^^^

Camel will provide exchange information in the Velocity context (just a
`Map`). The `Exchange` is transfered as:

confluenceTableSmall

[width="100%",cols="50%,50%",options="header",]
|======================================================================
|key |value
|`exchange` |The `Exchange` itself.
|`exchange.properties` |The `Exchange` properties.
|`headers` |The headers of the In message.
|`camelContext` |The Camel Context instance.
|`request` |The In message.
|`in` |The In message.
|`body` |The In message body.
|`out` |The Out message (only for InOut message exchange pattern).
|`response` |The Out message (only for InOut message exchange pattern).
|======================================================================

Since Camel-2.14, you can setup a custom Velocity Context yourself by
setting the message header **CamelVelocityContext **just like this

java VelocityContext velocityContext = new VelocityContext(variableMap);
exchange.getIn().setHeader("CamelVelocityContext", velocityContext);

 

[[BookComponentAppendix-Hotreloading.1]]
Hot reloading
^^^^^^^^^^^^^

The Velocity template resource is, by default, hot reloadable for both
file and classpath resources (expanded jar). If you set
`contentCache=true`, Camel will only load the resource once, and thus
hot reloading is not possible. This scenario can be used in production,
when the resource never changes.

[[BookComponentAppendix-Dynamictemplates.1]]
Dynamic templates
^^^^^^^^^^^^^^^^^

*Available as of Camel 2.1* +
Camel provides two headers by which you can define a different resource
location for a template or the template content itself. If any of these
headers is set then Camel uses this over the endpoint configured
resource. This allows you to provide a dynamic template at runtime.

confluenceTableSmall

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Header |Type |Description
|CamelVelocityResourceUri |String |*Camel 2.1:* A URI for the template
resource to use instead of the endpoint configured.

|CamelVelocityTemplate |String |*Camel 2.1:* The template to use instead
of the endpoint configured.
|=======================================================================

[[BookComponentAppendix-Samples.14]]
Samples
^^^^^^^

For example you could use something like

from("activemq:My.Queue"). to("velocity:com/acme/MyResponse.vm");

To use a Velocity template to formulate a response to a message for
InOut message exchanges (where there is a `JMSReplyTo` header).

If you want to use InOnly and consume the message and send it to another
destination, you could use the following route:

from("activemq:My.Queue"). to("velocity:com/acme/MyResponse.vm").
to("activemq:Another.Queue");

And to use the content cache, e.g. for use in production, where the
`.vm` template never changes:

from("activemq:My.Queue").
to("velocity:com/acme/MyResponse.vm?contentCache=true").
to("activemq:Another.Queue");

And a file based resource:

from("activemq:My.Queue").
to("velocity:file://myfolder/MyResponse.vm?contentCache=true").
to("activemq:Another.Queue");

In *Camel 2.1* it's possible to specify what template the component
should use dynamically via a header, so for example:

from("direct:in").
setHeader("CamelVelocityResourceUri").constant("path/to/my/template.vm").
to("velocity:dummy");

In *Camel 2.1* it's possible to specify a template directly as a header
the component should use dynamically via a header, so for example:

from("direct:in"). setHeader("CamelVelocityTemplate").constant("Hi this
is a velocity template that can do templating $\{body}").
to("velocity:dummy");

[[BookComponentAppendix-TheEmailSample.2]]
The Email Sample
^^^^^^^^^^^^^^^^

In this sample we want to use Velocity templating for an order
confirmation email. The email template is laid out in Velocity as:

Dear $\{headers.lastName}, $\{headers.firstName} Thanks for the order of
$\{headers.item}. Regards Camel Riders Bookstore $\{body}

And the java
code:\{snippet:id=e1|lang=java|url=camel/trunk/components/camel-velocity/src/test/java/org/apache/camel/component/velocity/VelocityLetterTest.java}link:endpoint-see-also.html[Endpoint
See Also]

[[BookComponentAppendix-VMComponent]]
VM Component
~~~~~~~~~~~~

The *vm:* component provides asynchronous
http://www.eecs.harvard.edu/~mdw/proj/seda/[SEDA] behavior, exchanging
messages on a
http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/BlockingQueue.html[BlockingQueue]
and invoking consumers in a separate thread pool.

This component differs from the link:seda.html[Seda] component in that
VM supports communication across CamelContext instances - so you can use
this mechanism to communicate across web applications (provided that
`camel-core.jar` is on the `system/boot` classpath).

VM is an extension to the link:seda.html[Seda] component.

[[BookComponentAppendix-URIformat.69]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
vm:queueName[?options]
----

Where *`queueName`* can be any string to uniquely identify the endpoint
within the JVM (or at least within the classloader that loaded
camel-core.jar)

You can append query options to the URI in the following format:
`?option=value&option=value&...`

**Before Camel 2.3 - Same URI must be used for both producer and
consumer**

An exactly identical link:vm.html[VM] endpoint URI *must* be used for
both the producer and the consumer endpoint. Otherwise, Camel will
create a second link:vm.html[VM] endpoint despite that the `queueName`
portion of the URI is identical. For example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:foo").to("vm:bar?concurrentConsumers=5");

from("vm:bar?concurrentConsumers=5").to("file://output");
----

Notice that we have to use the full URI, including options in both the
producer and consumer.

In Camel 2.4 this has been fixed so that only the queue name must match.
Using the queue name `bar`, we could rewrite the previous exmple as
follows:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:foo").to("vm:bar");

from("vm:bar?concurrentConsumers=5").to("file://output");
----

[[BookComponentAppendix-Options.58]]
Options
^^^^^^^

See the link:seda.html[Seda] component for options and other important
usage details as the same rules apply to the link:vm.html[Vm] component.

[[BookComponentAppendix-Samples.15]]
Samples
^^^^^^^

In the route below we send exchanges across CamelContext instances to a
VM queue named `order.email`:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:in").bean(MyOrderBean.class).to("vm:order.email");
----

And then we receive exchanges in some other Camel context (such as
deployed in another `.war` application):

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("vm:order.email").bean(MyOrderEmailSender.class);
----

[[BookComponentAppendix-SeeAlso.36]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

* link:seda.html[Seda]

[[BookComponentAppendix-XMPPComponent]]
XMPP Component
~~~~~~~~~~~~~~

The *xmpp:* component implements an XMPP (Jabber) transport.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-xmpp</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.70]]
URI format
^^^^^^^^^^

[source,brush:,text;,gutter:,false;,theme:,Default]
----
xmpp://[login@]hostname[:port][/participant][?Options]
----

The component supports both room based and private person-person
conversations. +
The component supports both producer and consumer (you can get messages
from XMPP or send messages to XMPP). Consumer mode supports rooms
starting.

You can append query options to the URI in the following format,
`?option=value&option=value&...`

[[BookComponentAppendix-Options.59]]
Options
^^^^^^^

[width="100%",cols="50%,50%",options="header",]
|=======================================================================
|Name |Description
|`room` |If this option is specified, the component will connect to MUC
(Multi User Chat). Usually, the domain name for MUC is different from
the login domain. For example, if you are `superman@jabber.org` and want
to join the `krypton` room, then the room URL is
`krypton@conference.jabber.org`. Note the `conference` part. +
It is not a requirement to provide the full room JID. If the `room`
parameter does not contain the `@` symbol, the domain part will be
discovered and added by Camel

|`user` |User name (without server name). If not specified, anonymous
login will be attempted.

|`password` |Password.

|`resource` |XMPP resource. The default is `Camel`.

|`createAccount` |If `true`, an attempt to create an account will be
made. Default is `false`.

|`participant` |JID (Jabber ID) of person to receive messages. `room`
parameter has precedence over `participant`.

|`nickname` |Use nickname when joining room. If room is specified and
nickname is not, `user` will be used for the nickname.

|`serviceName` |The name of the service you are connecting to. For
Google Talk, this would be `gmail.com`.

|`testConnectionOnStartup` |*Camel 2.11* Specifies whether to test the
connection on startup. This is used to ensure that the XMPP client has a
valid connection to the XMPP server when the route starts. Camel throws
an exception on startup if a connection cannot be established. When this
option is set to false, Camel will attempt to establish a "lazy"
connection when needed by a producer, and will poll for a consumer
connection until the connection is established. Default is `true`.

|`connectionPollDelay` |*Camel 2.11* The amount of time in seconds
between polls to verify the health of the XMPP connection, or between
attempts to establish an initial consumer connection. Camel will try to
re-establish a connection if it has become inactive. Default is
`10 seconds`.

|pubsub |*Camel 2.15* Accept pubsub packets on input, default is false

|doc |*Camel 2.15* Set a doc header on the IN message containing a
Document form of the incoming packet; default is true if presence or
pubsub are true, otherwise false

|connectionConfiguration |*Camel 2.18:* To use an existing connection
configuration
|=======================================================================

[[BookComponentAppendix-HeadersandsettingSubjectorLanguage]]
Headers and setting Subject or Language
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Camel sets the message IN headers as properties on the XMPP message. You
can configure a `HeaderFilterStategy` if you need custom filtering of
headers. +
The *Subject* and *Language* of the XMPP message are also set if they
are provided as IN headers.

[[BookComponentAppendix-Examples.16]]
Examples
^^^^^^^^

User `superman` to join room `krypton` at `jabber` server with password,
`secret`:

[source,brush:,text;,gutter:,false;,theme:,Default]
----
xmpp://superman@jabber.org/?room=krypton@conference.jabber.org&password=secret
----

User `superman` to send messages to `joker`:

[source,brush:,text;,gutter:,false;,theme:,Default]
----
xmpp://superman@jabber.org/joker@jabber.org?password=secret
----

Routing example in Java:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("timer://kickoff?period=10000").
setBody(constant("I will win!\n Your Superman.")).
to("xmpp://superman@jabber.org/joker@jabber.org?password=secret");
----

Consumer configuration, which writes all messages from `joker` into the
queue, `evil.talk`.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("xmpp://superman@jabber.org/joker@jabber.org?password=secret").
to("activemq:evil.talk");
----

Consumer configuration, which listens to room messages:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("xmpp://superman@jabber.org/?password=secret&room=krypton@conference.jabber.org").
to("activemq:krypton.talk");
----

Room in short notation (no domain part):

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("xmpp://superman@jabber.org/?password=secret&room=krypton").
to("activemq:krypton.talk");
----

When connecting to the Google Chat service, you'll need to specify the
`serviceName` as well as your credentials:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("direct:start").
  to("xmpp://talk.google.com:5222/touser@gmail.com?serviceName=gmail.com&user=fromuser&password=secret").
  to("mock:result");
----

 

[[BookComponentAppendix-SeeAlso.37]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-XQuery]]
XQuery
~~~~~~

The *xquery:* component allows you to process a message using an
link:xquery.html[XQuery] template. This can be ideal when using
link:templating.html[Templating] to generate respopnses for requests.

Maven users will need to add the following dependency to their `pom.xml`
for this component:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-saxon</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

[[BookComponentAppendix-URIformat.71]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
xquery:templateName[?options]
----

Where *templateName* is the classpath-local URI of the template to
invoke; or the complete URL of the remote template.

For example you could use something like this:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:My.Queue").
  to("xquery:com/acme/mytransform.xquery");
----

To use an XQuery template to formulate a response to a message for InOut
message exchanges (where there is a `JMSReplyTo` header).

If you want to use InOnly, consume the message, and send it to another
destination, you could use the following route:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:My.Queue").
  to("xquery:com/acme/mytransform.xquery").
  to("activemq:Another.Queue");
----

[[BookComponentAppendix-SeeAlso.38]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]

[[BookComponentAppendix-XSLT]]
XSLT
~~~~

The *xslt:* component allows you to process a message using an
http://www.w3.org/TR/xslt[XSLT] template. This can be ideal when using
link:templating.html[Templating] to generate respopnses for requests.

[[BookComponentAppendix-URIformat.72]]
URI format
^^^^^^^^^^

[source,brush:,java;,gutter:,false;,theme:,Default]
----
xslt:templateName[?options]
----

Where *templateName* is the classpath-local URI of the template to
invoke; or the complete URL of the remote template. Refer to the
http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/core/io/DefaultResourceLoader.html[Spring
Documentation for more detail of the URI syntax]

You can append query options to the URI in the following format,
`?option=value&option=value&...`

Here are some example URIs

[width="100%",cols="50%,50%",options="header",]
|=============================================================
|URI |Description
a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
xslt:com/acme/mytransform.xsl
----

 |refers to the file com/acme/mytransform.xsl on the classpath
a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
xslt:file:///foo/bar.xsl
----

 |refers to the file /foo/bar.xsl
a|
[source,brush:,java;,gutter:,false;,theme:,Default]
----
xslt:http://acme.com/cheese/foo.xsl
----

 |refers to the remote http resource
|=============================================================

Maven users will need to add the following dependency to their `pom.xml`
for this component when using *Camel 2.8* or older:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-spring</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

From Camel 2.9 onwards the link:xslt.html[XSLT] component is provided
directly in the camel-core.

[[BookComponentAppendix-Options.60]]
Options
^^^^^^^

[width="100%",cols="34%,33%,33%",options="header",]
|=======================================================================
|Name |Default Value |Description
|`converter` |`null` |Option to override default
http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/converter/jaxp/XmlConverter.html[XmlConverter].
Will lookup for the converter in the link:registry.html[Registry]. The
provided converted must be of type
org.apache.camel.converter.jaxp.XmlConverter.

|`transformerFactory` |`null` |Option to override default
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/TransformerFactory.html[TransformerFactory].
Will lookup for the transformerFactory in the
link:registry.html[Registry]. The provided transformer factory must be
of type javax.xml.transform.TransformerFactory.

|`transformerFactoryClass` |`null` |Option to override default
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/TransformerFactory.html[TransformerFactory].
Will create a TransformerFactoryClass instance and set it to the
converter.

|`uriResolverFactory` |`DefaultXsltUriResolverFactory` |*Camel 2.17*:
 Reference to
a `org.apache.camel.component.``xslt``.``XsltUriResolverFactory` which
creates an URI resolver per endpoint`.`The default implementation
returns an instance
of `org.apache.camel.component.xslt.``DefaultXsltUriResolverFactory`
which creates the default URI
resolver `org.apache.camel.builder.xml`.XsltUriResolver per endpoint.
The default URI resolver reads XSLT documents from the classpath and the
file system. This option instead of the option `uriResolver` shall be
used when the URI resolver depends on the resource URI of the root XSLT
document specified in the endpoint; for example, if you want to extend
the default URI resolver. This option is also available on the XSLT
component, so that you can set the resource resolver factory only once
for all endpoints.

|`uriResolver` |`null` |*Camel 2.3*: Allows you to use a custom
`javax.xml.transformation.URIResolver`. Camel will by default use its
own implementation `org.apache.camel.builder.xml.XsltUriResolver` which
is capable of loading from classpath.

|`resultHandlerFactory` |`null` |*Camel 2.3:* Allows you to use a custom
`org.apache.camel.builder.xml.ResultHandlerFactory` which is capable of
using custom `org.apache.camel.builder.xml.ResultHandler` types.

|`failOnNullBody` |`true` |*Camel 2.3:* Whether or not to throw an
exception if the input body is null.

|`deleteOutputFile` |`false` |*Camel 2.6:* If you have `output=file`
then this option dictates whether or not the output file should be
deleted when the link:exchange.html[Exchange] is done processing. For
example suppose the output file is a temporary file, then it can be a
good idea to delete it after use.

|`output` |`string` |*Camel 2.3:* Option to specify which output type to
use. Possible values are: `string, bytes, DOM, file`. The first three
options are all in memory based, where as `file` is streamed directly to
a `java.io.File`. For `file` you *must* specify the filename in the IN
header with the key `Exchange.XSLT_FILE_NAME` which is also
`CamelXsltFileName`. Also any paths leading to the filename must be
created beforehand, otherwise an exception is thrown at runtime.

|`contentCache` |`true` |*Camel 2.6:* Cache for the resource content
(the stylesheet file) when it is loaded. If set to `false` Camel will
reload the stylesheet file on each message processing. This is good for
development. +
Note: from *Camel 2.9* a cached stylesheet can be forced to reload at
runtime via JMX using the `clearCachedStylesheet` operation.

|`allowStAX` |  |*Camel 2.8.3/2.9:* Whether to allow using StAX as the
`javax.xml.transform.Source`. The option is default `false` in Camel
2.11.3/2.12.2 or older. And default `true` in Camel 2.11.4/2.12.3
onwards.

|`transformerCacheSize` |`0` |*Camel 2.9.3/2.10.1:* The number of
`javax.xml.transform.Transformer` object that are cached for reuse to
avoid calls to `Template.newTransformer()`.

|`saxon` |`false` |*Camel 2.11:* Whether to use Saxon as the
`transformerFactoryClass`. If enabled then the class
`net.sf.saxon.TransformerFactoryImpl`. You would need to add Saxon to
the classpath.

|`saxonExtensionFunctions` |`null` |**Camel 2.17:** Allows to configure
one or more custom net.sf.saxon.lib.ExtensionFunctionDefinition. You
would need to add Saxon to the classpath. By setting this option, saxon
option will be turned out automatically.

|`errorListener` |  |*Camel 2.14:* Allows to configure to use a custom
`javax.xml.transform.ErrorListener`. Beware when doing this then the
default error listener which captures any errors or fatal errors and
store information on the Exchange as properties is not in use. So only
use this option for special use-cases.

|`entityResolver` |  |*Camel 2.18:* To use a custom
org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.
|=======================================================================

[[BookComponentAppendix-UsingXSLTendpoints]]
Using XSLT endpoints
^^^^^^^^^^^^^^^^^^^^

For example you could use something like

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:My.Queue").
  to("xslt:com/acme/mytransform.xsl");
----

To use an XSLT template to formulate a response for a message for InOut
message exchanges (where there is a `JMSReplyTo` header).

If you want to use InOnly and consume the message and send it to another
destination you could use the following route:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
from("activemq:My.Queue").
  to("xslt:com/acme/mytransform.xsl").
  to("activemq:Another.Queue");
----

[[BookComponentAppendix-GettingParametersintotheXSLTtoworkwith]]
Getting Parameters into the XSLT to work with
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

By default, all headers are added as parameters which are available in
the XSLT. +
To do this you will need to declare the parameter so it is then
_useable_.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<setHeader headerName="myParam"><constant>42</constant></setHeader>
<to uri="xslt:MyTransform.xsl"/>
----

And the XSLT just needs to declare it at the top level for it to be
available:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<xsl: ...... >

   <xsl:param name="myParam"/>
  
    <xsl:template ...>
----

[[BookComponentAppendix-SpringXMLversions]]
Spring XML versions
^^^^^^^^^^^^^^^^^^^

To use the above examples in Spring XML you would use something like

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <camelContext xmlns="http://activemq.apache.org/camel/schema/spring">
    <route>
      <from uri="activemq:My.Queue"/>
      <to uri="xslt:org/apache/camel/spring/processor/example.xsl"/>
      <to uri="activemq:Another.Queue"/>
    </route>
  </camelContext>
----

There is a
http://svn.apache.org/repos/asf/camel/trunk/components/camel-spring/src/test/java/org/apache/camel/spring/processor/XsltTest.java[test
case] along with
http://svn.apache.org/repos/asf/camel/trunk/components/camel-spring/src/test/resources/org/apache/camel/spring/processor/XsltTest-context.xml[its
Spring XML] if you want a concrete example.

[[BookComponentAppendix-Usingxsl:include]]
Using xsl:include
^^^^^^^^^^^^^^^^^

*Camel 2.2 or older* +
If you use xsl:include in your XSL files then in Camel 2.2 or older it
uses the default `javax.xml.transform.URIResolver` which means it can
only lookup files from file system, and its does that relative from the
JVM starting folder.

For example this include:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<xsl:include href="staff_template.xsl"/>
----

Will lookup the `staff_tempkalte.xsl` file from the starting folder
where the application was started.

*Camel 2.3 or newer* +
Now Camel provides its own implementation of `URIResolver` which allows
Camel to load included files from the classpath and more intelligent
than before.

For example this include:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<xsl:include href="staff_template.xsl"/>
----

Will now be located relative from the starting endpoint, which for
example could be:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
.to("xslt:org/apache/camel/component/xslt/staff_include_relative.xsl")
----

Which means Camel will locate the file in the *classpath* as
`org/apache/camel/component/xslt/staff_template.xsl`. +
This allows you to use xsl include and have xsl files located in the
same folder such as we do in the example
`org/apache/camel/component/xslt`.

You can use the following two prefixes `classpath:` or `file:` to
instruct Camel to look either in classpath or file system. If you omit
the prefix then Camel uses the prefix from the endpoint configuration.
If that neither has one, then classpath is assumed.

You can also refer back in the paths such as

[source,brush:,java;,gutter:,false;,theme:,Default]
----
    <xsl:include href="../staff_other_template.xsl"/>
----

Which then will resolve the xsl file under `org/apache/camel/component`.

[[BookComponentAppendix-Usingxsl:includeanddefaultprefix]]
Using xsl:include and default prefix
++++++++++++++++++++++++++++++++++++

When using xsl:include such as:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<xsl:include href="staff_template.xsl"/>
----

Then in Camel 2.10.3 and older, then Camel will use "classpath:" as the
default prefix, and load the resource from the classpath. This works for
most cases, but if you configure the starting resource to load from
file,

[source,brush:,java;,gutter:,false;,theme:,Default]
----
.to("xslt:file:etc/xslt/staff_include_relative.xsl")
----

.. then you would have to prefix all your includes with "file:" as well.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<xsl:include href="file:staff_template.xsl"/>
----

From Camel 2.10.4 onwards we have made this easier as Camel will use the
prefix from the endpoint configuration as the default prefix. So from
Camel 2.10.4 onwards you can do:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
<xsl:include href="staff_template.xsl"/>
----

Which will load the staff_template.xsl resource from the file system, as
the endpoint was configured with "file:" as prefix. +
You can still though explicit configure a prefix, and then mix and
match. And have both file and classpath loading. But that would be
unusual, as most people either use file or classpath based resources.

[[BookComponentAppendix-UsingSaxonextensionfunctions]]
Using Saxon extension functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since Saxon 9.2, writing extension functions has been supplemented by a
new mechanism, referred to
as http://www.saxonica.com/html/documentation/extensibility/integratedfunctions[integrated
extension functions] you can now easily use camel:

 

- Java example:

[source,brush:,java;,gutter:,false;,theme:,Default]
----
SimpleRegistry registry = new SimpleRegistry();
registry.put("function1", new MyExtensionFunction1());
registry.put("function2", new MyExtensionFunction2());

CamelContext context = new DefaultCamelContext(registry);
context.addRoutes(new RouteBuilder() {
    @Override
    public void configure() throws Exception {
        from("direct:start")
            .to("xslt:org/apache/camel/component/xslt/extensions/extensions.xslt?saxonExtensionFunctions=#function1,#function2");
    }
});
----

 

Spring example:

[source,brush:,xml;,gutter:,false;,theme:,Default]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
  <route>
    <from uri="direct:extensions"/>
    <to uri="xslt:org/apache/camel/component/xslt/extensions/extensions.xslt?saxonExtensionFunctions=#function1,#function2"/>
  </route>
</camelContext>


<bean id="function1" class="org.apache.camel.component.xslt.extensions.MyExtensionFunction1"/>
<bean id="function2" class="org.apache.camel.component.xslt.extensions.MyExtensionFunction2"/>
----

 

 

[[BookComponentAppendix-Dynamicstylesheets]]
Dynamic stylesheets
^^^^^^^^^^^^^^^^^^^

To provide a dynamic stylesheet at runtime you can define a dynamic URI.
See link:how-to-use-a-dynamic-uri-in-to.html[How to use a dynamic URI in
to()] for more information.

*Available as of Camel 2.9 (removed in 2.11.4, 2.12.3 and 2.13.0)* +
Camel provides the `CamelXsltResourceUri` header which you can use to
define a stylesheet to use instead of what is configured on the endpoint
URI. This allows you to provide a dynamic stylesheet at runtime.

[[BookComponentAppendix-Accessingwarnings,errorsandfatalErrorsfromXSLTErrorListener]]
Accessing warnings, errors and fatalErrors from XSLT ErrorListener
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Available as of Camel 2.14*

From Camel 2.14 onwards, any warning/error or fatalError is stored on
the current Exchange as a property with the
keys `Exchange.XSLT_ERROR`, `Exchange.XSLT_FATAL_ERROR`,
or `Exchange.XSLT_WARNING` which allows end users to get hold of any
errors happening during transformation.

For example in the stylesheet below, we want to terminate if a staff has
an empty dob field. And to include a custom error message using
xsl:message.

[source,brush:,java;,gutter:,false;,theme:,Default]
----
  <xsl:template match="/">
    <html>
      <body>
        <xsl:for-each select="staff/programmer">
          <p>Name: <xsl:value-of select="name"/><br />
            <xsl:if test="dob=''">
              <xsl:message terminate="yes">Error: DOB is an empty string!</xsl:message>
            </xsl:if>
          </p>
        </xsl:for-each>
      </body>
    </html>
  </xsl:template>
----

This information is not available on the Exchange stored as an Exception
that contains the message in the `getMessage()` method on the exception.
The exception is stored on the Exchange as a warning with the
key `Exchange.XSLT_WARNING.`

[[BookComponentAppendix-NotesonusingXSLTandJavaVersions]]
Notes on using XSLT and Java Versions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Here are some observations from Sameer, a Camel user, which he kindly
shared with us:

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
In case anybody faces issues with the XSLT endpoint please review these
points.

I was trying to use an xslt endpoint for a simple transformation from
one xml to another using a simple xsl. The output xml kept appearing
(after the xslt processor in the route) with outermost xml tag with no
content within.

No explanations show up in the DEBUG logs. On the TRACE logs however I
did find some error/warning indicating that the XMLConverter bean could
no be initialized.

After a few hours of cranking my mind, I had to do the following to get
it to work (thanks to some posts on the users forum that gave some
clue):

\1. Use the transformerFactory option in the route
`("xslt:my-transformer.xsl?transformerFactory=tFactory")` with the
`tFactory` bean having bean defined in the spring context for
`class="org.apache.xalan.xsltc.trax.TransformerFactoryImpl"`. +
2. Added the Xalan jar into my maven pom.

My guess is that the default xml parsing mechanism supplied within the
JDK (I am using 1.6.0_03) does not work right in this context and does
not throw up any error either. When I switched to Xalan this way it
works. This is not a Camel issue, but might need a mention on the xslt
component page.

Another note, jdk 1.6.0_03 ships with JAXB 2.0 while Camel needs 2.1.
One workaround is to add the 2.1 jar to the `jre/lib/endorsed` directory
for the jvm or as specified by the container.

Hope this post saves newbie Camel riders some time.
________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

[[BookComponentAppendix-SeeAlso.39]]
See Also
^^^^^^^^

* link:configuring-camel.html[Configuring Camel]
* link:component.html[Component]
* link:endpoint.html[Endpoint]
* link:getting-started.html[Getting Started]
